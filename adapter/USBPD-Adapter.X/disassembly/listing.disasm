Disassembly Listing for USBPD-Adapter
Generated From:
E:/Users/Alex/Documents/eagle/projects/USBPD Supply/adapter/USBPD-Adapter.X/dist/default/debug/USBPD-Adapter.X.debug.elf
May 14, 2023 6:18:27 PM

---  E:/Users/Alex/Documents/eagle/projects/USBPD Supply/adapter/USBPD-Adapter.X/util.c  ----------------
1:                 #include "util.h"
2:                 #include "mcc_generated_files/tmr2.h"
3:                 
4:                 
5:                 uint64_t util_currentTimeMicroseconds = 0;
6:                 
7:                 
8:                 uint64_t UTIL_GetTimeMicroseconds() {
0028E0  FA0010     LNK #0x10
0028E2  781F88     MOV W8, [W15++]
9:                     __builtin_disable_interrupts();
0028E4  A9E083     BCLR 0x83, #7
0028E6  000000     NOP
0028E8  000000     NOP
10:                    uint64_t upper = TMR2_SoftwareCounterGet();
0028EA  07FECD     RCALL TMR2_SoftwareCounterGet
0028EC  DE80CF     ASR W0, #15, W1
0028EE  B90961     MUL.SU W1, #1, W2
0028F0  BE9F00     MOV.D W0, [W14++]
0028F2  BE9702     MOV.D W2, [W14--]
11:                    uint64_t lower = TMR2_Counter32BitGet();
0028F4  07FE8D     RCALL TMR2_Counter32BitGet
0028F6  B81160     MUL.UU W2, #0, W2
0028F8  470268     ADD W14, #0x8, W4
0028FA  BE9A00     MOV.D W0, [W4++]
0028FC  BE9202     MOV.D W2, [W4--]
12:                    __builtin_enable_interrupts();
0028FE  A8E083     BSET 0x83, #7
002900  000000     NOP
002902  000000     NOP
13:                    
14:                    return (upper << 32) | lower;
002904  BE003E     MOV.D [W14++], W0
002906  BE012E     MOV.D [W14--], W2
002908  BE0302     MOV.D W2, W6
00290A  BE0200     MOV.D W0, W4
00290C  BE0304     MOV.D W4, W6
00290E  B82260     MUL.UU W4, #0, W4
002910  470068     ADD W14, #0x8, W0
002912  BE0150     MOV.D [++W0], W2
002914  BE0040     MOV.D [--W0], W0
002916  720000     IOR W4, W0, W0
002918  728081     IOR W5, W1, W1
00291A  730102     IOR W6, W2, W2
00291C  738183     IOR W7, W3, W3
15:                }
00291E  78044F     MOV [--W15], W8
002920  FA8000     ULNK
002922  060000     RETURN
16:                
17:                void UTIL_UpdateCurrentTime() {
002924  FA0000     LNK #0x0
18:                    util_currentTimeMicroseconds = UTIL_GetTimeMicroseconds();
002926  07FFDC     RCALL UTIL_GetTimeMicroseconds
002928  208C24     MOV #0x8C2, W4
00292A  BE9A00     MOV.D W0, [W4++]
00292C  BE9202     MOV.D W2, [W4--]
19:                }
00292E  FA8000     ULNK
002930  060000     RETURN
---  E:/Users/Alex/Documents/eagle/projects/USBPD Supply/adapter/USBPD-Adapter.X/ui.c  ------------------
1:                 #include "ui.h"
2:                 #include "mcc_generated_files/pin_manager.h"
3:                 #include "util.h"
4:                 
5:                 
6:                 #define UI_ENCODER_DEBOUNCE_TIME 5000
7:                 #define UI_ENCODER_FAST_THRESH 100000
8:                 #define UI_BUTTON_DEBOUNCE_TIME 10000
9:                 #define UI_BUTTON_LONGPRESS_THRESH 1000000
10:                
11:                
12:                int32_t ui_setVoltage = 500;
13:                int32_t ui_setCurrent = 50;
14:                int32_t ui_outVoltage = 0;
15:                int32_t ui_outCurrent = 0;
16:                bool ui_pps = false;
17:                bool ui_cc = false;
18:                bool ui_outputOn = false;
19:                
20:                static int8_t _ui_encoderInput = 0;
21:                static uint64_t _ui_encoderDebounceStart = 0;
22:                static bool _ui_buttonPressed = false;
23:                static bool _ui_buttonDebouncing = false;
24:                static uint64_t _ui_buttonDebounceStart = 0;
25:                
26:                static uint64_t _ui_lastEncChangeAt = 0;
27:                static uint64_t _ui_buttonPressedAt = 0;
28:                static bool _ui_longPressDone = false;
29:                
30:                UI_STATE ui_state = UI_IDLE;
31:                
32:                
33:                void _ui_encoderCallback() {
001C0A  FA000C     LNK #0xC
001C0C  BE9F88     MOV.D W8, [W15++]
001C0E  BE9F8A     MOV.D W10, [W15++]
34:                    uint64_t time = UTIL_GetTimeMicroseconds();
001C10  070667     RCALL UTIL_GetTimeMicroseconds
001C12  BE9F00     MOV.D W0, [W14++]
001C14  BE9702     MOV.D W2, [W14--]
35:                    
36:                    if (time - _ui_encoderDebounceStart < UI_ENCODER_DEBOUNCE_TIME) return;
001C16  2085C0     MOV #0x85C, W0
001C18  BE0150     MOV.D [++W0], W2
001C1A  BE0040     MOV.D [--W0], W0
001C1C  BE043E     MOV.D [W14++], W8
001C1E  BE052E     MOV.D [W14--], W10
001C20  540200     SUB W8, W0, W4
001C22  5C8281     SUBB W9, W1, W5
001C24  5D0302     SUBB W10, W2, W6
001C26  5D8383     SUBB W11, W3, W7
001C28  213870     MOV #0x1387, W0
001C2A  200001     MOV #0x0, W1
001C2C  B81160     MUL.UU W2, #0, W2
001C2E  E12000     CP.W W4, W0
001C30  E1A801     CPB.W W5, W1
001C32  E1B002     CPB.W W6, W2
001C34  E1B803     CPB.W W7, W3
001C36  360025     BRA LEU, .L6
001C82  000000     NOP
37:                    
38:                    uint16_t portb = PORTB;
001C38  470068     ADD W14, #0x8, W0
001C3A  8033C1     MOV PORTB, W1
001C3C  780801     MOV W1, [W0]
39:                    bool enc_a = (portb & 0x8000) > 0;
001C3E  470068     ADD W14, #0x8, W0
001C40  780010     MOV [W0], W0
001C42  DE00CF     LSR W0, #15, W1
001C44  47006A     ADD W14, #0xA, W0
001C46  784801     MOV.B W1, [W0]
40:                    bool enc_b = (portb & 0x4000) > 0;
001C48  470068     ADD W14, #0x8, W0
001C4A  780090     MOV [W0], W1
001C4C  240000     MOV #0x4000, W0
001C4E  608000     AND W1, W0, W0
001C50  A7F000     BTSC W0, #15
001C52  EA0000     NEG W0, W0
001C54  EA0000     NEG W0, W0
001C56  DE00CF     LSR W0, #15, W1
001C58  47006B     ADD W14, #0xB, W0
001C5A  784801     MOV.B W1, [W0]
41:                    
42:                    if (enc_a == enc_b) _ui_encoderInput--;
001C5C  47006A     ADD W14, #0xA, W0
001C5E  784090     MOV.B [W0], W1
001C60  47006B     ADD W14, #0xB, W0
001C62  784010     MOV.B [W0], W0
001C64  50CF80     SUB.B W1, W0, [W15]
001C66  3A0004     BRA NZ, .L4
001C68  BFC85B     MOV.B _ui_encoderInput, WREG
001C6A  E94000     DEC.B W0, W0
001C6C  B7E85B     MOV.B WREG, _ui_encoderInput
001C6E  370003     BRA .L5
43:                    else _ui_encoderInput++;
001C70  BFC85B     MOV.B _ui_encoderInput, WREG
001C72  E84000     INC.B W0, W0
001C74  B7E85B     MOV.B WREG, _ui_encoderInput
44:                    
45:                    _ui_encoderDebounceStart = time;
001C76  2085C0     MOV #0x85C, W0
001C78  BE023E     MOV.D [W14++], W4
001C7A  BE032E     MOV.D [W14--], W6
001C7C  BE9804     MOV.D W4, [W0++]
001C7E  BE9006     MOV.D W6, [W0--]
001C80  370001     BRA .L1
46:                }
001C84  BE054F     MOV.D [--W15], W10
001C86  BE044F     MOV.D [--W15], W8
001C88  FA8000     ULNK
001C8A  060000     RETURN
47:                
48:                void _ui_buttonCallback() {    
001C8C  FA0000     LNK #0x0
49:                    if (!_ui_buttonDebouncing) {
001C8E  BFC865     MOV.B _ui_buttonDebouncing, WREG
001C90  A20400     BTG.B W0, #0
001C92  E00400     CP0.B W0
001C94  320006     BRA Z, .L7
50:                        _ui_buttonDebouncing = true;
001C96  B3C010     MOV.B #0x1, W0
001C98  B7E865     MOV.B WREG, _ui_buttonDebouncing
51:                        _ui_buttonDebounceStart = UTIL_GetTimeMicroseconds();
001C9A  070622     RCALL UTIL_GetTimeMicroseconds
001C9C  208664     MOV #0x866, W4
001C9E  BE9A00     MOV.D W0, [W4++]
001CA0  BE9202     MOV.D W2, [W4--]
52:                    }
53:                }
001CA2  FA8000     ULNK
001CA4  060000     RETURN
54:                
55:                static void _ui_handleEncoderChange(int8_t change) {
001CA6  FA0004     LNK #0x4
001CA8  BE9F88     MOV.D W8, [W15++]
001CAA  BE9F8A     MOV.D W10, [W15++]
001CAC  E8808E     INC2 W14, W1
001CAE  784880     MOV.B W0, [W1]
56:                    bool largeStep = (util_currentTimeMicroseconds - _ui_lastEncChangeAt) < (UI_ENCODER_FAST_THRESH * (change < 0 ? -change : change));
001CB0  208C20     MOV #0x8C2, W0
001CB2  BE0430     MOV.D [W0++], W8
001CB4  BE0520     MOV.D [W0--], W10
001CB6  2086E0     MOV #0x86E, W0
001CB8  BE0150     MOV.D [++W0], W2
001CBA  BE0040     MOV.D [--W0], W0
001CBC  540200     SUB W8, W0, W4
001CBE  5C8281     SUBB W9, W1, W5
001CC0  5D0302     SUBB W10, W2, W6
001CC2  5D8383     SUBB W11, W3, W7
001CC4  E8800E     INC2 W14, W0
001CC6  784010     MOV.B [W0], W0
001CC8  E00400     CP0.B W0
001CCA  3D0010     BRA GE, .L10
001CCC  E8800E     INC2 W14, W0
001CCE  784010     MOV.B [W0], W0
001CD0  FB0000     SE W0, W0
001CD2  EA0000     NEG W0, W0
001CD4  DE80CF     ASR W0, #15, W1
001CD6  286A02     MOV #0x86A0, W2
001CD8  B98902     MUL.SS W1, W2, W2
001CDA  780102     MOV W2, W2
001CDC  B90461     MUL.SU W0, #1, W8
001CDE  780188     MOV W8, W3
001CE0  410103     ADD W2, W3, W2
001CE2  286A03     MOV #0x86A0, W3
001CE4  B80003     MUL.UU W0, W3, W0
001CE6  410101     ADD W2, W1, W2
001CE8  780082     MOV W2, W1
001CEA  37000E     BRA .L11
001CEC  E8800E     INC2 W14, W0
001CEE  784010     MOV.B [W0], W0
001CF0  FB0000     SE W0, W0
001CF2  DE80CF     ASR W0, #15, W1
001CF4  286A02     MOV #0x86A0, W2
001CF6  B98902     MUL.SS W1, W2, W2
001CF8  780102     MOV W2, W2
001CFA  B90461     MUL.SU W0, #1, W8
001CFC  780188     MOV W8, W3
001CFE  410103     ADD W2, W3, W2
001D00  286A03     MOV #0x86A0, W3
001D02  B80003     MUL.UU W0, W3, W0
001D04  410101     ADD W2, W1, W2
001D06  780082     MOV W2, W1
001D08  DE894F     ASR W1, #15, W2
001D0A  780182     MOV W2, W3
001D0C  B3C018     MOV.B #0x1, W8
001D0E  E12000     CP.W W4, W0
001D10  E1A801     CPB.W W5, W1
001D12  E1B002     CPB.W W6, W2
001D14  E1B803     CPB.W W7, W3
001D16  390001     BRA NC, .L12
001D18  EB4400     CLR.B W8
001D1A  784F08     MOV.B W8, [W14]
57:                    _ui_lastEncChangeAt = util_currentTimeMicroseconds;
001D1C  208C20     MOV #0x8C2, W0
001D1E  BE0150     MOV.D [++W0], W2
001D20  BE0040     MOV.D [--W0], W0
001D22  2086E4     MOV #0x86E, W4
001D24  BE9A00     MOV.D W0, [W4++]
001D26  BE9202     MOV.D W2, [W4--]
58:                    
59:                    switch (ui_state) {
001D28  804400     MOV ui_state, W0
001D2A  500FE1     SUB W0, #0x1, [W15]
001D2C  320003     BRA Z, .L14
001D2E  500FE2     SUB W0, #0x2, [W15]
001D30  32001C     BRA Z, .L15
60:                        case UI_ADJ_VOLTAGE:
61:                            ui_setVoltage += (int32_t)change * (largeStep ? 10 : 2);
001D34  E8800E     INC2 W14, W0
001D36  784010     MOV.B [W0], W0
001D38  FB0100     SE W0, W2
001D3A  DE91CF     ASR W2, #15, W3
001D3C  78401E     MOV.B [W14], W0
001D3E  E00400     CP0.B W0
001D40  320003     BRA Z, .L16
001D42  2000A0     MOV #0xA, W0
001D44  200001     MOV #0x0, W1
001D46  370002     BRA .L17
001D48  200020     MOV #0x2, W0
001D4A  200001     MOV #0x0, W1
001D4C  B99A00     MUL.SS W3, W0, W4
001D4E  780204     MOV W4, W4
001D50  B98B02     MUL.SS W1, W2, W6
001D52  780286     MOV W6, W5
001D54  420205     ADD W4, W5, W4
001D56  B81000     MUL.UU W2, W0, W0
001D58  420201     ADD W4, W1, W4
001D5A  780084     MOV W4, W1
001D5C  8045D2     MOV 0x8BA, W2
001D5E  8045E3     MOV 0x8BC, W3
001D60  410000     ADD W2, W0, W0
001D62  498081     ADDC W3, W1, W1
001D64  8845D0     MOV W0, 0x8BA
001D66  8845E1     MOV W1, 0x8BC
62:                            break;
001D68  370014     BRA .L9
63:                        case UI_ADJ_CURRENT:
64:                            ui_setCurrent += (int32_t)change * 5;
001D6A  E8800E     INC2 W14, W0
001D6C  784010     MOV.B [W0], W0
001D6E  FB0000     SE W0, W0
001D70  DE80CF     ASR W0, #15, W1
001D72  B90965     MUL.SU W1, #5, W2
001D74  780102     MOV W2, W2
001D76  B90260     MUL.SU W0, #0, W4
001D78  780184     MOV W4, W3
001D7A  410103     ADD W2, W3, W2
001D7C  200053     MOV #0x5, W3
001D7E  B80003     MUL.UU W0, W3, W0
001D80  410101     ADD W2, W1, W2
001D82  780082     MOV W2, W1
001D84  8045F2     MOV 0x8BE, W2
001D86  804603     MOV 0x8C0, W3
001D88  410000     ADD W2, W0, W0
001D8A  498081     ADDC W3, W1, W1
001D8C  8845F0     MOV W0, 0x8BE
001D8E  884601     MOV W1, 0x8C0
65:                            break;
001D90  000000     NOP
66:                        default:
67:                            break;
001D32  37002F     BRA .L9
68:                    }
69:                }
001D92  BE054F     MOV.D [--W15], W10
001D94  BE044F     MOV.D [--W15], W8
001D96  FA8000     ULNK
001D98  060000     RETURN
70:                
71:                static void _ui_handleShortPress() {
001D9A  FA0000     LNK #0x0
72:                    if (ui_outputOn) {
001D9C  BFC85A     MOV.B ui_outputOn, WREG
001D9E  E00400     CP0.B W0
001DA0  320003     BRA Z, .L20
73:                        ui_state = UI_IDLE;
001DA2  EF2880     CLR ui_state
74:                        ui_outputOn = false;
001DA4  EF685A     CLR.B ui_outputOn
75:                        return;
001DA6  37000E     BRA .L19
76:                    }
77:                    
78:                    switch (ui_state) {
001DA8  804400     MOV ui_state, W0
001DAA  E00000     CP0 W0
001DAC  320003     BRA Z, .L23
001DAE  500FE1     SUB W0, #0x1, [W15]
001DB0  320004     BRA Z, .L24
001DB2  370006     BRA .L25
79:                        case UI_IDLE:
80:                            ui_state = UI_ADJ_VOLTAGE;
001DB4  200010     MOV #0x1, W0
001DB6  884400     MOV W0, ui_state
81:                            break;
001DB8  370005     BRA .L19
82:                        case UI_ADJ_VOLTAGE:
83:                            ui_state = UI_ADJ_CURRENT;
001DBA  200020     MOV #0x2, W0
001DBC  884400     MOV W0, ui_state
84:                            break;
001DBE  370002     BRA .L19
85:                        case UI_ADJ_CURRENT:
86:                        default:
87:                            ui_state = UI_IDLE;
001DC0  EF2880     CLR ui_state
88:                            break;
001DC2  000000     NOP
89:                    }
90:                }
001DC4  FA8000     ULNK
001DC6  060000     RETURN
91:                
92:                static void _ui_handleLongPress() {
001DC8  FA0000     LNK #0x0
93:                    if (ui_state != UI_IDLE) {
001DCA  804400     MOV ui_state, W0
001DCC  E00000     CP0 W0
001DCE  320002     BRA Z, .L27
94:                        _ui_handleShortPress();
001DD0  07FFE4     RCALL _ui_handleShortPress
95:                        return;
001DD2  370005     BRA .L26
96:                    }
97:                    
98:                    ui_outputOn = !ui_outputOn;
001DD4  BFC85A     MOV.B ui_outputOn, WREG
001DD6  A20400     BTG.B W0, #0
001DD8  FB8000     ZE W0, W0
001DDA  784000     MOV.B W0, W0
001DDC  B7E85A     MOV.B WREG, ui_outputOn
99:                }
001DDE  FA8000     ULNK
001DE0  060000     RETURN
100:               
101:               
102:               void UI_Initialize() {
001DE2  FA0000     LNK #0x0
103:                   ui_setVoltage = 500;
001DE4  201F40     MOV #0x1F4, W0
001DE6  200001     MOV #0x0, W1
001DE8  8845D0     MOV W0, 0x8BA
001DEA  8845E1     MOV W1, 0x8BC
104:                   ui_setCurrent = 50;
001DEC  200320     MOV #0x32, W0
001DEE  200001     MOV #0x0, W1
001DF0  8845F0     MOV W0, 0x8BE
001DF2  884601     MOV W1, 0x8C0
105:                   ui_outVoltage = 0;
001DF4  EF2850     CLR ui_outVoltage
001DF6  EF2852     CLR 0x852
106:                   ui_outCurrent = 0;
001DF8  EF2854     CLR ui_outCurrent
001DFA  EF2856     CLR 0x856
107:                   ui_pps = false;
001DFC  EF6858     CLR.B ui_pps
108:                   ui_cc = false;
001DFE  EF6859     CLR.B ui_cc
109:                   ui_outputOn = false;
001E00  EF685A     CLR.B ui_outputOn
110:                   
111:                   _ui_encoderInput = 0;
001E02  EF685B     CLR.B _ui_encoderInput
112:                   _ui_encoderDebounceStart = 0;
001E04  2085C4     MOV #0x85C, W4
001E06  B80060     MUL.UU W0, #0, W0
001E08  B81160     MUL.UU W2, #0, W2
001E0A  BE9A00     MOV.D W0, [W4++]
001E0C  BE9202     MOV.D W2, [W4--]
113:                   _ui_buttonPressed = false;
001E0E  EF6864     CLR.B _ui_buttonPressed
114:                   _ui_buttonDebouncing = false;
001E10  EF6865     CLR.B _ui_buttonDebouncing
115:                   _ui_buttonDebounceStart = 0;
001E12  208664     MOV #0x866, W4
001E14  B80060     MUL.UU W0, #0, W0
001E16  B81160     MUL.UU W2, #0, W2
001E18  BE9A00     MOV.D W0, [W4++]
001E1A  BE9202     MOV.D W2, [W4--]
116:                   
117:                   _ui_lastEncChangeAt = 0;
001E1C  2086E4     MOV #0x86E, W4
001E1E  B80060     MUL.UU W0, #0, W0
001E20  B81160     MUL.UU W2, #0, W2
001E22  BE9A00     MOV.D W0, [W4++]
001E24  BE9202     MOV.D W2, [W4--]
118:                   _ui_buttonPressedAt = 0;
001E26  208764     MOV #0x876, W4
001E28  B80060     MUL.UU W0, #0, W0
001E2A  B81160     MUL.UU W2, #0, W2
001E2C  BE9A00     MOV.D W0, [W4++]
001E2E  BE9202     MOV.D W2, [W4--]
119:                   _ui_longPressDone = false;
001E30  EF687E     CLR.B _ui_longPressDone
120:                   
121:                   ui_state = UI_IDLE;
001E32  EF2880     CLR ui_state
122:                   
123:                   ENC_A_SetInterruptHandler(&_ui_encoderCallback);
001E34  21C0A0     MOV #0x1C0A, W0
001E36  07047E     RCALL ENC_A_SetInterruptHandler
124:                   ENC_SW_SetInterruptHandler(&_ui_buttonCallback);
001E38  21C8C0     MOV #0x1C8C, W0
001E3A  070460     RCALL ENC_SW_SetInterruptHandler
125:               }
001E3C  FA8000     ULNK
001E3E  060000     RETURN
126:               
127:               void UI_Tasks() {
001E40  FA0000     LNK #0x0
001E42  BE9F88     MOV.D W8, [W15++]
001E44  BE9F8A     MOV.D W10, [W15++]
128:                   if (_ui_buttonDebouncing) {
001E46  BFC865     MOV.B _ui_buttonDebouncing, WREG
001E48  E00400     CP0.B W0
001E4A  32002B     BRA Z, .L31
129:                       if (util_currentTimeMicroseconds - _ui_buttonDebounceStart >= UI_BUTTON_DEBOUNCE_TIME) {
001E4C  208C20     MOV #0x8C2, W0
001E4E  BE0430     MOV.D [W0++], W8
001E50  BE0520     MOV.D [W0--], W10
001E52  208660     MOV #0x866, W0
001E54  BE0150     MOV.D [++W0], W2
001E56  BE0040     MOV.D [--W0], W0
001E58  540200     SUB W8, W0, W4
001E5A  5C8281     SUBB W9, W1, W5
001E5C  5D0302     SUBB W10, W2, W6
001E5E  5D8383     SUBB W11, W3, W7
001E60  2270F0     MOV #0x270F, W0
001E62  200001     MOV #0x0, W1
001E64  B81160     MUL.UU W2, #0, W2
001E66  E12000     CP.W W4, W0
001E68  E1A801     CPB.W W5, W1
001E6A  E1B002     CPB.W W6, W2
001E6C  E1B803     CPB.W W7, W3
001E6E  360019     BRA LEU, .L31
130:                           _ui_buttonPressed = !ENC_SW_GetValue();
001E70  803320     MOV PORTA, W0
001E72  600061     AND W0, #0x1, W0
001E74  A7F000     BTSC W0, #15
001E76  EA0000     NEG W0, W0
001E78  E90000     DEC W0, W0
001E7A  DE004F     LSR W0, #15, W0
001E7C  784000     MOV.B W0, W0
001E7E  B7E864     MOV.B WREG, _ui_buttonPressed
131:                           _ui_buttonDebouncing = false;
001E80  EF6865     CLR.B _ui_buttonDebouncing
132:                           
133:                           if (_ui_buttonPressed) {
001E82  BFC864     MOV.B _ui_buttonPressed, WREG
001E84  E00400     CP0.B W0
001E86  320007     BRA Z, .L32
134:                               _ui_buttonPressedAt = util_currentTimeMicroseconds;
001E88  208C20     MOV #0x8C2, W0
001E8A  BE0150     MOV.D [++W0], W2
001E8C  BE0040     MOV.D [--W0], W0
001E8E  208764     MOV #0x876, W4
001E90  BE9A00     MOV.D W0, [W4++]
001E92  BE9202     MOV.D W2, [W4--]
001E94  370006     BRA .L31
135:                           } else {
136:                               if (!_ui_longPressDone) {
001E96  BFC87E     MOV.B _ui_longPressDone, WREG
001E98  A20400     BTG.B W0, #0
001E9A  E00400     CP0.B W0
001E9C  320001     BRA Z, .L33
137:                                   _ui_handleShortPress();
001E9E  07FF7D     RCALL _ui_handleShortPress
138:                               }
139:                               _ui_longPressDone = false;
001EA0  EF687E     CLR.B _ui_longPressDone
140:                           }
141:                       }
142:                   }
143:                   
144:                   if (_ui_buttonPressed && !_ui_longPressDone) {
001EA2  BFC864     MOV.B _ui_buttonPressed, WREG
001EA4  E00400     CP0.B W0
001EA6  320019     BRA Z, .L34
001EA8  BFC87E     MOV.B _ui_longPressDone, WREG
001EAA  A20400     BTG.B W0, #0
001EAC  E00400     CP0.B W0
001EAE  320015     BRA Z, .L34
145:                       if (util_currentTimeMicroseconds - _ui_buttonDebounceStart >= UI_BUTTON_LONGPRESS_THRESH) {
001EB0  208C20     MOV #0x8C2, W0
001EB2  BE0430     MOV.D [W0++], W8
001EB4  BE0520     MOV.D [W0--], W10
001EB6  208660     MOV #0x866, W0
001EB8  BE0150     MOV.D [++W0], W2
001EBA  BE0040     MOV.D [--W0], W0
001EBC  540200     SUB W8, W0, W4
001EBE  5C8281     SUBB W9, W1, W5
001EC0  5D0302     SUBB W10, W2, W6
001EC2  5D8383     SUBB W11, W3, W7
001EC4  2423F0     MOV #0x423F, W0
001EC6  2000F1     MOV #0xF, W1
001EC8  B81160     MUL.UU W2, #0, W2
001ECA  E12000     CP.W W4, W0
001ECC  E1A801     CPB.W W5, W1
001ECE  E1B002     CPB.W W6, W2
001ED0  E1B803     CPB.W W7, W3
001ED2  360003     BRA LEU, .L34
146:                           _ui_longPressDone = true;
001ED4  B3C010     MOV.B #0x1, W0
001ED6  B7E87E     MOV.B WREG, _ui_longPressDone
147:                           _ui_handleLongPress();
001ED8  07FF77     RCALL _ui_handleLongPress
148:                       }
149:                   }
150:                   
151:                   if (_ui_encoderInput != 0 && !_ui_buttonPressed && !_ui_buttonDebouncing) {
001EDA  BFC85B     MOV.B _ui_encoderInput, WREG
001EDC  E00400     CP0.B W0
001EDE  32000A     BRA Z, .L35
001EE0  BFC864     MOV.B _ui_buttonPressed, WREG
001EE2  A20400     BTG.B W0, #0
001EE4  E00400     CP0.B W0
001EE6  320006     BRA Z, .L35
001EE8  BFC865     MOV.B _ui_buttonDebouncing, WREG
001EEA  A20400     BTG.B W0, #0
001EEC  E00400     CP0.B W0
001EEE  320002     BRA Z, .L35
152:                       _ui_handleEncoderChange(_ui_encoderInput);
001EF0  BFC85B     MOV.B _ui_encoderInput, WREG
001EF2  07FED9     RCALL _ui_handleEncoderChange
153:                   }
154:                   
155:                   _ui_encoderInput = 0;
001EF4  EF685B     CLR.B _ui_encoderInput
156:               }
001EF6  BE054F     MOV.D [--W15], W10
001EF8  BE044F     MOV.D [--W15], W8
001EFA  FA8000     ULNK
001EFC  060000     RETURN
---  E:/Users/Alex/Documents/eagle/projects/USBPD Supply/adapter/USBPD-Adapter.X/sh1106_driver.c  -------
1:                 #include "sh1106_driver.h"
2:                 #include "mcc_generated_files/delay.h"
3:                 #include "i2c_blocking.h"
4:                 #include "util.h"
5:                 #include <string.h>
6:                 
7:                 #define SH_I2C_ADDR 0x3C
8:                 #define SH_I2C_INST I2CB_I2C2
9:                 
10:                
11:                uint8_t sh_framebuf[SH_FRAMEBUF_SIZE] = { 0 };
12:                
13:                
14:                static void _sh_wait_busy() {
00237E  FA0002     LNK #0x2
15:                    uint16_t status = I2CB_CmdRead8(SH_I2C_INST, SH_I2C_ADDR, 0x00);
002380  EB4300     CLR.B W6
002382  2003C5     MOV #0x3C, W5
002384  848B10     MOV 0x9162, W0
002386  848B21     MOV 0x9164, W1
002388  848B32     MOV 0x9166, W2
00238A  848B43     MOV 0x9168, W3
00238C  848B54     MOV 0x916A, W4
00238E  07FBAF     RCALL I2CB_CmdRead8
002390  780F00     MOV W0, [W14]
16:                    while (status & 0x80) {
002392  37000B     BRA .L2
0023AA  200800     MOV #0x80, W0
0023AC  60001E     AND W0, [W14], W0
0023AE  E00000     CP0 W0
0023B0  3AFFF1     BRA NZ, .L3
17:                        DELAY_milliseconds(1);
002394  200010     MOV #0x1, W0
002396  070279     RCALL DELAY_milliseconds
18:                        status = I2CB_CmdRead8(SH_I2C_INST, SH_I2C_ADDR, 0x00);
002398  EB4300     CLR.B W6
00239A  2003C5     MOV #0x3C, W5
00239C  848B10     MOV 0x9162, W0
00239E  848B21     MOV 0x9164, W1
0023A0  848B32     MOV 0x9166, W2
0023A2  848B43     MOV 0x9168, W3
0023A4  848B54     MOV 0x916A, W4
0023A6  07FBA3     RCALL I2CB_CmdRead8
0023A8  780F00     MOV W0, [W14]
19:                    }
20:                }
0023B2  FA8000     ULNK
0023B4  060000     RETURN
21:                
22:                bool SH_SendCommand(uint8_t command) {
0023B6  FA0002     LNK #0x2
0023B8  784F00     MOV.B W0, [W14]
23:                    _sh_wait_busy();
0023BA  07FFE1     RCALL _sh_wait_busy
24:                    return I2CB_Write16(SH_I2C_INST, SH_I2C_ADDR, ((uint16_t)command) << 8);
0023BC  FB801E     ZE [W14], W0
0023BE  DD0048     SL W0, #8, W0
0023C0  780300     MOV W0, W6
0023C2  2003C5     MOV #0x3C, W5
0023C4  848B10     MOV 0x9162, W0
0023C6  848B21     MOV 0x9164, W1
0023C8  848B32     MOV 0x9166, W2
0023CA  848B43     MOV 0x9168, W3
0023CC  848B54     MOV 0x916A, W4
0023CE  07FA1B     RCALL I2CB_Write16
25:                }
0023D0  FA8000     ULNK
0023D2  060000     RETURN
26:                
27:                bool SH_SendDoubleCommand(uint8_t command1, uint8_t command2) {
0023D4  FA0002     LNK #0x2
0023D6  784F00     MOV.B W0, [W14]
0023D8  E8000E     INC W14, W0
0023DA  784801     MOV.B W1, [W0]
28:                    _sh_wait_busy();
0023DC  07FFD0     RCALL _sh_wait_busy
29:                    return I2CB_Write32(SH_I2C_INST, SH_I2C_ADDR, (((uint32_t)command2) << 24) | (((uint32_t)command1) << 8) | 0x80);
0023DE  E8000E     INC W14, W0
0023E0  784010     MOV.B [W0], W0
0023E2  FB8000     ZE W0, W0
0023E4  EB0080     CLR W1
0023E6  DD01C8     SL W0, #8, W3
0023E8  200002     MOV #0x0, W2
0023EA  FB821E     ZE [W14], W4
0023EC  EB0280     CLR W5
0023EE  DD2848     SL W5, #8, W0
0023F0  DE20C8     LSR W4, #8, W1
0023F2  700081     IOR W0, W1, W1
0023F4  DD2048     SL W4, #8, W0
0023F6  710000     IOR W2, W0, W0
0023F8  718081     IOR W3, W1, W1
0023FA  A07000     BSET W0, #7
0023FC  BE0300     MOV.D W0, W6
0023FE  2003C5     MOV #0x3C, W5
002400  848B10     MOV 0x9162, W0
002402  848B21     MOV 0x9164, W1
002404  848B32     MOV 0x9166, W2
002406  848B43     MOV 0x9168, W3
002408  848B54     MOV 0x916A, W4
00240A  07FA1C     RCALL I2CB_Write32
30:                }
00240C  FA8000     ULNK
00240E  060000     RETURN
31:                
32:                bool SH_WriteFramebuffer() {
002410  FA0088     LNK #0x88
33:                    uint8_t buf[133] = { 0x40, 0 };
002412  4700E2     ADD W14, #0x2, W1
002414  090041     REPEAT #0x41
002416  EB1880     CLR [W1++]
002418  EB5880     CLR.B [W1++]
00241A  B3C401     MOV.B #0x40, W1
00241C  E8800E     INC2 W14, W0
00241E  784801     MOV.B W1, [W0]
34:                    
35:                    //reset column address to zero
36:                    asserttrue(SH_SendCommand(0x00));
002420  EB4000     CLR.B W0
002422  07FFC9     RCALL SH_SendCommand
002424  A20400     BTG.B W0, #0
002426  E00400     CP0.B W0
002428  320002     BRA Z, .L7
00242A  EB4000     CLR.B W0
00242C  370031     BRA .L8
37:                    asserttrue(SH_SendCommand(0x10));
00242E  B3C100     MOV.B #0x10, W0
002430  07FFC2     RCALL SH_SendCommand
002432  A20400     BTG.B W0, #0
002434  E00400     CP0.B W0
002436  320002     BRA Z, .L9
002438  EB4000     CLR.B W0
00243A  37002A     BRA .L8
38:                    
39:                    uint16_t page;
40:                    for (page = 0; page < 8; page++) {
00243C  EB0000     CLR W0
00243E  780F00     MOV W0, [W14]
002440  370023     BRA .L10
002486  E80F1E     INC [W14], [W14]
002488  78001E     MOV [W14], W0
00248A  500FE7     SUB W0, #0x7, [W15]
00248C  36FFDA     BRA LEU, .L13
41:                        asserttrue(SH_SendCommand(0xB0 | page));
002442  78001E     MOV [W14], W0
002444  784080     MOV.B W0, W1
002446  B3CB00     MOV.B #0xB0, W0
002448  70C000     IOR.B W1, W0, W0
00244A  07FFB5     RCALL SH_SendCommand
00244C  A20400     BTG.B W0, #0
00244E  E00400     CP0.B W0
002450  320002     BRA Z, .L11
002452  EB4000     CLR.B W0
002454  37001D     BRA .L8
42:                        memcpy(buf + 3, sh_framebuf + (page * 128), 128);
002456  78001E     MOV [W14], W0
002458  DD00C7     SL W0, #7, W1
00245A  208D40     MOV #0x8D4, W0
00245C  408080     ADD W1, W0, W1
00245E  E8800E     INC2 W14, W0
002460  400063     ADD W0, #0x3, W0
002462  200802     MOV #0x80, W2
002464  07F252     RCALL _memcpy
43:                        _sh_wait_busy();
002466  07FF8B     RCALL _sh_wait_busy
44:                        asserttrue(I2CB_Write(SH_I2C_INST, SH_I2C_ADDR, buf, 133));
002468  E8800E     INC2 W14, W0
00246A  B3C857     MOV.B #0x85, W7
00246C  780300     MOV W0, W6
00246E  2003C5     MOV #0x3C, W5
002470  848B10     MOV 0x9162, W0
002472  848B21     MOV 0x9164, W1
002474  848B32     MOV 0x9166, W2
002476  848B43     MOV 0x9168, W3
002478  848B54     MOV 0x916A, W4
00247A  07F952     RCALL I2CB_Write
00247C  A20400     BTG.B W0, #0
00247E  E00400     CP0.B W0
002480  320002     BRA Z, .L12
002482  EB4000     CLR.B W0
002484  370005     BRA .L8
45:                    }
46:                    
47:                    return true;
00248E  B3C010     MOV.B #0x1, W0
48:                }
002490  FA8000     ULNK
002492  060000     RETURN
49:                
50:                bool SH_Initialize() {
002494  FA0000     LNK #0x0
51:                    asserttrue(SH_SendCommand(0xAE)); //display power off
002496  B3CAE0     MOV.B #0xAE, W0
002498  07FF8E     RCALL SH_SendCommand
00249A  A20400     BTG.B W0, #0
00249C  E00400     CP0.B W0
00249E  320002     BRA Z, .L15
0024A0  EB4000     CLR.B W0
0024A2  37007C     BRA .L16
52:                    asserttrue(SH_SendCommand(0x32)); //pump voltage 8.0V
0024A4  B3C320     MOV.B #0x32, W0
0024A6  07FF87     RCALL SH_SendCommand
0024A8  A20400     BTG.B W0, #0
0024AA  E00400     CP0.B W0
0024AC  320002     BRA Z, .L17
0024AE  EB4000     CLR.B W0
0024B0  370075     BRA .L16
53:                    asserttrue(SH_SendCommand(0x40)); //start line 0
0024B2  B3C400     MOV.B #0x40, W0
0024B4  07FF80     RCALL SH_SendCommand
0024B6  A20400     BTG.B W0, #0
0024B8  E00400     CP0.B W0
0024BA  320002     BRA Z, .L18
0024BC  EB4000     CLR.B W0
0024BE  37006E     BRA .L16
54:                    asserttrue(SH_SendDoubleCommand(0x81, 0x80)); //contrast 128
0024C0  B3C801     MOV.B #0x80, W1
0024C2  B3C810     MOV.B #0x81, W0
0024C4  07FF87     RCALL SH_SendDoubleCommand
0024C6  A20400     BTG.B W0, #0
0024C8  E00400     CP0.B W0
0024CA  320002     BRA Z, .L19
0024CC  EB4000     CLR.B W0
0024CE  370066     BRA .L16
55:                    asserttrue(SH_SendCommand(0xA1)); //segment remap ADC = H (flip horizontally)
0024D0  B3CA10     MOV.B #0xA1, W0
0024D2  07FF71     RCALL SH_SendCommand
0024D4  A20400     BTG.B W0, #0
0024D6  E00400     CP0.B W0
0024D8  320002     BRA Z, .L20
0024DA  EB4000     CLR.B W0
0024DC  37005F     BRA .L16
56:                    asserttrue(SH_SendCommand(0xA4)); //entire display on: disable (normal display)
0024DE  B3CA40     MOV.B #0xA4, W0
0024E0  07FF6A     RCALL SH_SendCommand
0024E2  A20400     BTG.B W0, #0
0024E4  E00400     CP0.B W0
0024E6  320002     BRA Z, .L21
0024E8  EB4000     CLR.B W0
0024EA  370058     BRA .L16
57:                    asserttrue(SH_SendCommand(0xA6)); //inverted display: disable (normal display)
0024EC  B3CA60     MOV.B #0xA6, W0
0024EE  07FF63     RCALL SH_SendCommand
0024F0  A20400     BTG.B W0, #0
0024F2  E00400     CP0.B W0
0024F4  320002     BRA Z, .L22
0024F6  EB4000     CLR.B W0
0024F8  370051     BRA .L16
58:                    asserttrue(SH_SendDoubleCommand(0xA8, 0x3F)); //multiplex ratio 64
0024FA  B3C3F1     MOV.B #0x3F, W1
0024FC  B3CA80     MOV.B #0xA8, W0
0024FE  07FF6A     RCALL SH_SendDoubleCommand
002500  A20400     BTG.B W0, #0
002502  E00400     CP0.B W0
002504  320002     BRA Z, .L23
002506  EB4000     CLR.B W0
002508  370049     BRA .L16
59:                    asserttrue(SH_SendDoubleCommand(0xAD, 0x8B)); //DC-DC enabled (built-in)
00250A  B3C8B1     MOV.B #0x8B, W1
00250C  B3CAD0     MOV.B #0xAD, W0
00250E  07FF62     RCALL SH_SendDoubleCommand
002510  A20400     BTG.B W0, #0
002512  E00400     CP0.B W0
002514  320002     BRA Z, .L24
002516  EB4000     CLR.B W0
002518  370041     BRA .L16
60:                    asserttrue(SH_SendCommand(0xC8)); //common output scan direction: reversed (flip vertically)
00251A  B3CC80     MOV.B #0xC8, W0
00251C  07FF4C     RCALL SH_SendCommand
00251E  A20400     BTG.B W0, #0
002520  E00400     CP0.B W0
002522  320002     BRA Z, .L25
002524  EB4000     CLR.B W0
002526  37003A     BRA .L16
61:                    asserttrue(SH_SendDoubleCommand(0xD3, 0x00)); //display offset 0
002528  EB4080     CLR.B W1
00252A  B3CD30     MOV.B #0xD3, W0
00252C  07FF53     RCALL SH_SendDoubleCommand
00252E  A20400     BTG.B W0, #0
002530  E00400     CP0.B W0
002532  320002     BRA Z, .L26
002534  EB4000     CLR.B W0
002536  370032     BRA .L16
62:                    asserttrue(SH_SendDoubleCommand(0xD5, 0x50)); //display clock frequency +-0%, divide ratio 1
002538  B3C501     MOV.B #0x50, W1
00253A  B3CD50     MOV.B #0xD5, W0
00253C  07FF4B     RCALL SH_SendDoubleCommand
00253E  A20400     BTG.B W0, #0
002540  E00400     CP0.B W0
002542  320002     BRA Z, .L27
002544  EB4000     CLR.B W0
002546  37002A     BRA .L16
63:                    asserttrue(SH_SendDoubleCommand(0xD9, 0x22)); //discharge 2DCLK, precharge 2DCLK
002548  B3C221     MOV.B #0x22, W1
00254A  B3CD90     MOV.B #0xD9, W0
00254C  07FF43     RCALL SH_SendDoubleCommand
00254E  A20400     BTG.B W0, #0
002550  E00400     CP0.B W0
002552  320002     BRA Z, .L28
002554  EB4000     CLR.B W0
002556  370022     BRA .L16
64:                    asserttrue(SH_SendDoubleCommand(0xDA, 0x12)); //common pads: alternative config
002558  B3C121     MOV.B #0x12, W1
00255A  B3CDA0     MOV.B #0xDA, W0
00255C  07FF3B     RCALL SH_SendDoubleCommand
00255E  A20400     BTG.B W0, #0
002560  E00400     CP0.B W0
002562  320002     BRA Z, .L29
002564  EB4000     CLR.B W0
002566  37001A     BRA .L16
65:                    asserttrue(SH_SendDoubleCommand(0xDB, 0x35)); //VCOM deselect level 0.770
002568  B3C351     MOV.B #0x35, W1
00256A  B3CDB0     MOV.B #0xDB, W0
00256C  07FF33     RCALL SH_SendDoubleCommand
00256E  A20400     BTG.B W0, #0
002570  E00400     CP0.B W0
002572  320002     BRA Z, .L30
002574  EB4000     CLR.B W0
002576  370012     BRA .L16
66:                    
67:                    memset(sh_framebuf, 0, SH_FRAMEBUF_SIZE);
002578  204002     MOV #0x400, W2
00257A  EB0080     CLR W1
00257C  208D40     MOV #0x8D4, W0
00257E  07F1CC     RCALL _memset
68:                    asserttrue(SH_WriteFramebuffer());
002580  07FF47     RCALL SH_WriteFramebuffer
002582  A20400     BTG.B W0, #0
002584  E00400     CP0.B W0
002586  320002     BRA Z, .L31
002588  EB4000     CLR.B W0
00258A  370008     BRA .L16
69:                    asserttrue(SH_SendCommand(0xAF)); //display power on
00258C  B3CAF0     MOV.B #0xAF, W0
00258E  07FF13     RCALL SH_SendCommand
002590  A20400     BTG.B W0, #0
002592  E00400     CP0.B W0
002594  320002     BRA Z, .L32
002596  EB4000     CLR.B W0
002598  370001     BRA .L16
70:                    
71:                    return true;
00259A  B3C010     MOV.B #0x1, W0
72:                }
00259C  FA8000     ULNK
00259E  060000     RETURN
---  E:/Users/Alex/Documents/eagle/projects/USBPD Supply/adapter/USBPD-Adapter.X/oled.c  ----------------
1:                 #include "oled.h"
2:                 #include "sh1106_driver.h"
3:                 #include "util.h"
4:                 #include "ui.h"
5:                 #include <string.h>
6:                 
7:                 //digits size 12pt - 0123456789- - pages 0-2
8:                 #define OLED_DIG12_CHARWIDTH 9
9:                 #define OLED_DIG12_TOTALWIDTH (OLED_DIG12_CHARWIDTH * 11)
10:                static const uint8_t _oled_digits_12[] = {
11:                    0x00, 0xe0, 0x10, 0x10, 0x10, 0x10, 0x10, 0xe0, 0x00, 0x00, 0x40,
12:                    0x20, 0x20, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x10, 0x10,
13:                    0x10, 0x10, 0x10, 0xe0, 0x00, 0x00, 0x60, 0x10, 0x10, 0x10, 0x10,
14:                    0x10, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x30, 0x00, 0x00,
15:                    0x00, 0x00, 0xf0, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00,
16:                    0x00, 0x00, 0xc0, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10,
17:                    0x10, 0x10, 0x10, 0xd0, 0x30, 0x00, 0x00, 0xe0, 0x10, 0x10, 0x10,
18:                    0x10, 0x10, 0xe0, 0x00, 0x00, 0xe0, 0x10, 0x10, 0x10, 0x10, 0x10,
19:                    0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
20:                
21:                    0x00, 0xff, 0x10, 0x08, 0x08, 0x04, 0x02, 0xff, 0x00, 0x00, 0x00,
22:                    0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x60, 0x10,
23:                    0x08, 0x08, 0x04, 0x03, 0x00, 0x00, 0x80, 0x00, 0x00, 0x04, 0x04,
24:                    0x0a, 0xf1, 0x00, 0x00, 0x30, 0x2c, 0x23, 0x20, 0x20, 0xfe, 0x20,
25:                    0x00, 0x00, 0xc7, 0x02, 0x01, 0x01, 0x01, 0x02, 0xfc, 0x00, 0x00,
26:                    0xf8, 0x07, 0x04, 0x04, 0x04, 0x08, 0xf0, 0x00, 0x00, 0x00, 0x00,
27:                    0x80, 0x70, 0x0e, 0x01, 0x00, 0x00, 0x00, 0xe0, 0x13, 0x0c, 0x04,
28:                    0x0c, 0x13, 0xe0, 0x00, 0x00, 0x03, 0x04, 0x08, 0x08, 0xc8, 0x38,
29:                    0x07, 0x00, 0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00,
30:                
31:                    0x00, 0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x01, 0x00, 0x00, 0x00,
32:                    0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x02, 0x02,
33:                    0x02, 0x02, 0x02, 0x02, 0x00, 0x00, 0x01, 0x02, 0x02, 0x02, 0x02,
34:                    0x02, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00,
35:                    0x00, 0x00, 0x01, 0x02, 0x02, 0x02, 0x02, 0x01, 0x00, 0x00, 0x00,
36:                    0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00,
37:                    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x02, 0x02,
38:                    0x02, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
39:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
40:                };
41:                
42:                //digits size 13pt - 0123456789- - pages 5-7
43:                #define OLED_DIG13_CHARWIDTH 10
44:                #define OLED_DIG13_TOTALWIDTH (OLED_DIG13_CHARWIDTH * 11)
45:                static const uint8_t _oled_digits_13[] = {
46:                    0x00, 0x80, 0x40, 0x20, 0x20, 0x20, 0x20, 0x40, 0x80, 0x00, 0x00,
47:                    0x00, 0x80, 0x40, 0x20, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
48:                    0x40, 0x20, 0x20, 0x20, 0x20, 0x40, 0x80, 0x00, 0x00, 0x80, 0x40,
49:                    0x20, 0x20, 0x20, 0x20, 0x40, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
50:                    0x00, 0xc0, 0x20, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x20, 0x20, 0x20,
51:                    0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x20,
52:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
53:                    0xe0, 0x20, 0x00, 0x00, 0x80, 0x40, 0x20, 0x20, 0x20, 0x20, 0x40,
54:                    0x80, 0x00, 0x00, 0x80, 0x40, 0x20, 0x20, 0x20, 0x20, 0x40, 0x80,
55:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
56:                
57:                    0x00, 0xff, 0x40, 0x20, 0x10, 0x10, 0x08, 0x04, 0xff, 0x00, 0x00,
58:                    0x01, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
59:                    0x80, 0x40, 0x20, 0x20, 0x10, 0x08, 0x07, 0x00, 0x00, 0x00, 0x00,
60:                    0x00, 0x08, 0x08, 0x08, 0x14, 0xe3, 0x00, 0x00, 0xc0, 0xb0, 0x8c,
61:                    0x83, 0x80, 0xfc, 0x80, 0x80, 0x00, 0x00, 0x1f, 0x08, 0x04, 0x04,
62:                    0x04, 0x04, 0x08, 0xf0, 0x00, 0x00, 0xe0, 0x1c, 0x0b, 0x08, 0x08,
63:                    0x08, 0x10, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x0e,
64:                    0x01, 0x00, 0x00, 0x00, 0x81, 0x46, 0x28, 0x10, 0x10, 0x28, 0x46,
65:                    0x81, 0x00, 0x00, 0x0f, 0x10, 0x20, 0x20, 0x20, 0xa0, 0x70, 0x0f,
66:                    0x00, 0x00, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00,
67:                
68:                    0x00, 0x03, 0x04, 0x08, 0x08, 0x08, 0x08, 0x04, 0x03, 0x00, 0x00,
69:                    0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e,
70:                    0x09, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00, 0x03, 0x04,
71:                    0x08, 0x08, 0x08, 0x08, 0x04, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,
72:                    0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x03, 0x04, 0x08, 0x08,
73:                    0x08, 0x08, 0x04, 0x03, 0x00, 0x00, 0x03, 0x04, 0x08, 0x08, 0x08,
74:                    0x08, 0x04, 0x03, 0x00, 0x00, 0x00, 0x00, 0x08, 0x07, 0x00, 0x00,
75:                    0x00, 0x00, 0x00, 0x00, 0x07, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
76:                    0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x06, 0x01, 0x00, 0x00,
77:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
78:                };
79:                
80:                //labels - Fixed PPS CV CC ON - pages 3-4
81:                static const uint16_t _oled_labels_offsets[] = { 0, 39, 63, 79, 95 };
82:                static const uint16_t _oled_labels_columns[] = { 8, 15, 94, 94, 58 };
83:                static const uint16_t _oled_labels_widths[] = { 39, 24, 16, 16, 15 };
84:                #define OLED_LABELS_TOTALWIDTH 110
85:                static const uint8_t _oled_labels[] = {
86:                    0x00, 0xfc, 0x84, 0x84, 0x84, 0x00, 0x00, 0x00, 0x20, 0x20, 0xe4,
87:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0xc0, 0x00, 0x80, 0x60, 0x00,
88:                    0x00, 0x00, 0xc0, 0x20, 0x20, 0x20, 0x20, 0xc0, 0x00, 0x00, 0xc0,
89:                    0x20, 0x20, 0x20, 0xfc, 0x00, 0x00, 0x00, 0xfc, 0x84, 0x84, 0x84,
90:                    0x84, 0x78, 0x00, 0x00, 0xfc, 0x84, 0x84, 0x84, 0x84, 0x78, 0x00,
91:                    0x00, 0x38, 0x44, 0x84, 0x84, 0x04, 0x18, 0x00, 0x00, 0xf8, 0x04,
92:                    0x04, 0x04, 0x1c, 0x00, 0x00, 0x00, 0x3c, 0xc0, 0x00, 0x00, 0xf0,
93:                    0x0c, 0x00, 0x00, 0xf8, 0x04, 0x04, 0x04, 0x1c, 0x00, 0x00, 0x00,
94:                    0xf8, 0x04, 0x04, 0x04, 0x1c, 0x00, 0x00, 0x00, 0xf8, 0x04, 0x04,
95:                    0x04, 0x04, 0xf8, 0x00, 0x00, 0xfc, 0x30, 0xc0, 0x00, 0xfc, 0x00,
96:                
97:                    0x00, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x1f,
98:                    0x10, 0x10, 0x00, 0x00, 0x00, 0x10, 0x0c, 0x03, 0x04, 0x18, 0x00,
99:                    0x00, 0x00, 0x0f, 0x11, 0x11, 0x11, 0x11, 0x09, 0x00, 0x00, 0x0f,
100:                   0x10, 0x10, 0x10, 0x1f, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x00,
101:                   0x00, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
102:                   0x00, 0x0c, 0x10, 0x10, 0x10, 0x11, 0x0e, 0x00, 0x00, 0x0f, 0x10,
103:                   0x10, 0x10, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x03, 0x1c, 0x07, 0x00,
104:                   0x00, 0x00, 0x00, 0x0f, 0x10, 0x10, 0x10, 0x1c, 0x00, 0x00, 0x00,
105:                   0x0f, 0x10, 0x10, 0x10, 0x1c, 0x00, 0x00, 0x00, 0x0f, 0x10, 0x10,
106:                   0x10, 0x10, 0x0f, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x03, 0x1f, 0x00
107:               };
108:               
109:               //base background - all pages
110:               static const uint8_t _oled_background[] = {
111:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
112:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
113:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
114:                   0x00, 0x00, 0x70, 0x80, 0x00, 0x00, 0x00, 0x80, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
115:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
116:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
117:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
118:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x30, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
119:               
120:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
121:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
122:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
123:                   0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0xf0, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
124:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
125:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
126:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
127:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x7c, 0x23, 0x20, 0x23, 0x7c, 0x80, 0x00, 0x00, 0x00, 0x00,
128:               
129:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
130:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
131:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
132:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0xc0, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
133:                   0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0xc0, 0x40, 0x40, 0x40, 0x40,
134:                   0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x42, 0x40, 0x40, 0x40,
135:                   0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
136:                   0x40, 0x40, 0x40, 0x40, 0x40, 0x43, 0x40, 0x40, 0x40, 0x40, 0x40, 0x43, 0x40, 0x40, 0x00, 0x00,
137:               
138:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
139:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
140:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
141:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
142:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00,
143:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
144:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
145:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
146:               
147:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
148:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
149:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
150:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
151:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00,
152:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
153:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
154:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
155:               
156:                   0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
157:                   0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
158:                   0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
159:                   0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0xe1, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0xe1, 0x01,
160:                   0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00,
161:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
162:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
163:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
164:               
165:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
166:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
167:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
168:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0xf0, 0x0f, 0x00, 0x00,
169:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
170:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
171:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
172:                   0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x5e, 0x41, 0x41, 0x5e, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00,
173:               
174:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
175:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x08, 0x00, 0x00, 0x00,
176:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
177:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x07, 0x00, 0x00, 0x00, 0x00,
178:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
179:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
180:                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
181:                   0x00, 0x00, 0x00, 0x00, 0x0e, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0x0e, 0x00, 0x00, 0x00, 0x00
182:               };
183:               
184:               
185:               static void _oled_drawDigit12(uint8_t column, uint8_t index) {
00116C  FA000A     LNK #0xA
00116E  470168     ADD W14, #0x8, W2
001170  784900     MOV.B W0, [W2]
001172  470069     ADD W14, #0x9, W0
001174  784801     MOV.B W1, [W0]
186:                   if (column >= 128 - OLED_DIG12_CHARWIDTH || index > 10) return;
001176  470068     ADD W14, #0x8, W0
001178  784090     MOV.B [W0], W1
00117A  B3C760     MOV.B #0x76, W0
00117C  50CF80     SUB.B W1, W0, [W15]
00117E  3E0054     BRA GTU, .L11
001180  470069     ADD W14, #0x9, W0
001182  784010     MOV.B [W0], W0
001184  504FEA     SUB.B W0, #0xA, [W15]
001186  3E0052     BRA GTU, .L12
001228  000000     NOP
00122A  370001     BRA .L1
00122C  000000     NOP
187:                   
188:                   uint16_t writeOffset = column;
001188  470068     ADD W14, #0x8, W0
00118A  784010     MOV.B [W0], W0
00118C  FB8000     ZE W0, W0
00118E  780F00     MOV W0, [W14]
189:                   uint16_t readOffset = index * OLED_DIG12_CHARWIDTH;
001190  470069     ADD W14, #0x9, W0
001192  784010     MOV.B [W0], W0
001194  FB8000     ZE W0, W0
001196  B90069     MUL.SU W0, #9, W0
001198  780080     MOV W0, W1
00119A  E8800E     INC2 W14, W0
00119C  780801     MOV W1, [W0]
190:                   
191:                   uint16_t i, j;
192:                   for (i = 0; i < 3; i++) {
00119E  EB0080     CLR W1
0011A0  470064     ADD W14, #0x4, W0
0011A2  780801     MOV W1, [W0]
0011A4  37003C     BRA .L5
001214  470064     ADD W14, #0x4, W0
001216  780010     MOV [W0], W0
001218  E80080     INC W0, W1
00121A  470064     ADD W14, #0x4, W0
00121C  780801     MOV W1, [W0]
00121E  470064     ADD W14, #0x4, W0
001220  780010     MOV [W0], W0
001222  500FE2     SUB W0, #0x2, [W15]
001224  36FFC0     BRA LEU, .L10
001226  370003     BRA .L1
193:                       if (i < 2) {
0011A6  470064     ADD W14, #0x4, W0
0011A8  780010     MOV [W0], W0
0011AA  500FE1     SUB W0, #0x1, [W15]
0011AC  3E0009     BRA GTU, .L6
194:                           memcpy(sh_framebuf + writeOffset, _oled_digits_12 + readOffset, OLED_DIG12_CHARWIDTH);
0011AE  E8800E     INC2 W14, W0
0011B0  780090     MOV [W0], W1
0011B2  289EA0     MOV #0x89EA, W0
0011B4  408080     ADD W1, W0, W1
0011B6  208D40     MOV #0x8D4, W0
0011B8  40001E     ADD W0, [W14], W0
0011BA  200092     MOV #0x9, W2
0011BC  07FBA6     RCALL _memcpy
0011BE  370022     BRA .L7
195:                       } else {
196:                           for (j = 0; j < OLED_DIG12_CHARWIDTH; j++) {
0011C0  EB0080     CLR W1
0011C2  470066     ADD W14, #0x6, W0
0011C4  780801     MOV W1, [W0]
0011C6  37001A     BRA .L8
0011F2  470066     ADD W14, #0x6, W0
0011F4  780010     MOV [W0], W0
0011F6  E80080     INC W0, W1
0011F8  470066     ADD W14, #0x6, W0
0011FA  780801     MOV W1, [W0]
0011FC  470066     ADD W14, #0x6, W0
0011FE  780010     MOV [W0], W0
001200  500FE8     SUB W0, #0x8, [W15]
001202  36FFE2     BRA LEU, .L9
197:                               sh_framebuf[writeOffset + j] |= _oled_digits_12[readOffset + j];
0011C8  470066     ADD W14, #0x6, W0
0011CA  780010     MOV [W0], W0
0011CC  40001E     ADD W0, [W14], W0
0011CE  4700E6     ADD W14, #0x6, W1
0011D0  780091     MOV [W1], W1
0011D2  40809E     ADD W1, [W14], W1
0011D4  208D42     MOV #0x8D4, W2
0011D6  410081     ADD W2, W1, W1
0011D8  784111     MOV.B [W1], W2
0011DA  E8808E     INC2 W14, W1
0011DC  780191     MOV [W1], W3
0011DE  4700E6     ADD W14, #0x6, W1
0011E0  780091     MOV [W1], W1
0011E2  418081     ADD W3, W1, W1
0011E4  289EA3     MOV #0x89EA, W3
0011E6  418081     ADD W3, W1, W1
0011E8  784091     MOV.B [W1], W1
0011EA  714081     IOR.B W2, W1, W1
0011EC  208D42     MOV #0x8D4, W2
0011EE  410000     ADD W2, W0, W0
0011F0  784801     MOV.B W1, [W0]
198:                           }
199:                       }        
200:                       writeOffset += 128;
001204  200801     MOV #0x80, W1
001206  408F1E     ADD W1, [W14], [W14]
201:                       readOffset += OLED_DIG12_TOTALWIDTH;
001208  E8800E     INC2 W14, W0
00120A  780010     MOV [W0], W0
00120C  200631     MOV #0x63, W1
00120E  408080     ADD W1, W0, W1
001210  E8800E     INC2 W14, W0
001212  780801     MOV W1, [W0]
202:                   }
203:               }
00122E  FA8000     ULNK
001230  060000     RETURN
204:               
205:               static void _oled_drawDigit13(uint8_t column, uint8_t index) {
001232  FA000A     LNK #0xA
001234  470168     ADD W14, #0x8, W2
001236  784900     MOV.B W0, [W2]
001238  470069     ADD W14, #0x9, W0
00123A  784801     MOV.B W1, [W0]
206:                   if (column >= 128 - OLED_DIG13_CHARWIDTH || index > 10) return;
00123C  470068     ADD W14, #0x8, W0
00123E  784090     MOV.B [W0], W1
001240  B3C750     MOV.B #0x75, W0
001242  50CF80     SUB.B W1, W0, [W15]
001244  3E0055     BRA GTU, .L23
001246  470069     ADD W14, #0x9, W0
001248  784010     MOV.B [W0], W0
00124A  504FEA     SUB.B W0, #0xA, [W15]
00124C  3E0053     BRA GTU, .L24
0012F0  000000     NOP
0012F2  370001     BRA .L13
0012F4  000000     NOP
207:                   
208:                   uint16_t writeOffset = 5 * 128 + column;
00124E  470068     ADD W14, #0x8, W0
001250  784010     MOV.B [W0], W0
001252  FB8000     ZE W0, W0
001254  B02800     ADD #0x280, W0
001256  780F00     MOV W0, [W14]
209:                   uint16_t readOffset = index * OLED_DIG13_CHARWIDTH;
001258  470069     ADD W14, #0x9, W0
00125A  784010     MOV.B [W0], W0
00125C  FB8000     ZE W0, W0
00125E  B9006A     MUL.SU W0, #10, W0
001260  780080     MOV W0, W1
001262  E8800E     INC2 W14, W0
001264  780801     MOV W1, [W0]
210:                   
211:                   uint16_t i, j;
212:                   for (i = 0; i < 3; i++) {
001266  EB0080     CLR W1
001268  470064     ADD W14, #0x4, W0
00126A  780801     MOV W1, [W0]
00126C  37003C     BRA .L17
0012DC  470064     ADD W14, #0x4, W0
0012DE  780010     MOV [W0], W0
0012E0  E80080     INC W0, W1
0012E2  470064     ADD W14, #0x4, W0
0012E4  780801     MOV W1, [W0]
0012E6  470064     ADD W14, #0x4, W0
0012E8  780010     MOV [W0], W0
0012EA  500FE2     SUB W0, #0x2, [W15]
0012EC  36FFC0     BRA LEU, .L22
0012EE  370003     BRA .L13
213:                       if (i > 0) {
00126E  470064     ADD W14, #0x4, W0
001270  780010     MOV [W0], W0
001272  E00000     CP0 W0
001274  320009     BRA Z, .L18
214:                           memcpy(sh_framebuf + writeOffset, _oled_digits_13 + readOffset, OLED_DIG13_CHARWIDTH);
001276  E8800E     INC2 W14, W0
001278  780090     MOV [W0], W1
00127A  28B130     MOV #0x8B13, W0
00127C  408080     ADD W1, W0, W1
00127E  208D40     MOV #0x8D4, W0
001280  40001E     ADD W0, [W14], W0
001282  2000A2     MOV #0xA, W2
001284  07FB42     RCALL _memcpy
001286  370022     BRA .L19
215:                       } else {
216:                           for (j = 0; j < OLED_DIG13_CHARWIDTH; j++) {
001288  EB0080     CLR W1
00128A  470066     ADD W14, #0x6, W0
00128C  780801     MOV W1, [W0]
00128E  37001A     BRA .L20
0012BA  470066     ADD W14, #0x6, W0
0012BC  780010     MOV [W0], W0
0012BE  E80080     INC W0, W1
0012C0  470066     ADD W14, #0x6, W0
0012C2  780801     MOV W1, [W0]
0012C4  470066     ADD W14, #0x6, W0
0012C6  780010     MOV [W0], W0
0012C8  500FE9     SUB W0, #0x9, [W15]
0012CA  36FFE2     BRA LEU, .L21
217:                               sh_framebuf[writeOffset + j] |= _oled_digits_13[readOffset + j];
001290  470066     ADD W14, #0x6, W0
001292  780010     MOV [W0], W0
001294  40001E     ADD W0, [W14], W0
001296  4700E6     ADD W14, #0x6, W1
001298  780091     MOV [W1], W1
00129A  40809E     ADD W1, [W14], W1
00129C  208D42     MOV #0x8D4, W2
00129E  410081     ADD W2, W1, W1
0012A0  784111     MOV.B [W1], W2
0012A2  E8808E     INC2 W14, W1
0012A4  780191     MOV [W1], W3
0012A6  4700E6     ADD W14, #0x6, W1
0012A8  780091     MOV [W1], W1
0012AA  418081     ADD W3, W1, W1
0012AC  28B133     MOV #0x8B13, W3
0012AE  418081     ADD W3, W1, W1
0012B0  784091     MOV.B [W1], W1
0012B2  714081     IOR.B W2, W1, W1
0012B4  208D42     MOV #0x8D4, W2
0012B6  410000     ADD W2, W0, W0
0012B8  784801     MOV.B W1, [W0]
218:                           }
219:                       }
220:                       writeOffset += 128;
0012CC  200801     MOV #0x80, W1
0012CE  408F1E     ADD W1, [W14], [W14]
221:                       readOffset += OLED_DIG13_TOTALWIDTH;
0012D0  E8800E     INC2 W14, W0
0012D2  780010     MOV [W0], W0
0012D4  2006E1     MOV #0x6E, W1
0012D6  408080     ADD W1, W0, W1
0012D8  E8800E     INC2 W14, W0
0012DA  780801     MOV W1, [W0]
222:                   }
223:               }
0012F6  FA8000     ULNK
0012F8  060000     RETURN
224:               
225:               static void _oled_drawLabel(uint8_t index) {
0012FA  FA0008     LNK #0x8
0012FC  4700E6     ADD W14, #0x6, W1
0012FE  784880     MOV.B W0, [W1]
226:                   if (index > 4) return;
001300  470066     ADD W14, #0x6, W0
001302  784010     MOV.B [W0], W0
001304  504FE4     SUB.B W0, #0x4, [W15]
001306  3E0035     BRA GTU, .L30
001372  000000     NOP
227:                   
228:                   uint16_t writeOffset = 3 * 128 + _oled_labels_columns[index];
001308  470066     ADD W14, #0x6, W0
00130A  784010     MOV.B [W0], W0
00130C  FB8000     ZE W0, W0
00130E  400080     ADD W0, W0, W1
001310  28C680     MOV #0x8C68, W0
001312  408000     ADD W1, W0, W0
001314  780010     MOV [W0], W0
001316  201801     MOV #0x180, W1
001318  400F01     ADD W0, W1, [W14]
229:                   uint16_t readOffset = _oled_labels_offsets[index];
00131A  470066     ADD W14, #0x6, W0
00131C  784010     MOV.B [W0], W0
00131E  FB8000     ZE W0, W0
001320  400080     ADD W0, W0, W1
001322  28C5E0     MOV #0x8C5E, W0
001324  408080     ADD W1, W0, W1
001326  E8800E     INC2 W14, W0
001328  780811     MOV [W1], [W0]
230:                   
231:                   uint16_t i;
232:                   for (i = 0; i < 2; i++) {
00132A  EB0080     CLR W1
00132C  470064     ADD W14, #0x4, W0
00132E  780801     MOV W1, [W0]
001330  37001B     BRA .L28
00135E  470064     ADD W14, #0x4, W0
001360  780010     MOV [W0], W0
001362  E80080     INC W0, W1
001364  470064     ADD W14, #0x4, W0
001366  780801     MOV W1, [W0]
001368  470064     ADD W14, #0x4, W0
00136A  780010     MOV [W0], W0
00136C  500FE1     SUB W0, #0x1, [W15]
00136E  36FFE1     BRA LEU, .L29
001370  370001     BRA .L25
233:                       memcpy(sh_framebuf + writeOffset, _oled_labels + readOffset, _oled_labels_widths[index]);
001332  470066     ADD W14, #0x6, W0
001334  784010     MOV.B [W0], W0
001336  FB8000     ZE W0, W0
001338  400080     ADD W0, W0, W1
00133A  28C720     MOV #0x8C72, W0
00133C  408000     ADD W1, W0, W0
00133E  780110     MOV [W0], W2
001340  E8800E     INC2 W14, W0
001342  780090     MOV [W0], W1
001344  28C7C0     MOV #0x8C7C, W0
001346  408080     ADD W1, W0, W1
001348  208D40     MOV #0x8D4, W0
00134A  40001E     ADD W0, [W14], W0
00134C  07FADE     RCALL _memcpy
234:                       writeOffset += 128;
00134E  200801     MOV #0x80, W1
001350  408F1E     ADD W1, [W14], [W14]
235:                       readOffset += OLED_LABELS_TOTALWIDTH;
001352  E8800E     INC2 W14, W0
001354  780010     MOV [W0], W0
001356  2006E1     MOV #0x6E, W1
001358  408080     ADD W1, W0, W1
00135A  E8800E     INC2 W14, W0
00135C  780801     MOV W1, [W0]
236:                   }
237:               }
001374  FA8000     ULNK
001376  060000     RETURN
238:               
239:               static void _oled_drawNumber(uint8_t endColumn, int32_t numTimes100, uint8_t digits, uint8_t digitWidth, void (*digitFunc)(uint8_t, uint8_t)) {
001378  FA0016     LNK #0x16
00137A  47036C     ADD W14, #0xC, W6
00137C  784B00     MOV.B W0, [W6]
00137E  47006E     ADD W14, #0xE, W0
001380  BE8802     MOV.D W2, [W0]
001382  470072     ADD W14, #0x12, W0
001384  784801     MOV.B W1, [W0]
001386  470073     ADD W14, #0x13, W0
001388  784804     MOV.B W4, [W0]
00138A  470074     ADD W14, #0x14, W0
00138C  780805     MOV W5, [W0]
240:                   if (endColumn > 128 || digits < 3 || digits > 4) return;
00138E  47006C     ADD W14, #0xC, W0
001390  784090     MOV.B [W0], W1
001392  B3C800     MOV.B #0x80, W0
001394  50CF80     SUB.B W1, W0, [W15]
001396  3E00AC     BRA GTU, .L41
001398  470072     ADD W14, #0x12, W0
00139A  784010     MOV.B [W0], W0
00139C  504FE2     SUB.B W0, #0x2, [W15]
00139E  3600AA     BRA LEU, .L42
0013A0  470072     ADD W14, #0x12, W0
0013A2  784010     MOV.B [W0], W0
0013A4  504FE4     SUB.B W0, #0x4, [W15]
0013A6  3E00A8     BRA GTU, .L43
0014F0  000000     NOP
0014F2  370003     BRA .L31
0014F4  000000     NOP
0014F6  370001     BRA .L31
0014F8  000000     NOP
241:                   
242:                   uint8_t col = endColumn - digitWidth;
0013A8  47006C     ADD W14, #0xC, W0
0013AA  784090     MOV.B [W0], W1
0013AC  470073     ADD W14, #0x13, W0
0013AE  784010     MOV.B [W0], W0
0013B0  50CF00     SUB.B W1, W0, [W14]
243:                   uint16_t i;
244:                   
245:                   const int32_t limits[] = {1000, 10000};
0013B2  203E80     MOV #0x3E8, W0
0013B4  200001     MOV #0x0, W1
0013B6  470164     ADD W14, #0x4, W2
0013B8  BE8900     MOV.D W0, [W2]
0013BA  227100     MOV #0x2710, W0
0013BC  200001     MOV #0x0, W1
0013BE  470168     ADD W14, #0x8, W2
0013C0  BE8900     MOV.D W0, [W2]
246:                   if (numTimes100 < 0 || numTimes100 >= limits[digits - 3]) { //dashes for invalid numbers
0013C2  47006E     ADD W14, #0xE, W0
0013C4  BE0010     MOV.D [W0], W0
0013C6  500FE0     SUB W0, #0x0, [W15]
0013C8  588FE0     SUBB W1, #0x0, [W15]
0013CA  35000D     BRA LT, .L35
0013CC  470072     ADD W14, #0x12, W0
0013CE  784010     MOV.B [W0], W0
0013D0  FB8000     ZE W0, W0
0013D2  500063     SUB W0, #0x3, W0
0013D4  DD0042     SL W0, #2, W0
0013D6  4700E4     ADD W14, #0x4, W1
0013D8  408000     ADD W1, W0, W0
0013DA  BE0110     MOV.D [W0], W2
0013DC  47006E     ADD W14, #0xE, W0
0013DE  BE0010     MOV.D [W0], W0
0013E0  510F80     SUB W2, W0, [W15]
0013E2  598F81     SUBB W3, W1, [W15]
0013E4  3C002F     BRA GT, .L36
001442  37005B     BRA .L31
247:                       digitFunc(col, 10);
0013E6  470074     ADD W14, #0x14, W0
0013E8  780110     MOV [W0], W2
0013EA  B3C0A1     MOV.B #0xA, W1
0013EC  78401E     MOV.B [W14], W0
0013EE  010002     CALL W2
248:                       col -= digitWidth;
0013F0  78409E     MOV.B [W14], W1
0013F2  470073     ADD W14, #0x13, W0
0013F4  784010     MOV.B [W0], W0
0013F6  50CF00     SUB.B W1, W0, [W14]
249:                       digitFunc(col, 10);
0013F8  470074     ADD W14, #0x14, W0
0013FA  780110     MOV [W0], W2
0013FC  B3C0A1     MOV.B #0xA, W1
0013FE  78401E     MOV.B [W14], W0
001400  010002     CALL W2
250:                       col -= 2 * digitWidth;
001402  470073     ADD W14, #0x13, W0
001404  784090     MOV.B [W0], W1
001406  200FE0     MOV #0xFE, W0
001408  B98800     MUL.SS W1, W0, W0
00140A  780000     MOV W0, W0
00140C  784000     MOV.B W0, W0
00140E  404F1E     ADD.B W0, [W14], [W14]
251:                       for (i = 2; i < digits; i++) {
001410  200021     MOV #0x2, W1
001412  E8800E     INC2 W14, W0
001414  780801     MOV W1, [W0]
001416  37000E     BRA .L37
00142A  E8800E     INC2 W14, W0
00142C  780010     MOV [W0], W0
00142E  E80080     INC W0, W1
001430  E8800E     INC2 W14, W0
001432  780801     MOV W1, [W0]
001434  470072     ADD W14, #0x12, W0
001436  784010     MOV.B [W0], W0
001438  FB8000     ZE W0, W0
00143A  E8808E     INC2 W14, W1
00143C  780091     MOV [W1], W1
00143E  500F81     SUB W0, W1, [W15]
001440  3EFFEB     BRA GTU, .L38
252:                           digitFunc(col, 10);
001418  470074     ADD W14, #0x14, W0
00141A  780110     MOV [W0], W2
00141C  B3C0A1     MOV.B #0xA, W1
00141E  78401E     MOV.B [W14], W0
001420  010002     CALL W2
253:                           col -= digitWidth;
001422  78409E     MOV.B [W14], W1
001424  470073     ADD W14, #0x13, W0
001426  784010     MOV.B [W0], W0
001428  50CF00     SUB.B W1, W0, [W14]
254:                       }
255:                   } else { //draw number itself
256:                       digitFunc(col, numTimes100 % 10);
001444  47006E     ADD W14, #0xE, W0
001446  BE0010     MOV.D [W0], W0
001448  2000A2     MOV #0xA, W2
00144A  200003     MOV #0x0, W3
00144C  07FA3C     RCALL ___modsi3
00144E  784000     MOV.B W0, W0
001450  4700F4     ADD W14, #0x14, W1
001452  780111     MOV [W1], W2
001454  784080     MOV.B W0, W1
001456  78401E     MOV.B [W14], W0
001458  010002     CALL W2
257:                       col -= digitWidth;
00145A  78409E     MOV.B [W14], W1
00145C  470073     ADD W14, #0x13, W0
00145E  784010     MOV.B [W0], W0
001460  50CF00     SUB.B W1, W0, [W14]
258:                       numTimes100 /= 10;
001462  47006E     ADD W14, #0xE, W0
001464  BE0010     MOV.D [W0], W0
001466  2000A2     MOV #0xA, W2
001468  200003     MOV #0x0, W3
00146A  07FA1E     RCALL ___divsi3
00146C  47016E     ADD W14, #0xE, W2
00146E  BE8900     MOV.D W0, [W2]
259:                       digitFunc(col, numTimes100 % 10);
001470  47006E     ADD W14, #0xE, W0
001472  BE0010     MOV.D [W0], W0
001474  2000A2     MOV #0xA, W2
001476  200003     MOV #0x0, W3
001478  07FA26     RCALL ___modsi3
00147A  784000     MOV.B W0, W0
00147C  4700F4     ADD W14, #0x14, W1
00147E  780111     MOV [W1], W2
001480  784080     MOV.B W0, W1
001482  78401E     MOV.B [W14], W0
001484  010002     CALL W2
260:                       col -= 2 * digitWidth;
001486  470073     ADD W14, #0x13, W0
001488  784090     MOV.B [W0], W1
00148A  200FE0     MOV #0xFE, W0
00148C  B98800     MUL.SS W1, W0, W0
00148E  780000     MOV W0, W0
001490  784000     MOV.B W0, W0
001492  404F1E     ADD.B W0, [W14], [W14]
261:                       numTimes100 /= 10;
001494  47006E     ADD W14, #0xE, W0
001496  BE0010     MOV.D [W0], W0
001498  2000A2     MOV #0xA, W2
00149A  200003     MOV #0x0, W3
00149C  07FA05     RCALL ___divsi3
00149E  47016E     ADD W14, #0xE, W2
0014A0  BE8900     MOV.D W0, [W2]
262:                       for (i = 2; i < digits; i++) {
0014A2  200021     MOV #0x2, W1
0014A4  E8800E     INC2 W14, W0
0014A6  780801     MOV W1, [W0]
0014A8  37001B     BRA .L39
0014D6  E8800E     INC2 W14, W0
0014D8  780010     MOV [W0], W0
0014DA  E80080     INC W0, W1
0014DC  E8800E     INC2 W14, W0
0014DE  780801     MOV W1, [W0]
0014E0  470072     ADD W14, #0x12, W0
0014E2  784010     MOV.B [W0], W0
0014E4  FB8000     ZE W0, W0
0014E6  E8808E     INC2 W14, W1
0014E8  780091     MOV [W1], W1
0014EA  500F81     SUB W0, W1, [W15]
0014EC  3EFFDE     BRA GTU, .L40
0014EE  370005     BRA .L31
263:                           digitFunc(col, numTimes100 % 10);
0014AA  47006E     ADD W14, #0xE, W0
0014AC  BE0010     MOV.D [W0], W0
0014AE  2000A2     MOV #0xA, W2
0014B0  200003     MOV #0x0, W3
0014B2  07FA09     RCALL ___modsi3
0014B4  784000     MOV.B W0, W0
0014B6  4700F4     ADD W14, #0x14, W1
0014B8  780111     MOV [W1], W2
0014BA  784080     MOV.B W0, W1
0014BC  78401E     MOV.B [W14], W0
0014BE  010002     CALL W2
264:                           col -= digitWidth;
0014C0  78409E     MOV.B [W14], W1
0014C2  470073     ADD W14, #0x13, W0
0014C4  784010     MOV.B [W0], W0
0014C6  50CF00     SUB.B W1, W0, [W14]
265:                           numTimes100 /= 10;
0014C8  47006E     ADD W14, #0xE, W0
0014CA  BE0010     MOV.D [W0], W0
0014CC  2000A2     MOV #0xA, W2
0014CE  200003     MOV #0x0, W3
0014D0  07F9EB     RCALL ___divsi3
0014D2  47016E     ADD W14, #0xE, W2
0014D4  BE8900     MOV.D W0, [W2]
266:                       }
267:                   }
268:               }
0014FA  FA8000     ULNK
0014FC  060000     RETURN
269:               
270:               static void _oled_drawNumber12(uint8_t endColumn, int32_t numTimes100, uint8_t digits) {
0014FE  FA0008     LNK #0x8
001500  784F00     MOV.B W0, [W14]
001502  E8800E     INC2 W14, W0
001504  BE8802     MOV.D W2, [W0]
001506  470066     ADD W14, #0x6, W0
001508  784801     MOV.B W1, [W0]
271:                   _oled_drawNumber(endColumn, numTimes100, digits, OLED_DIG12_CHARWIDTH, &_oled_drawDigit12);
00150A  2116C5     MOV #0x116C, W5
00150C  B3C094     MOV.B #0x9, W4
00150E  470066     ADD W14, #0x6, W0
001510  784090     MOV.B [W0], W1
001512  E8800E     INC2 W14, W0
001514  BE0110     MOV.D [W0], W2
001516  78401E     MOV.B [W14], W0
001518  07FF2F     RCALL _oled_drawNumber
272:               }
00151A  FA8000     ULNK
00151C  060000     RETURN
273:               
274:               static void _oled_drawNumber13(uint8_t endColumn, int32_t numTimes100, uint8_t digits) {
00151E  FA0008     LNK #0x8
001520  784F00     MOV.B W0, [W14]
001522  E8800E     INC2 W14, W0
001524  BE8802     MOV.D W2, [W0]
001526  470066     ADD W14, #0x6, W0
001528  784801     MOV.B W1, [W0]
275:                   _oled_drawNumber(endColumn, numTimes100, digits, OLED_DIG13_CHARWIDTH, &_oled_drawDigit13);
00152A  212325     MOV #0x1232, W5
00152C  B3C0A4     MOV.B #0xA, W4
00152E  470066     ADD W14, #0x6, W0
001530  784090     MOV.B [W0], W1
001532  E8800E     INC2 W14, W0
001534  BE0110     MOV.D [W0], W2
001536  78401E     MOV.B [W14], W0
001538  07FF1F     RCALL _oled_drawNumber
276:               }
00153A  FA8000     ULNK
00153C  060000     RETURN
277:               
278:               static void _oled_drawSelectBox(uint8_t startColumn, uint8_t endColumn) {
00153E  FA0002     LNK #0x2
001540  784F00     MOV.B W0, [W14]
001542  E8000E     INC W14, W0
001544  784801     MOV.B W1, [W0]
279:                   sh_framebuf[startColumn] |= 0xFC;
001546  FB801E     ZE [W14], W0
001548  FB809E     ZE [W14], W1
00154A  208D42     MOV #0x8D4, W2
00154C  410081     ADD W2, W1, W1
00154E  784111     MOV.B [W1], W2
001550  B3CFC1     MOV.B #0xFC, W1
001552  714081     IOR.B W2, W1, W1
001554  208D42     MOV #0x8D4, W2
001556  410000     ADD W2, W0, W0
001558  784801     MOV.B W1, [W0]
280:                   sh_framebuf[128 + startColumn] |= 0xFF;
00155A  FB801E     ZE [W14], W0
00155C  B00800     ADD #0x80, W0
00155E  208D42     MOV #0x8D4, W2
001560  EBC080     SETM.B W1
001562  410000     ADD W2, W0, W0
001564  784801     MOV.B W1, [W0]
281:                   sh_framebuf[256 + startColumn] |= 0x0F;
001566  FB801E     ZE [W14], W0
001568  B01000     ADD #0x100, W0
00156A  FB809E     ZE [W14], W1
00156C  B01001     ADD #0x100, W1
00156E  208D42     MOV #0x8D4, W2
001570  410081     ADD W2, W1, W1
001572  784091     MOV.B [W1], W1
001574  B340F1     IOR.B #0xF, W1
001576  208D42     MOV #0x8D4, W2
001578  410000     ADD W2, W0, W0
00157A  784801     MOV.B W1, [W0]
282:                   sh_framebuf[endColumn - 1] |= 0xFC;
00157C  E8000E     INC W14, W0
00157E  784010     MOV.B [W0], W0
001580  FB8000     ZE W0, W0
001582  E90000     DEC W0, W0
001584  E8008E     INC W14, W1
001586  784091     MOV.B [W1], W1
001588  FB8081     ZE W1, W1
00158A  E90081     DEC W1, W1
00158C  208D42     MOV #0x8D4, W2
00158E  410081     ADD W2, W1, W1
001590  784111     MOV.B [W1], W2
001592  B3CFC1     MOV.B #0xFC, W1
001594  714081     IOR.B W2, W1, W1
001596  208D42     MOV #0x8D4, W2
001598  410000     ADD W2, W0, W0
00159A  784801     MOV.B W1, [W0]
283:                   sh_framebuf[128 + endColumn - 1] |= 0xFF;
00159C  E8000E     INC W14, W0
00159E  784010     MOV.B [W0], W0
0015A0  FB8000     ZE W0, W0
0015A2  B007F0     ADD #0x7F, W0
0015A4  208D42     MOV #0x8D4, W2
0015A6  EBC080     SETM.B W1
0015A8  410000     ADD W2, W0, W0
0015AA  784801     MOV.B W1, [W0]
284:                   sh_framebuf[256 + endColumn - 1] |= 0x0F;
0015AC  E8000E     INC W14, W0
0015AE  784010     MOV.B [W0], W0
0015B0  FB8000     ZE W0, W0
0015B2  B00FF0     ADD #0xFF, W0
0015B4  E8008E     INC W14, W1
0015B6  784091     MOV.B [W1], W1
0015B8  FB8081     ZE W1, W1
0015BA  B00FF1     ADD #0xFF, W1
0015BC  208D42     MOV #0x8D4, W2
0015BE  410081     ADD W2, W1, W1
0015C0  784091     MOV.B [W1], W1
0015C2  B340F1     IOR.B #0xF, W1
0015C4  208D42     MOV #0x8D4, W2
0015C6  410000     ADD W2, W0, W0
0015C8  784801     MOV.B W1, [W0]
285:                   
286:                   sh_framebuf[startColumn + 1] |= 0x04;
0015CA  FB801E     ZE [W14], W0
0015CC  E80000     INC W0, W0
0015CE  FB809E     ZE [W14], W1
0015D0  E80081     INC W1, W1
0015D2  208D42     MOV #0x8D4, W2
0015D4  410081     ADD W2, W1, W1
0015D6  784091     MOV.B [W1], W1
0015D8  A02401     BSET.B W1, #2
0015DA  208D42     MOV #0x8D4, W2
0015DC  410000     ADD W2, W0, W0
0015DE  784801     MOV.B W1, [W0]
287:                   sh_framebuf[startColumn + 2] |= 0x04;
0015E0  FB801E     ZE [W14], W0
0015E2  E88000     INC2 W0, W0
0015E4  FB809E     ZE [W14], W1
0015E6  E88081     INC2 W1, W1
0015E8  208D42     MOV #0x8D4, W2
0015EA  410081     ADD W2, W1, W1
0015EC  784091     MOV.B [W1], W1
0015EE  A02401     BSET.B W1, #2
0015F0  208D42     MOV #0x8D4, W2
0015F2  410000     ADD W2, W0, W0
0015F4  784801     MOV.B W1, [W0]
288:                   sh_framebuf[endColumn - 2] |= 0x04;
0015F6  E8000E     INC W14, W0
0015F8  784010     MOV.B [W0], W0
0015FA  FB8000     ZE W0, W0
0015FC  E98000     DEC2 W0, W0
0015FE  E8008E     INC W14, W1
001600  784091     MOV.B [W1], W1
001602  FB8081     ZE W1, W1
001604  E98081     DEC2 W1, W1
001606  208D42     MOV #0x8D4, W2
001608  410081     ADD W2, W1, W1
00160A  784091     MOV.B [W1], W1
00160C  A02401     BSET.B W1, #2
00160E  208D42     MOV #0x8D4, W2
001610  410000     ADD W2, W0, W0
001612  784801     MOV.B W1, [W0]
289:                   sh_framebuf[endColumn - 3] |= 0x04;
001614  E8000E     INC W14, W0
001616  784010     MOV.B [W0], W0
001618  FB8000     ZE W0, W0
00161A  500063     SUB W0, #0x3, W0
00161C  E8008E     INC W14, W1
00161E  784091     MOV.B [W1], W1
001620  FB8081     ZE W1, W1
001622  5080E3     SUB W1, #0x3, W1
001624  208D42     MOV #0x8D4, W2
001626  410081     ADD W2, W1, W1
001628  784091     MOV.B [W1], W1
00162A  A02401     BSET.B W1, #2
00162C  208D42     MOV #0x8D4, W2
00162E  410000     ADD W2, W0, W0
001630  784801     MOV.B W1, [W0]
290:                   
291:                   sh_framebuf[256 + startColumn + 1] |= 0x08;
001632  FB801E     ZE [W14], W0
001634  B01010     ADD #0x101, W0
001636  FB809E     ZE [W14], W1
001638  B01011     ADD #0x101, W1
00163A  208D42     MOV #0x8D4, W2
00163C  410081     ADD W2, W1, W1
00163E  784091     MOV.B [W1], W1
001640  A03401     BSET.B W1, #3
001642  208D42     MOV #0x8D4, W2
001644  410000     ADD W2, W0, W0
001646  784801     MOV.B W1, [W0]
292:                   sh_framebuf[256 + startColumn + 2] |= 0x08;
001648  FB801E     ZE [W14], W0
00164A  B01020     ADD #0x102, W0
00164C  FB809E     ZE [W14], W1
00164E  B01021     ADD #0x102, W1
001650  208D42     MOV #0x8D4, W2
001652  410081     ADD W2, W1, W1
001654  784091     MOV.B [W1], W1
001656  A03401     BSET.B W1, #3
001658  208D42     MOV #0x8D4, W2
00165A  410000     ADD W2, W0, W0
00165C  784801     MOV.B W1, [W0]
293:                   sh_framebuf[256 + endColumn - 2] |= 0x08;
00165E  E8000E     INC W14, W0
001660  784010     MOV.B [W0], W0
001662  FB8000     ZE W0, W0
001664  B00FE0     ADD #0xFE, W0
001666  E8008E     INC W14, W1
001668  784091     MOV.B [W1], W1
00166A  FB8081     ZE W1, W1
00166C  B00FE1     ADD #0xFE, W1
00166E  208D42     MOV #0x8D4, W2
001670  410081     ADD W2, W1, W1
001672  784091     MOV.B [W1], W1
001674  A03401     BSET.B W1, #3
001676  208D42     MOV #0x8D4, W2
001678  410000     ADD W2, W0, W0
00167A  784801     MOV.B W1, [W0]
294:                   sh_framebuf[256 + endColumn - 3] |= 0x08;
00167C  E8000E     INC W14, W0
00167E  784010     MOV.B [W0], W0
001680  FB8000     ZE W0, W0
001682  B00FD0     ADD #0xFD, W0
001684  E8008E     INC W14, W1
001686  784091     MOV.B [W1], W1
001688  FB8081     ZE W1, W1
00168A  B00FD1     ADD #0xFD, W1
00168C  208D42     MOV #0x8D4, W2
00168E  410081     ADD W2, W1, W1
001690  784091     MOV.B [W1], W1
001692  A03401     BSET.B W1, #3
001694  208D42     MOV #0x8D4, W2
001696  410000     ADD W2, W0, W0
001698  784801     MOV.B W1, [W0]
295:               }
00169A  FA8000     ULNK
00169C  060000     RETURN
296:               
297:               
298:               bool OLED_UpdateScreen() {
00169E  FA0000     LNK #0x0
299:                   memcpy(sh_framebuf, _oled_background, SH_FRAMEBUF_SIZE);
0016A0  204002     MOV #0x400, W2
0016A2  28D581     MOV #0x8D58, W1
0016A4  208D40     MOV #0x8D4, W0
0016A6  07F931     RCALL _memcpy
300:                   
301:                   _oled_drawNumber12(48, ui_setVoltage, 4);
0016A8  8045D2     MOV 0x8BA, W2
0016AA  8045E3     MOV 0x8BC, W3
0016AC  B3C041     MOV.B #0x4, W1
0016AE  B3C300     MOV.B #0x30, W0
0016B0  07FF26     RCALL _oled_drawNumber12
302:                   _oled_drawNumber12(115, ui_setCurrent, 3);
0016B2  8045F2     MOV 0x8BE, W2
0016B4  804603     MOV 0x8C0, W3
0016B6  B3C031     MOV.B #0x3, W1
0016B8  B3C730     MOV.B #0x73, W0
0016BA  07FF21     RCALL _oled_drawNumber12
303:                   
304:                   _oled_drawNumber13(53, ui_outVoltage, 4);
0016BC  804282     MOV ui_outVoltage, W2
0016BE  804293     MOV 0x852, W3
0016C0  B3C041     MOV.B #0x4, W1
0016C2  B3C350     MOV.B #0x35, W0
0016C4  07FF2C     RCALL _oled_drawNumber13
305:                   _oled_drawNumber13(114, ui_outCurrent, 3);
0016C6  8042A2     MOV ui_outCurrent, W2
0016C8  8042B3     MOV 0x856, W3
0016CA  B3C031     MOV.B #0x3, W1
0016CC  B3C720     MOV.B #0x72, W0
0016CE  07FF27     RCALL _oled_drawNumber13
306:                   
307:                   _oled_drawLabel(ui_pps ? 1 : 0);
0016D0  BFC858     MOV.B ui_pps, WREG
0016D2  07FE13     RCALL _oled_drawLabel
308:                   _oled_drawLabel(ui_cc ? 3 : 2);
0016D4  BFC859     MOV.B ui_cc, WREG
0016D6  E00400     CP0.B W0
0016D8  320002     BRA Z, .L48
0016DA  B3C030     MOV.B #0x3, W0
0016DC  370001     BRA .L49
0016DE  B3C020     MOV.B #0x2, W0
0016E0  07FE0C     RCALL _oled_drawLabel
309:                   if (ui_outputOn) _oled_drawLabel(4);
0016E2  BFC85A     MOV.B ui_outputOn, WREG
0016E4  E00400     CP0.B W0
0016E6  320002     BRA Z, .L50
0016E8  B3C040     MOV.B #0x4, W0
0016EA  07FE07     RCALL _oled_drawLabel
310:                   
311:                   if (ui_state == UI_ADJ_VOLTAGE) _oled_drawSelectBox(2, 59);
0016EC  804400     MOV ui_state, W0
0016EE  500FE1     SUB W0, #0x1, [W15]
0016F0  3A0004     BRA NZ, .L51
0016F2  B3C3B1     MOV.B #0x3B, W1
0016F4  B3C020     MOV.B #0x2, W0
0016F6  07FF23     RCALL _oled_drawSelectBox
0016F8  370006     BRA .L52
312:                   else if (ui_state == UI_ADJ_CURRENT) _oled_drawSelectBox(78, 126);
0016FA  804400     MOV ui_state, W0
0016FC  500FE2     SUB W0, #0x2, [W15]
0016FE  3A0003     BRA NZ, .L52
001700  B3C7E1     MOV.B #0x7E, W1
001702  B3C4E0     MOV.B #0x4E, W0
001704  07FF1C     RCALL _oled_drawSelectBox
313:                   
314:                   return SH_WriteFramebuffer();
001706  070684     RCALL SH_WriteFramebuffer
315:               }
001708  FA8000     ULNK
00170A  060000     RETURN
316:               
317:               bool OLED_Initialize() {
00170C  FA0000     LNK #0x0
318:                   asserttrue(SH_Initialize());
00170E  0706C2     RCALL SH_Initialize
001710  A20400     BTG.B W0, #0
001712  E00400     CP0.B W0
001714  320002     BRA Z, .L54
001716  EB4000     CLR.B W0
001718  370001     BRA .L55
319:                   
320:                   return OLED_UpdateScreen();
00171A  07FFC1     RCALL OLED_UpdateScreen
321:               }
00171C  FA8000     ULNK
00171E  060000     RETURN
---  E:/Users/Alex/Documents/eagle/projects/USBPD Supply/adapter/USBPD-Adapter.X/mcc_generated_files/traps.c
1:                 /**
2:                   System Traps Generated Driver File 
3:                 
4:                   @Company:
5:                     Microchip Technology Inc.
6:                 
7:                   @File Name:
8:                     traps.h
9:                 
10:                  @Summary:
11:                    This is the generated driver implementation file for handling traps
12:                    using PIC24 / dsPIC33 / PIC32MM MCUs
13:                
14:                  @Description:
15:                    This source file provides implementations for PIC24 / dsPIC33 / PIC32MM MCUs traps.
16:                    Generation Information : 
17:                        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - 1.171.1
18:                        Device            :  PIC24FJ128GA702
19:                    The generated drivers are tested against the following:
20:                        Compiler          :  XC16 v1.70
21:                        MPLAB             :  MPLAB X v5.50
22:                */
23:                /*
24:                    (c) 2020 Microchip Technology Inc. and its subsidiaries. You may use this
25:                    software and any derivatives exclusively with Microchip products.
26:                
27:                    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:                    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:                    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:                    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
31:                    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
32:                
33:                    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:                    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:                    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:                    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:                    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:                
41:                    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
42:                    TERMS.
43:                */
44:                
45:                /**
46:                    Section: Includes
47:                */
48:                #include <xc.h>
49:                #include "traps.h"
50:                
51:                #define ERROR_HANDLER __attribute__((interrupt,no_auto_psv))
52:                #define FAILSAFE_STACK_GUARDSIZE 8
53:                
54:                /**
55:                 * a private place to store the error code if we run into a severe error
56:                 */
57:                static uint16_t TRAPS_error_code = -1;
58:                
59:                /**
60:                 * Halts 
61:                 * 
62:                 * @param code error code
63:                 */
64:                void __attribute__((weak)) TRAPS_halt_on_error(uint16_t code)
65:                {
00299A  FA0002     LNK #0x2
00299C  780F00     MOV W0, [W14]
66:                    TRAPS_error_code = code;
00299E  78009E     MOV [W14], W1
0029A0  884141     MOV W1, 0x828
0029A2  DA4000     BREAK
67:                #ifdef __DEBUG    
68:                    __builtin_software_breakpoint();
69:                    /* If we are in debug mode, cause a software breakpoint in the debugger */
70:                #endif
71:                    while(1);
0029A4  37FFFF     BRA .L2
72:                    
73:                }
74:                
75:                /**
76:                 * Sets the stack pointer to a backup area of memory, in case we run into
77:                 * a stack error (in which case we can't really trust the stack pointer)
78:                 */
79:                inline static void use_failsafe_stack(void)
80:                {
0029A6  FA0000     LNK #0x0
81:                    static uint8_t failsafe_stack[32];
82:                    asm volatile (
0029A8  20CD40     MOV #0xCD4, W0
0029AA  780780     MOV W0, W15
83:                        "   mov    %[pstack], W15\n"
84:                        :
85:                        : [pstack]"r"(failsafe_stack)
86:                    );
87:                /* Controls where the stack pointer limit is, relative to the end of the
88:                 * failsafe stack
89:                 */    
90:                    SPLIM = (uint16_t)(((uint8_t *)failsafe_stack) + sizeof(failsafe_stack) 
0029AC  20CEC0     MOV #0xCEC, W0
0029AE  880100     MOV W0, SPLIM
91:                            - FAILSAFE_STACK_GUARDSIZE);
92:                }
0029B0  FA8000     ULNK
0029B2  060000     RETURN
93:                
94:                /** Oscillator Fail Trap vector**/
95:                void ERROR_HANDLER _OscillatorFail(void)
96:                {
00024C  F80036     PUSH RCOUNT
00024E  BE9F80     MOV.D W0, [W15++]
000250  BE9F82     MOV.D W2, [W15++]
000252  BE9F84     MOV.D W4, [W15++]
000254  BE9F86     MOV.D W6, [W15++]
000256  FA0000     LNK #0x0
97:                    INTCON1bits.OSCFAIL = 0;  //Clear the trap flag
000258  A92080     BCLR INTCON1, #1
98:                    TRAPS_halt_on_error(TRAPS_OSC_FAIL);
00025A  EB0000     CLR W0
00025C  07139E     RCALL TRAPS_halt_on_error
99:                }
00025E  FA8000     ULNK
000260  BE034F     MOV.D [--W15], W6
000262  BE024F     MOV.D [--W15], W4
000264  BE014F     MOV.D [--W15], W2
000266  BE004F     MOV.D [--W15], W0
000268  F90036     POP RCOUNT
00026A  064000     RETFIE
100:               /** Stack Error Trap Vector**/
101:               void ERROR_HANDLER _StackError(void)
102:               {
00026C  F80036     PUSH RCOUNT
00026E  BE9F80     MOV.D W0, [W15++]
000270  BE9F82     MOV.D W2, [W15++]
000272  BE9F84     MOV.D W4, [W15++]
000274  BE9F86     MOV.D W6, [W15++]
000276  FA0000     LNK #0x0
103:                   /* We use a failsafe stack: the presence of a stack-pointer error
104:                    * means that we cannot trust the stack to operate correctly unless
105:                    * we set the stack pointer to a safe place.
106:                    */
107:                   use_failsafe_stack(); 
000278  071396     RCALL use_failsafe_stack
108:                   INTCON1bits.STKERR = 0;  //Clear the trap flag
00027A  A94080     BCLR INTCON1, #2
109:                   TRAPS_halt_on_error(TRAPS_STACK_ERR);
00027C  200010     MOV #0x1, W0
00027E  07138D     RCALL TRAPS_halt_on_error
110:               }
000280  FA8000     ULNK
000282  BE034F     MOV.D [--W15], W6
000284  BE024F     MOV.D [--W15], W4
000286  BE014F     MOV.D [--W15], W2
000288  BE004F     MOV.D [--W15], W0
00028A  F90036     POP RCOUNT
00028C  064000     RETFIE
111:               /** Address Error Trap Vector**/
112:               void ERROR_HANDLER _AddressError(void)
113:               {
00028E  F80036     PUSH RCOUNT
000290  BE9F80     MOV.D W0, [W15++]
000292  BE9F82     MOV.D W2, [W15++]
000294  BE9F84     MOV.D W4, [W15++]
000296  BE9F86     MOV.D W6, [W15++]
000298  FA0000     LNK #0x0
114:                   INTCON1bits.ADDRERR = 0;  //Clear the trap flag
00029A  A96080     BCLR INTCON1, #3
115:                   TRAPS_halt_on_error(TRAPS_ADDRESS_ERR);
00029C  200020     MOV #0x2, W0
00029E  07137D     RCALL TRAPS_halt_on_error
116:               }
0002A0  FA8000     ULNK
0002A2  BE034F     MOV.D [--W15], W6
0002A4  BE024F     MOV.D [--W15], W4
0002A6  BE014F     MOV.D [--W15], W2
0002A8  BE004F     MOV.D [--W15], W0
0002AA  F90036     POP RCOUNT
0002AC  064000     RETFIE
117:               /** Math Error Trap Vector**/
118:               void ERROR_HANDLER _MathError(void)
119:               {
0002AE  F80036     PUSH RCOUNT
0002B0  BE9F80     MOV.D W0, [W15++]
0002B2  BE9F82     MOV.D W2, [W15++]
0002B4  BE9F84     MOV.D W4, [W15++]
0002B6  BE9F86     MOV.D W6, [W15++]
0002B8  FA0000     LNK #0x0
120:                   INTCON1bits.MATHERR = 0;  //Clear the trap flag
0002BA  A98080     BCLR INTCON1, #4
121:                   TRAPS_halt_on_error(TRAPS_MATH_ERR);
0002BC  200030     MOV #0x3, W0
0002BE  07136D     RCALL TRAPS_halt_on_error
122:               }
0002C0  FA8000     ULNK
0002C2  BE034F     MOV.D [--W15], W6
0002C4  BE024F     MOV.D [--W15], W4
0002C6  BE014F     MOV.D [--W15], W2
0002C8  BE004F     MOV.D [--W15], W0
0002CA  F90036     POP RCOUNT
0002CC  064000     RETFIE
123:               /** NVM Error Trap Vector**/
124:               void ERROR_HANDLER _NVMError(void)
125:               {
0002CE  F80036     PUSH RCOUNT
0002D0  BE9F80     MOV.D W0, [W15++]
0002D2  BE9F82     MOV.D W2, [W15++]
0002D4  BE9F84     MOV.D W4, [W15++]
0002D6  BE9F86     MOV.D W6, [W15++]
0002D8  FA0000     LNK #0x0
126:                   INTCON4bits.SGHT = 0;  //Clear the trap flag
0002DA  A90086     BCLR INTCON4, #0
127:                   TRAPS_halt_on_error(TRAPS_NVM_ERR);
0002DC  200070     MOV #0x7, W0
0002DE  07135D     RCALL TRAPS_halt_on_error
128:               }
0002E0  FA8000     ULNK
0002E2  BE034F     MOV.D [--W15], W6
0002E4  BE024F     MOV.D [--W15], W4
0002E6  BE014F     MOV.D [--W15], W2
0002E8  BE004F     MOV.D [--W15], W0
0002EA  F90036     POP RCOUNT
0002EC  064000     RETFIE
---  E:/Users/Alex/Documents/eagle/projects/USBPD Supply/adapter/USBPD-Adapter.X/mcc_generated_files/tmr2.c
1:                 
2:                 /**
3:                   TMR2 Generated Driver API Source File 
4:                 
5:                   @Company
6:                     Microchip Technology Inc.
7:                 
8:                   @File Name
9:                     tmr2.c
10:                
11:                  @Summary
12:                    This is the generated source file for the TMR2 driver using PIC24 / dsPIC33 / PIC32MM MCUs
13:                
14:                  @Description
15:                    This source file provides APIs for driver for TMR2. 
16:                    Generation Information : 
17:                        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - 1.171.1
18:                        Device            :  PIC24FJ128GA702
19:                    The generated drivers are tested against the following:
20:                        Compiler          :  XC16 v1.70
21:                        MPLAB             :  MPLAB X v5.50
22:                */
23:                
24:                /*
25:                    (c) 2020 Microchip Technology Inc. and its subsidiaries. You may use this
26:                    software and any derivatives exclusively with Microchip products.
27:                
28:                    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
29:                    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
30:                    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
31:                    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
32:                    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
33:                
34:                    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
35:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
36:                    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
37:                    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
38:                    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
39:                    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
40:                    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
41:                
42:                    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
43:                    TERMS.
44:                */
45:                
46:                /**
47:                  Section: Included Files
48:                */
49:                
50:                #include <stdio.h>
51:                #include "tmr2.h"
52:                
53:                /**
54:                 Section: File specific functions
55:                */
56:                void (*TMR2_InterruptHandler)(void) = NULL;
57:                void TMR2_CallBack(void);
58:                
59:                /**
60:                  Section: Data Type Definitions
61:                */
62:                
63:                /** TMR Driver Hardware Instance Object
64:                
65:                  @Summary
66:                    Defines the object required for the maintenance of the hardware instance.
67:                
68:                  @Description
69:                    This defines the object required for the maintenance of the hardware
70:                    instance. This object exists once per hardware instance of the peripheral.
71:                
72:                  Remarks:
73:                    None.
74:                */
75:                
76:                typedef struct _TMR_OBJ_STRUCT
77:                {
78:                    /* Timer Elapsed */
79:                    volatile bool           timerElapsed;
80:                    /*Software Counter value*/
81:                    volatile uint8_t        count;
82:                
83:                } TMR_OBJ;
84:                
85:                static TMR_OBJ tmr2_obj;
86:                
87:                /**
88:                  Section: Driver Interface
89:                */
90:                
91:                void TMR2_Initialize (void)
92:                {
0025A0  FA0000     LNK #0x0
93:                    //TMR3 0; 
94:                    TMR3 = 0x00;
0025A2  EF219A     CLR TMR3
95:                    //PR3 65535; 
96:                    PR3 = 0xFFFF;
0025A4  EB8000     SETM W0
0025A6  880CF0     MOV W0, PR3
97:                    //TMR2 0; 
98:                    TMR2 = 0x00;
0025A8  EF2196     CLR TMR2
99:                    //Period = 2147.483648 s; Frequency = 16000000 Hz; PR2 65535; 
100:                   PR2 = 0xFFFF;
0025AA  EB8000     SETM W0
0025AC  880CE0     MOV W0, PR2
101:                   //TCKPS 1:8; T32 32 Bit; TON enabled; TSIDL disabled; TCS FOSC/2; TECS SOSC; TGATE disabled; 
102:                   T2CON = 0x8018;
0025AE  280180     MOV #0x8018, W0
0025B0  880D00     MOV W0, T2CON
103:               
104:                   if(TMR2_InterruptHandler == NULL)
0025B2  804680     MOV TMR2_InterruptHandler, W0
0025B4  E00000     CP0 W0
0025B6  3A0002     BRA NZ, .L2
105:                   {
106:                       TMR2_SetInterruptHandler(&TMR2_CallBack);
0025B8  2263E0     MOV #0x263E, W0
0025BA  070044     RCALL TMR2_SetInterruptHandler
107:                   }
108:               
109:                   IFS0bits.T3IF = false;
0025BC  A90089     BCLR 0x89, #0
110:                   IEC0bits.T3IE = true;
0025BE  A80099     BSET 0x99, #0
111:               	
112:                   tmr2_obj.timerElapsed = false;
0025C0  20D180     MOV #0xD18, W0
0025C2  EB4080     CLR.B W1
0025C4  784801     MOV.B W1, [W0]
113:               
114:               }
0025C6  FA8000     ULNK
0025C8  060000     RETURN
115:               
116:               
117:               void __attribute__ ( ( interrupt, no_auto_psv ) ) _T3Interrupt (  )
118:               {
00085E  F80036     PUSH RCOUNT
000860  BE9F80     MOV.D W0, [W15++]
000862  BE9F82     MOV.D W2, [W15++]
000864  BE9F84     MOV.D W4, [W15++]
000866  BE9F86     MOV.D W6, [W15++]
000868  FA0000     LNK #0x0
119:                   /* Check if the Timer Interrupt/Status is set */
120:               
121:                   //***User Area Begin
122:                   static volatile unsigned int CountCallBack = 0;
123:               
124:                   // callback function - called every 10th pass
125:                   if (++CountCallBack >= TMR2_INTERRUPT_TICKER_FACTOR)
00086A  804690     MOV CountCallBack, W0
00086C  E80000     INC W0, W0
00086E  884690     MOV W0, CountCallBack
000870  804690     MOV CountCallBack, W0
000872  500FE9     SUB W0, #0x9, [W15]
000874  360006     BRA LEU, .L4
126:                   {
127:                       // ticker function call
128:                       if(TMR2_InterruptHandler) 
000876  804680     MOV TMR2_InterruptHandler, W0
000878  E00000     CP0 W0
00087A  320002     BRA Z, .L5
129:                       { 
130:                           TMR2_InterruptHandler(); 
00087C  804680     MOV TMR2_InterruptHandler, W0
00087E  010000     CALL W0
131:                       }
132:               
133:                       // reset ticker counter
134:                       CountCallBack = 0;
000880  EF28D2     CLR CountCallBack
135:                   }
136:               
137:                   //***User Area End
138:               
139:                   tmr2_obj.count++;
000882  20D190     MOV #0xD19, W0
000884  784010     MOV.B [W0], W0
000886  E84080     INC.B W0, W1
000888  20D190     MOV #0xD19, W0
00088A  784801     MOV.B W1, [W0]
140:                   tmr2_obj.timerElapsed = true;
00088C  20D180     MOV #0xD18, W0
00088E  B3C011     MOV.B #0x1, W1
000890  784801     MOV.B W1, [W0]
141:                   IFS0bits.T3IF = false;
000892  A90089     BCLR 0x89, #0
142:               }
000894  FA8000     ULNK
000896  BE034F     MOV.D [--W15], W6
000898  BE024F     MOV.D [--W15], W4
00089A  BE014F     MOV.D [--W15], W2
00089C  BE004F     MOV.D [--W15], W0
00089E  F90036     POP RCOUNT
0008A0  064000     RETFIE
143:               
144:               void TMR2_Period32BitSet( uint32_t value )
145:               {
0025CA  FA0004     LNK #0x4
0025CC  BE8F00     MOV.D W0, [W14]
146:                   /* Update the counter values */
147:                   PR2 = (value & 0x0000FFFF);
0025CE  78001E     MOV [W14], W0
0025D0  880CE0     MOV W0, PR2
148:                   PR3 = ((value & 0xFFFF0000)>>16);
0025D2  BE001E     MOV.D [W14], W0
0025D4  DE0840     LSR W1, #0, W0
0025D6  780000     MOV W0, W0
0025D8  880CF0     MOV W0, PR3
149:               }
0025DA  FA8000     ULNK
0025DC  060000     RETURN
150:               
151:               uint32_t TMR2_Period32BitGet( void )
152:               {
0025DE  FA0004     LNK #0x4
153:                   uint32_t periodVal = 0xFFFFFFFF;
0025E0  EB8000     SETM W0
0025E2  EB8080     SETM W1
0025E4  BE8F00     MOV.D W0, [W14]
154:               
155:                   /* get the timer period value and return it */
156:                   periodVal = (((uint32_t)PR3 <<16) | PR2);
0025E6  800CF0     MOV PR3, W0
0025E8  EB0080     CLR W1
0025EA  DD01C0     SL W0, #0, W3
0025EC  200002     MOV #0x0, W2
0025EE  800CE0     MOV PR2, W0
0025F0  EB0080     CLR W1
0025F2  711F00     IOR W2, W0, [W14++]
0025F4  719701     IOR W3, W1, [W14--]
157:               
158:                   return( periodVal );
0025F6  BE001E     MOV.D [W14], W0
159:               
160:               }
0025F8  FA8000     ULNK
0025FA  060000     RETURN
161:               
162:               void TMR2_Counter32BitSet( uint32_t value )
163:               {
0025FC  FA0004     LNK #0x4
0025FE  BE8F00     MOV.D W0, [W14]
164:                   /* Update the counter values */
165:                  TMR3HLD = ((value & 0xFFFF0000)>>16);
002600  BE001E     MOV.D [W14], W0
002602  DE0840     LSR W1, #0, W0
002604  780000     MOV W0, W0
002606  880CC0     MOV W0, TMR3HLD
166:                  TMR2 = (value & 0x0000FFFF);
002608  78001E     MOV [W14], W0
00260A  880CB0     MOV W0, TMR2
167:               
168:               }
00260C  FA8000     ULNK
00260E  060000     RETURN
169:               
170:               uint32_t TMR2_Counter32BitGet( void )
171:               {
002610  FA0008     LNK #0x8
172:                   uint32_t countVal = 0xFFFFFFFF;
002612  EB8000     SETM W0
002614  EB8080     SETM W1
002616  BE8F00     MOV.D W0, [W14]
173:                   uint16_t countValUpper;
174:                   uint16_t countValLower;
175:               
176:                   countValLower = TMR2;
002618  470064     ADD W14, #0x4, W0
00261A  800CB1     MOV TMR2, W1
00261C  780801     MOV W1, [W0]
177:                   countValUpper = TMR3HLD;
00261E  470066     ADD W14, #0x6, W0
002620  800CC1     MOV TMR3HLD, W1
002622  780801     MOV W1, [W0]
178:               
179:                   /* get the current counter value and return it */
180:                   countVal = (((uint32_t)countValUpper<<16)| countValLower );
002624  470066     ADD W14, #0x6, W0
002626  780010     MOV [W0], W0
002628  EB0080     CLR W1
00262A  DD01C0     SL W0, #0, W3
00262C  200002     MOV #0x0, W2
00262E  470064     ADD W14, #0x4, W0
002630  780010     MOV [W0], W0
002632  EB0080     CLR W1
002634  711F00     IOR W2, W0, [W14++]
002636  719701     IOR W3, W1, [W14--]
181:               
182:                   return( countVal );
002638  BE001E     MOV.D [W14], W0
183:               
184:               }
00263A  FA8000     ULNK
00263C  060000     RETURN
185:               
186:               
187:               void __attribute__ ((weak)) TMR2_CallBack(void)
188:               {
00263E  FA0000     LNK #0x0
189:                   // Add your custom callback code here
190:               }
002640  FA8000     ULNK
002642  060000     RETURN
191:               
192:               void  TMR2_SetInterruptHandler(void (* InterruptHandler)(void))
193:               { 
002644  FA0002     LNK #0x2
002646  780F00     MOV W0, [W14]
194:                   IEC0bits.T3IE = false;
002648  A90099     BCLR 0x99, #0
195:                   TMR2_InterruptHandler = InterruptHandler; 
00264A  78009E     MOV [W14], W1
00264C  884681     MOV W1, TMR2_InterruptHandler
196:                   IEC0bits.T3IE = true;
00264E  A80099     BSET 0x99, #0
197:               }
002650  FA8000     ULNK
002652  060000     RETURN
198:               
199:               void TMR2_Start( void )
200:               {
002654  FA0000     LNK #0x0
201:                   /* Reset the status information */
202:                   tmr2_obj.timerElapsed = false;
002656  20D180     MOV #0xD18, W0
002658  EB4080     CLR.B W1
00265A  784801     MOV.B W1, [W0]
203:               
204:                   /*Enable the interrupt*/
205:                   IEC0bits.T3IE = true;
00265C  A80099     BSET 0x99, #0
206:               
207:                   /* Start the Timer */
208:                   T2CONbits.TON = 1;
00265E  A8E1A1     BSET 0x1A1, #7
209:               }
002660  FA8000     ULNK
002662  060000     RETURN
210:               
211:               void TMR2_Stop( void )
212:               {
002664  FA0000     LNK #0x0
213:                   /* Stop the Timer */
214:                   T2CONbits.TON = false;
002666  A9E1A1     BCLR 0x1A1, #7
215:               
216:                   /*Disable the interrupt*/
217:                   IEC0bits.T3IE = false;
002668  A90099     BCLR 0x99, #0
218:               }
00266A  FA8000     ULNK
00266C  060000     RETURN
219:               
220:               bool TMR2_GetElapsedThenClear(void)
221:               {
00266E  FA0002     LNK #0x2
222:                   bool status;
223:                   
224:                   status = tmr2_obj.timerElapsed;
002670  20D180     MOV #0xD18, W0
002672  784F10     MOV.B [W0], [W14]
225:               
226:                   if(status == true)
002674  78401E     MOV.B [W14], W0
002676  E00400     CP0.B W0
002678  320003     BRA Z, .L15
227:                   {
228:                       tmr2_obj.timerElapsed = false;
00267A  20D180     MOV #0xD18, W0
00267C  EB4080     CLR.B W1
00267E  784801     MOV.B W1, [W0]
229:                   }
230:                   return status;
002680  78401E     MOV.B [W14], W0
231:               }
002682  FA8000     ULNK
002684  060000     RETURN
232:               
233:               int TMR2_SoftwareCounterGet(void)
234:               {
002686  FA0000     LNK #0x0
235:                   return tmr2_obj.count;
002688  20D190     MOV #0xD19, W0
00268A  784010     MOV.B [W0], W0
00268C  FB8000     ZE W0, W0
236:               }
00268E  FA8000     ULNK
002690  060000     RETURN
237:               
238:               void TMR2_SoftwareCounterClear(void)
239:               {
002692  FA0000     LNK #0x0
240:                   tmr2_obj.count = 0; 
002694  20D190     MOV #0xD19, W0
002696  EB4080     CLR.B W1
002698  784801     MOV.B W1, [W0]
241:               }
00269A  FA8000     ULNK
00269C  060000     RETURN
242:               
243:               /**
244:                End of File
245:               */
---  E:/Users/Alex/Documents/eagle/projects/USBPD Supply/adapter/USBPD-Adapter.X/mcc_generated_files/system.c
1:                 /**
2:                   @Generated PIC24 / dsPIC33 / PIC32MM MCUs Source File
3:                 
4:                   @Company:
5:                     Microchip Technology Inc.
6:                 
7:                   @File Name:
8:                     system.h
9:                 
10:                  @Summary:
11:                    This is the sysetm.h file generated using PIC24 / dsPIC33 / PIC32MM MCUs
12:                
13:                  @Description:
14:                    This header file provides implementations for driver APIs for all modules selected in the GUI.
15:                    Generation Information :
16:                        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - 1.171.1
17:                        Device            :  PIC24FJ128GA702
18:                    The generated drivers are tested against the following:
19:                        Compiler          :  XC16 v1.70
20:                        MPLAB             :  MPLAB X v5.50
21:                */
22:                
23:                /*
24:                    (c) 2020 Microchip Technology Inc. and its subsidiaries. You may use this
25:                    software and any derivatives exclusively with Microchip products.
26:                
27:                    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:                    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:                    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:                    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
31:                    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
32:                
33:                    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:                    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:                    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:                    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:                    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:                
41:                    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
42:                    TERMS.
43:                */
44:                
45:                // Configuration bits: selected in the GUI
46:                
47:                // FSEC
48:                #pragma config BWRP = OFF    //Boot Segment Write-Protect bit->Boot Segment may be written
49:                #pragma config BSS = DISABLED    //Boot Segment Code-Protect Level bits->No Protection (other than BWRP)
50:                #pragma config BSEN = OFF    //Boot Segment Control bit->No Boot Segment
51:                #pragma config GWRP = OFF    //General Segment Write-Protect bit->General Segment may be written
52:                #pragma config GSS = DISABLED    //General Segment Code-Protect Level bits->No Protection (other than GWRP)
53:                #pragma config CWRP = OFF    //Configuration Segment Write-Protect bit->Configuration Segment may be written
54:                #pragma config CSS = DISABLED    //Configuration Segment Code-Protect Level bits->No Protection (other than CWRP)
55:                #pragma config AIVTDIS = OFF    //Alternate Interrupt Vector Table bit->Disabled AIVT
56:                
57:                // FBSLIM
58:                #pragma config BSLIM = 8191    //Boot Segment Flash Page Address Limit bits->8191
59:                
60:                // FOSCSEL
61:                #pragma config FNOSC = FRC    //Oscillator Source Selection->FRC
62:                #pragma config PLLMODE = PLL96DIV2    //PLL Mode Selection->96 MHz PLL. Oscillator input is divided by 2 (8 MHz input)
63:                #pragma config IESO = OFF    //Two-speed Oscillator Start-up Enable bit->Start up with user-selected oscillator source
64:                
65:                // FOSC
66:                #pragma config POSCMD = NONE    //Primary Oscillator Mode Select bits->Primary Oscillator disabled
67:                #pragma config OSCIOFCN = ON    //OSC2 Pin Function bit->OSC2 is general purpose digital I/O pin
68:                #pragma config SOSCSEL = OFF    //SOSC Power Selection Configuration bits->Digital (SCLKI) mode
69:                #pragma config PLLSS = PLL_FRC    //PLL Secondary Selection Configuration bit->PLL is fed by the on-chip Fast RC (FRC) oscillator
70:                #pragma config IOL1WAY = ON    //Peripheral pin select configuration bit->Allow only one reconfiguration
71:                #pragma config FCKSM = CSECMD    //Clock Switching Mode bits->Clock switching is enabled,Fail-safe Clock Monitor is disabled
72:                
73:                // FWDT
74:                #pragma config WDTPS = PS32768    //Watchdog Timer Postscaler bits->1:32768
75:                #pragma config FWPSA = PR128    //Watchdog Timer Prescaler bit->1:128
76:                #pragma config FWDTEN = OFF    //Watchdog Timer Enable bits->WDT and SWDTEN disabled
77:                #pragma config WINDIS = OFF    //Watchdog Timer Window Enable bit->Watchdog Timer in Non-Window mode
78:                #pragma config WDTWIN = WIN25    //Watchdog Timer Window Select bits->WDT Window is 25% of WDT period
79:                #pragma config WDTCMX = WDTCLK    //WDT MUX Source Select bits->WDT clock source is determined by the WDTCLK Configuration bits
80:                #pragma config WDTCLK = LPRC    //WDT Clock Source Select bits->WDT uses LPRC
81:                
82:                // FPOR
83:                #pragma config BOREN = ON    //Brown Out Enable bit->Brown Out Enable Bit
84:                #pragma config LPCFG = OFF    //Low power regulator control->No Retention Sleep
85:                #pragma config DNVPEN = ENABLE    //Downside Voltage Protection Enable bit->Downside protection enabled using ZPBOR when BOR is inactive
86:                
87:                // FICD
88:                #pragma config ICS = PGD1    //ICD Communication Channel Select bits->Communicate on PGEC1 and PGED1
89:                #pragma config JTAGEN = OFF    //JTAG Enable bit->JTAG is disabled
90:                
91:                // FDEVOPT1
92:                #pragma config ALTCMPI = DISABLE    //Alternate Comparator Input Enable bit->C1INC, C2INC, and C3INC are on their standard pin locations
93:                #pragma config TMPRPIN = OFF    //Tamper Pin Enable bit->TMPRN pin function is disabled
94:                #pragma config SOSCHP = ON    //SOSC High Power Enable bit (valid only when SOSCSEL = 1->Enable SOSC high power mode (default)
95:                #pragma config ALTI2C1 = ALTI2CDIS    //Alternate I2C pin Location->ASDA1 and ASCL1 on RB5 and RB6
96:                
97:                #include "pin_manager.h"
98:                #include "clock.h"
99:                #include "system.h"
100:               #include "i2c2.h"
101:               #include "delay.h"
102:               #include "interrupt_manager.h"
103:               #include "traps.h"
104:               #include "tmr2.h"
105:               #include "i2c1.h"
106:               
107:               void SYSTEM_Initialize(void)
108:               {
0029B4  FA0000     LNK #0x0
109:                   PIN_MANAGER_Initialize();
0029B6  07FE73     RCALL PIN_MANAGER_Initialize
110:                   CLOCK_Initialize();
0029B8  07FF3A     RCALL CLOCK_Initialize
111:                   INTERRUPT_Initialize();
0029BA  07FFBB     RCALL INTERRUPT_Initialize
112:                   I2C1_Initialize();
0029BC  07FBC0     RCALL I2C1_Initialize
113:                   I2C2_Initialize();
0029BE  07FA9F     RCALL I2C2_Initialize
114:                   TMR2_Initialize();
0029C0  07FDEF     RCALL TMR2_Initialize
115:               }
0029C2  FA8000     ULNK
0029C4  060000     RETURN
116:               
117:               /**
118:                End of File
119:               */
---  E:/Users/Alex/Documents/eagle/projects/USBPD Supply/adapter/USBPD-Adapter.X/mcc_generated_files/pin_manager.c
1:                 /**
2:                   PIN MANAGER Generated Driver File
3:                 
4:                   @Company:
5:                     Microchip Technology Inc.
6:                 
7:                   @File Name:
8:                     pin_manager.c
9:                 
10:                  @Summary:
11:                    This is the generated manager file for the PIC24 / dsPIC33 / PIC32MM MCUs device.  This manager
12:                    configures the pins direction, initial state, analog setting.
13:                    The peripheral pin select, PPS, configuration is also handled by this manager.
14:                
15:                  @Description:
16:                    This source file provides implementations for PIN MANAGER.
17:                    Generation Information :
18:                        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - 1.171.1
19:                        Device            :  PIC24FJ128GA702
20:                    The generated drivers are tested against the following:
21:                        Compiler          :  XC16 v1.70
22:                        MPLAB 	          :  MPLAB X v5.50
23:                */
24:                
25:                /*
26:                    (c) 2020 Microchip Technology Inc. and its subsidiaries. You may use this
27:                    software and any derivatives exclusively with Microchip products.
28:                
29:                    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
30:                    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
31:                    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
32:                    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
33:                    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
34:                
35:                    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
36:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
37:                    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
38:                    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
39:                    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
40:                    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
41:                    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
42:                
43:                    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
44:                    TERMS.
45:                */
46:                
47:                
48:                /**
49:                    Section: Includes
50:                */
51:                
52:                #include <xc.h>
53:                #include <stdio.h>
54:                #include "pin_manager.h"
55:                
56:                /**
57:                 Section: File specific functions
58:                */
59:                void (*ENC_SW_InterruptHandler)(void) = NULL;
60:                void (*USB_INT_InterruptHandler)(void) = NULL;
61:                void (*ENC_A_InterruptHandler)(void) = NULL;
62:                
63:                /**
64:                 Section: Driver Interface Function Definitions
65:                */
66:                void PIN_MANAGER_Initialize (void)
67:                {
00269E  FA0000     LNK #0x0
68:                    /****************************************************************************
69:                     * Setting the Output Latch SFR(s)
70:                     ***************************************************************************/
71:                    LATA = 0x0000;
0026A0  EF2666     CLR LATA
72:                    LATB = 0x0000;
0026A2  EF267A     CLR LATB
73:                
74:                    /****************************************************************************
75:                     * Setting the GPIO Direction SFR(s)
76:                     ***************************************************************************/
77:                    TRISA = 0x0017;
0026A4  200170     MOV #0x17, W0
0026A6  883310     MOV W0, TRISA
78:                    TRISB = 0xFFFF;
0026A8  EB8000     SETM W0
0026AA  8833B0     MOV W0, TRISB
79:                
80:                    /****************************************************************************
81:                     * Setting the Weak Pull Up and Weak Pull Down SFR(s)
82:                     ***************************************************************************/
83:                    IOCPDA = 0x0000;
0026AC  EF2674     CLR IOCPDA
84:                    IOCPDB = 0x0000;
0026AE  EF2688     CLR IOCPDB
85:                    IOCPUA = 0x0001;
0026B0  200010     MOV #0x1, W0
0026B2  883390     MOV W0, IOCPUA
86:                    IOCPUB = 0xC000;
0026B4  2C0000     MOV #0xC000, W0
0026B6  883430     MOV W0, IOCPUB
87:                
88:                    /****************************************************************************
89:                     * Setting the Open Drain SFR(s)
90:                     ***************************************************************************/
91:                    ODCA = 0x0000;
0026B8  EF2668     CLR ODCA
92:                    ODCB = 0x006C;
0026BA  2006C0     MOV #0x6C, W0
0026BC  8833E0     MOV W0, ODCB
93:                
94:                    /****************************************************************************
95:                     * Setting the Analog/Digital Configuration SFR(s)
96:                     ***************************************************************************/
97:                    ANSA = 0x0006;
0026BE  200060     MOV #0x6, W0
0026C0  883350     MOV W0, ANSA
98:                    ANSB = 0x3200;
0026C2  232000     MOV #0x3200, W0
0026C4  8833F0     MOV W0, ANSB
99:                    
100:                   /****************************************************************************
101:                    * Interrupt On Change: any
102:                    ***************************************************************************/
103:                   IOCNAbits.IOCNA0 = 1;    //Pin : RA0
0026C6  A8066E     BSET IOCNA, #0
104:                   IOCPAbits.IOCPA0 = 1;    //Pin : RA0
0026C8  A8066C     BSET IOCPA, #0
105:                   /****************************************************************************
106:                    * Interrupt On Change: positive
107:                    ***************************************************************************/
108:                   IOCPBbits.IOCPB15 = 1;    //Pin : RB15
0026CA  A8E681     BSET 0x681, #7
109:                   IOCPBbits.IOCPB7 = 1;    //Pin : RB7
0026CC  A8E680     BSET IOCPB, #7
110:                   /****************************************************************************
111:                    * Interrupt On Change: flag
112:                    ***************************************************************************/
113:                   IOCFAbits.IOCFA0 = 0;    //Pin : RA0
0026CE  A90670     BCLR IOCFA, #0
114:                   IOCFBbits.IOCFB15 = 0;    //Pin : RB15
0026D0  A9E685     BCLR 0x685, #7
115:                   IOCFBbits.IOCFB7 = 0;    //Pin : RB7
0026D2  A9E684     BCLR IOCFB, #7
116:                   /****************************************************************************
117:                    * Interrupt On Change: config
118:                    ***************************************************************************/
119:                   PADCONbits.IOCON = 1;    //Config for PORTB
0026D4  A8E65F     BSET 0x65F, #7
120:                   
121:                   /* Initialize IOC Interrupt Handler*/
122:                   ENC_SW_SetInterruptHandler(&ENC_SW_CallBack);
0026D6  226EA0     MOV #0x26EA, W0
0026D8  070011     RCALL ENC_SW_SetInterruptHandler
123:                   USB_INT_SetInterruptHandler(&USB_INT_CallBack);
0026DA  226F00     MOV #0x26F0, W0
0026DC  07001D     RCALL USB_INT_SetInterruptHandler
124:                   ENC_A_SetInterruptHandler(&ENC_A_CallBack);
0026DE  226F60     MOV #0x26F6, W0
0026E0  070029     RCALL ENC_A_SetInterruptHandler
125:                   
126:                   /****************************************************************************
127:                    * Interrupt On Change: Interrupt Enable
128:                    ***************************************************************************/
129:                   IFS1bits.IOCIF = 0; //Clear IOCI interrupt flag
0026E2  A9608A     BCLR IFS1, #3
130:                   IEC1bits.IOCIE = 1; //Enable IOCI interrupt
0026E4  A8609A     BSET IEC1, #3
131:               }
0026E6  FA8000     ULNK
0026E8  060000     RETURN
132:               
133:               void __attribute__ ((weak)) ENC_SW_CallBack(void)
134:               {
0026EA  FA0000     LNK #0x0
135:               
136:               }
0026EC  FA8000     ULNK
0026EE  060000     RETURN
137:               
138:               void __attribute__ ((weak)) USB_INT_CallBack(void)
139:               {
0026F0  FA0000     LNK #0x0
140:               
141:               }
0026F2  FA8000     ULNK
0026F4  060000     RETURN
142:               
143:               void __attribute__ ((weak)) ENC_A_CallBack(void)
144:               {
0026F6  FA0000     LNK #0x0
145:               
146:               }
0026F8  FA8000     ULNK
0026FA  060000     RETURN
147:               
148:               void ENC_SW_SetInterruptHandler(void (* InterruptHandler)(void))
149:               { 
0026FC  FA0002     LNK #0x2
0026FE  780F00     MOV W0, [W14]
150:                   IEC1bits.IOCIE = 0; //Disable IOCI interrupt
002700  A9609A     BCLR IEC1, #3
151:                   ENC_SW_InterruptHandler = InterruptHandler; 
002702  78009E     MOV [W14], W1
002704  884651     MOV W1, ENC_SW_InterruptHandler
152:                   IEC1bits.IOCIE = 1; //Enable IOCI interrupt
002706  A8609A     BSET IEC1, #3
153:               }
002708  FA8000     ULNK
00270A  060000     RETURN
154:               
155:               void ENC_SW_SetIOCInterruptHandler(void *handler)
156:               { 
00270C  FA0002     LNK #0x2
00270E  780F00     MOV W0, [W14]
157:                   ENC_SW_SetInterruptHandler(handler);
002710  78001E     MOV [W14], W0
002712  07FFF4     RCALL ENC_SW_SetInterruptHandler
158:               }
002714  FA8000     ULNK
002716  060000     RETURN
159:               
160:               void USB_INT_SetInterruptHandler(void (* InterruptHandler)(void))
161:               { 
002718  FA0002     LNK #0x2
00271A  780F00     MOV W0, [W14]
162:                   IEC1bits.IOCIE = 0; //Disable IOCI interrupt
00271C  A9609A     BCLR IEC1, #3
163:                   USB_INT_InterruptHandler = InterruptHandler; 
00271E  78009E     MOV [W14], W1
002720  884661     MOV W1, USB_INT_InterruptHandler
164:                   IEC1bits.IOCIE = 1; //Enable IOCI interrupt
002722  A8609A     BSET IEC1, #3
165:               }
002724  FA8000     ULNK
002726  060000     RETURN
166:               
167:               void USB_INT_SetIOCInterruptHandler(void *handler)
168:               { 
002728  FA0002     LNK #0x2
00272A  780F00     MOV W0, [W14]
169:                   USB_INT_SetInterruptHandler(handler);
00272C  78001E     MOV [W14], W0
00272E  07FFF4     RCALL USB_INT_SetInterruptHandler
170:               }
002730  FA8000     ULNK
002732  060000     RETURN
171:               
172:               void ENC_A_SetInterruptHandler(void (* InterruptHandler)(void))
173:               { 
002734  FA0002     LNK #0x2
002736  780F00     MOV W0, [W14]
174:                   IEC1bits.IOCIE = 0; //Disable IOCI interrupt
002738  A9609A     BCLR IEC1, #3
175:                   ENC_A_InterruptHandler = InterruptHandler; 
00273A  78009E     MOV [W14], W1
00273C  884671     MOV W1, ENC_A_InterruptHandler
176:                   IEC1bits.IOCIE = 1; //Enable IOCI interrupt
00273E  A8609A     BSET IEC1, #3
177:               }
002740  FA8000     ULNK
002742  060000     RETURN
178:               
179:               void ENC_A_SetIOCInterruptHandler(void *handler)
180:               { 
002744  FA0002     LNK #0x2
002746  780F00     MOV W0, [W14]
181:                   ENC_A_SetInterruptHandler(handler);
002748  78001E     MOV [W14], W0
00274A  07FFF4     RCALL ENC_A_SetInterruptHandler
182:               }
00274C  FA8000     ULNK
00274E  060000     RETURN
183:               
184:               /* Interrupt service routine for the IOCI interrupt. */
185:               void __attribute__ (( interrupt, no_auto_psv )) _IOCInterrupt ( void )
186:               {
0002EE  F80036     PUSH RCOUNT
0002F0  BE9F80     MOV.D W0, [W15++]
0002F2  BE9F82     MOV.D W2, [W15++]
0002F4  BE9F84     MOV.D W4, [W15++]
0002F6  BE9F86     MOV.D W6, [W15++]
0002F8  FA0000     LNK #0x0
187:                   if(IFS1bits.IOCIF == 1)
0002FA  800450     MOV IFS1, W0
0002FC  600068     AND W0, #0x8, W0
0002FE  E00000     CP0 W0
000300  320021     BRA Z, .L11
188:                   {
189:                       if(IOCFAbits.IOCFA0 == 1)
000302  803380     MOV IOCFA, W0
000304  600061     AND W0, #0x1, W0
000306  E00000     CP0 W0
000308  320006     BRA Z, .L13
190:                       {
191:                           if(ENC_SW_InterruptHandler) 
00030A  804650     MOV ENC_SW_InterruptHandler, W0
00030C  E00000     CP0 W0
00030E  320002     BRA Z, .L14
192:                           { 
193:                               ENC_SW_InterruptHandler(); 
000310  804650     MOV ENC_SW_InterruptHandler, W0
000312  010000     CALL W0
194:                           }
195:                           
196:                           IOCFAbits.IOCFA0 = 0;  //Clear flag for Pin - RA0
000314  A90670     BCLR IOCFA, #0
197:               
198:                       }
199:                       
200:                       if(IOCFBbits.IOCFB7 == 1)
000316  803421     MOV IOCFB, W1
000318  200800     MOV #0x80, W0
00031A  608000     AND W1, W0, W0
00031C  E00000     CP0 W0
00031E  320006     BRA Z, .L15
201:                       {
202:                           if(USB_INT_InterruptHandler) 
000320  804660     MOV USB_INT_InterruptHandler, W0
000322  E00000     CP0 W0
000324  320002     BRA Z, .L16
203:                           { 
204:                               USB_INT_InterruptHandler(); 
000326  804660     MOV USB_INT_InterruptHandler, W0
000328  010000     CALL W0
205:                           }
206:                           
207:                           IOCFBbits.IOCFB7 = 0;  //Clear flag for Pin - RB7
00032A  A9E684     BCLR IOCFB, #7
208:               
209:                       }
210:                       
211:                       if(IOCFBbits.IOCFB15 == 1)
00032C  803421     MOV IOCFB, W1
00032E  280000     MOV #0x8000, W0
000330  608000     AND W1, W0, W0
000332  E00000     CP0 W0
000334  320006     BRA Z, .L17
212:                       {
213:                           if(ENC_A_InterruptHandler) 
000336  804670     MOV ENC_A_InterruptHandler, W0
000338  E00000     CP0 W0
00033A  320002     BRA Z, .L18
214:                           { 
215:                               ENC_A_InterruptHandler(); 
00033C  804670     MOV ENC_A_InterruptHandler, W0
00033E  010000     CALL W0
216:                           }
217:                           
218:                           IOCFBbits.IOCFB15 = 0;  //Clear flag for Pin - RB15
000340  A9E685     BCLR 0x685, #7
219:               
220:                       }
221:                       
222:                       
223:                       // Clear the flag
224:                       IFS1bits.IOCIF = 0;
000342  A9608A     BCLR IFS1, #3
225:                   }
226:               }
000344  FA8000     ULNK
000346  BE034F     MOV.D [--W15], W6
000348  BE024F     MOV.D [--W15], W4
00034A  BE014F     MOV.D [--W15], W2
00034C  BE004F     MOV.D [--W15], W0
00034E  F90036     POP RCOUNT
000350  064000     RETFIE
227:               
---  E:/Users/Alex/Documents/eagle/projects/USBPD Supply/adapter/USBPD-Adapter.X/mcc_generated_files/interrupt_manager.c
1:                 /**
2:                   System Interrupts Generated Driver File 
3:                 
4:                   @Company:
5:                     Microchip Technology Inc.
6:                 
7:                   @File Name:
8:                     interrupt_manager.h
9:                 
10:                  @Summary:
11:                    This is the generated driver implementation file for setting up the
12:                    interrupts using PIC24 / dsPIC33 / PIC32MM MCUs
13:                
14:                  @Description:
15:                    This source file provides implementations for PIC24 / dsPIC33 / PIC32MM MCUs interrupts.
16:                    Generation Information : 
17:                        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - 1.171.1
18:                        Device            :  PIC24FJ128GA702
19:                    The generated drivers are tested against the following:
20:                        Compiler          :  XC16 v1.70
21:                        MPLAB             :  MPLAB X v5.50
22:                */
23:                /*
24:                    (c) 2020 Microchip Technology Inc. and its subsidiaries. You may use this
25:                    software and any derivatives exclusively with Microchip products.
26:                
27:                    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:                    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:                    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:                    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
31:                    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
32:                
33:                    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:                    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:                    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:                    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:                    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:                
41:                    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
42:                    TERMS.
43:                */
44:                
45:                /**
46:                    Section: Includes
47:                */
48:                #include <xc.h>
49:                
50:                /**
51:                    void INTERRUPT_Initialize (void)
52:                */
53:                void INTERRUPT_Initialize (void)
54:                {
002932  FA0000     LNK #0x0
55:                    //    MICI: MI2C1 - I2C1 Master Events
56:                    //    Priority: 1
57:                        IPC4bits.MI2C1IP = 1;
002934  800581     MOV IPC4, W1
002936  2FF8F0     MOV #0xFF8F, W0
002938  608000     AND W1, W0, W0
00293A  A04000     BSET W0, #4
00293C  880580     MOV W0, IPC4
58:                    //    SICI: SI2C1 - I2C1 Slave Events
59:                    //    Priority: 1
60:                        IPC4bits.SI2C1IP = 1;
00293E  800581     MOV IPC4, W1
002940  2FFF80     MOV #0xFFF8, W0
002942  608000     AND W1, W0, W0
002944  A00000     BSET W0, #0
002946  880580     MOV W0, IPC4
61:                    //    IOCI: IOC -  Interrupt On Change Interrupt
62:                    //    Priority: 1
63:                        IPC4bits.IOCIP = 1;
002948  800581     MOV IPC4, W1
00294A  28FFF0     MOV #0x8FFF, W0
00294C  608000     AND W1, W0, W0
00294E  A0C000     BSET W0, #12
002950  880580     MOV W0, IPC4
64:                    //    MICI: MI2C2 - I2C2 Master Events
65:                    //    Priority: 1
66:                        IPC12bits.MI2C2IP = 1;
002952  800601     MOV IPC12, W1
002954  2F8FF0     MOV #0xF8FF, W0
002956  608000     AND W1, W0, W0
002958  A08000     BSET W0, #8
00295A  880600     MOV W0, IPC12
67:                    //    SICI: SI2C2 - I2C2 Slave Events
68:                    //    Priority: 1
69:                        IPC12bits.SI2C2IP = 1;
00295C  800601     MOV IPC12, W1
00295E  2FF8F0     MOV #0xFF8F, W0
002960  608000     AND W1, W0, W0
002962  A04000     BSET W0, #4
002964  880600     MOV W0, IPC12
70:                    //    TI: T2 - Timer2
71:                    //    Priority: 1
72:                        IPC1bits.T2IP = 1;
002966  800551     MOV IPC1, W1
002968  28FFF0     MOV #0x8FFF, W0
00296A  608000     AND W1, W0, W0
00296C  A0C000     BSET W0, #12
00296E  880550     MOV W0, IPC1
73:                    //    TNI: T3 - Timer3
74:                    //    Priority: 1
75:                        IPC2bits.T3IP = 1;
002970  800561     MOV IPC2, W1
002972  2FFF80     MOV #0xFFF8, W0
002974  608000     AND W1, W0, W0
002976  A00000     BSET W0, #0
002978  880560     MOV W0, IPC2
76:                
77:                }
00297A  FA8000     ULNK
00297C  060000     RETURN
---  E:/Users/Alex/Documents/eagle/projects/USBPD Supply/adapter/USBPD-Adapter.X/mcc_generated_files/i2c2.c
1:                 
2:                 /**
3:                   I2C2 Generated Driver File
4:                 
5:                   @Company
6:                     Microchip Technology Inc.
7:                 
8:                   @File Name
9:                     i2c2.c
10:                
11:                  @Summary
12:                    This is the generated header file for the i2c2 driver using PIC24 / dsPIC33 / PIC32MM MCUs
13:                
14:                  @Description
15:                    This header file provides APIs for driver for i2c2.
16:                    Generation Information :
17:                        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - 1.171.1
18:                        Device            :  PIC24FJ128GA702
19:                
20:                    The generated drivers are tested against the following:
21:                        Compiler          :  XC16 v1.70
22:                        MPLAB             :  MPLAB X v5.50
23:                */
24:                
25:                /*
26:                    (c) 2020 Microchip Technology Inc. and its subsidiaries. You may use this
27:                    software and any derivatives exclusively with Microchip products.
28:                
29:                    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
30:                    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
31:                    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
32:                    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
33:                    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
34:                
35:                    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
36:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
37:                    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
38:                    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
39:                    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
40:                    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
41:                    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
42:                
43:                    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
44:                    TERMS.
45:                */
46:                
47:                #include "i2c2.h"
48:                
49:                /**
50:                 Section: Data Types
51:                */
52:                
53:                /**
54:                  I2C Driver Queue Status Type
55:                
56:                  @Summary
57:                    Defines the type used for the transaction queue status.
58:                
59:                  @Description
60:                    This defines type used to keep track of the queue status.
61:                 */
62:                
63:                typedef union
64:                {
65:                    struct
66:                    {
67:                            uint8_t full:1;
68:                            uint8_t empty:1;
69:                            uint8_t reserved:6;
70:                    }s;
71:                    uint8_t status;
72:                } I2C_TR_QUEUE_STATUS;
73:                
74:                /**
75:                  I2C Driver Queue Entry Type
76:                
77:                  @Summary
78:                    Defines the object used for an entry in the i2c queue items.
79:                
80:                  @Description
81:                    This defines the object in the i2c queue. Each entry is a composed
82:                    of a list of TRBs, the number of the TRBs and the status of the
83:                    currently processed TRB.
84:                 */
85:                typedef struct
86:                {
87:                    uint8_t                         count;          // a count of trb's in the trb list
88:                    I2C2_TRANSACTION_REQUEST_BLOCK  *ptrb_list;     // pointer to the trb list
89:                    I2C2_MESSAGE_STATUS             *pTrFlag;       // set with the error of the last trb sent.
90:                                                                    // if all trb's are sent successfully,
91:                                                                    // then this is I2C2_MESSAGE_COMPLETE
92:                } I2C_TR_QUEUE_ENTRY;
93:                
94:                /**
95:                  I2C Master Driver Object Type
96:                
97:                  @Summary
98:                    Defines the object that manages the i2c master.
99:                
100:                 @Description
101:                   This defines the object that manages the sending and receiving of
102:                   i2c master transactions.
103:                 */
104:               
105:               typedef struct
106:               {
107:                   /* Read/Write Queue */
108:                   I2C_TR_QUEUE_ENTRY          *pTrTail;       // tail of the queue
109:                   I2C_TR_QUEUE_ENTRY          *pTrHead;       // head of the queue
110:                   I2C_TR_QUEUE_STATUS         trStatus;       // status of the last transaction
111:                   uint8_t                     i2cDoneFlag;    // flag to indicate the current
112:                                                               // transaction is done
113:                   uint8_t                     i2cErrors;      // keeps track of errors
114:               
115:               
116:               } I2C_OBJECT ;
117:               
118:               /**
119:                 I2C Master Driver State Enumeration
120:               
121:                 @Summary
122:                   Defines the different states of the i2c master.
123:               
124:                 @Description
125:                   This defines the different states that the i2c master
126:                   used to process transactions on the i2c bus.
127:               */
128:               
129:               typedef enum
130:               {
131:                   S_MASTER_IDLE,
132:                   S_MASTER_RESTART,
133:                   S_MASTER_SEND_ADDR,
134:                   S_MASTER_SEND_DATA,
135:                   S_MASTER_SEND_STOP,
136:                   S_MASTER_ACK_ADDR,
137:                   S_MASTER_RCV_DATA,
138:                   S_MASTER_RCV_STOP,
139:                   S_MASTER_ACK_RCV_DATA,
140:                   S_MASTER_NOACK_STOP,
141:                   S_MASTER_SEND_ADDR_10BIT_LSB,
142:                   S_MASTER_10BIT_RESTART,
143:                   
144:               } I2C_MASTER_STATES;
145:               
146:               /**
147:                Section: Macro Definitions
148:               */
149:               
150:               /* defined for I2C2 */
151:               
152:               
153:               #ifndef I2C2_CONFIG_TR_QUEUE_LENGTH
154:                       #define I2C2_CONFIG_TR_QUEUE_LENGTH 1
155:               #endif
156:               
157:               #define I2C2_TRANSMIT_REG                       I2C2TRN			// Defines the transmit register used to send data.
158:               #define I2C2_RECEIVE_REG                        I2C2RCV	// Defines the receive register used to receive data.
159:               
160:               // The following control bits are used in the I2C state machine to manage
161:               // the I2C module and determine next states.
162:               #define I2C2_WRITE_COLLISION_STATUS_BIT         I2C2STATbits.IWCOL	// Defines the write collision status bit.
163:               #define I2C2_ACKNOWLEDGE_STATUS_BIT             I2C2STATbits.ACKSTAT	// I2C ACK status bit.
164:               
165:               #define I2C2_START_CONDITION_ENABLE_BIT         I2C2CONLbits.SEN		// I2C START control bit.
166:               #define I2C2_REPEAT_START_CONDITION_ENABLE_BIT  I2C2CONLbits.RSEN	// I2C Repeated START control bit.
167:               #define I2C2_RECEIVE_ENABLE_BIT                 I2C2CONLbits.RCEN	// I2C Receive enable control bit.
168:               #define I2C2_STOP_CONDITION_ENABLE_BIT          I2C2CONLbits.PEN		// I2C STOP control bit.
169:               #define I2C2_ACKNOWLEDGE_ENABLE_BIT             I2C2CONLbits.ACKEN 	// I2C ACK start control bit.
170:               #define I2C2_ACKNOWLEDGE_DATA_BIT               I2C2CONLbits.ACKDT	// I2C ACK data control bit.
171:               
172:               /**
173:                Section: Local Functions
174:               */
175:               
176:               static void I2C2_FunctionComplete(void);
177:               static void I2C2_Stop(I2C2_MESSAGE_STATUS completion_code);
178:               
179:               /**
180:                Section: Local Variables
181:               */
182:               
183:               static I2C_TR_QUEUE_ENTRY            i2c2_tr_queue[I2C2_CONFIG_TR_QUEUE_LENGTH];
184:               static I2C_OBJECT                    i2c2_object;
185:               static I2C_MASTER_STATES             i2c2_state = S_MASTER_IDLE;
186:               static uint8_t                       i2c2_trb_count;
187:               
188:               static I2C2_TRANSACTION_REQUEST_BLOCK *p_i2c2_trb_current;
189:               static I2C_TR_QUEUE_ENTRY            *p_i2c2_current = NULL;
190:               
191:               
192:               /**
193:                 Section: Driver Interface
194:               */
195:               
196:               void I2C2_Initialize(void)
197:               {
001EFE  FA0000     LNK #0x0
198:                   
199:                   i2c2_object.pTrHead = i2c2_tr_queue;
001F00  208820     MOV #0x882, W0
001F02  20CF41     MOV #0xCF4, W1
001F04  E88000     INC2 W0, W0
001F06  780801     MOV W1, [W0]
200:                   i2c2_object.pTrTail = i2c2_tr_queue;
001F08  208820     MOV #0x882, W0
001F0A  20CF41     MOV #0xCF4, W1
001F0C  780801     MOV W1, [W0]
201:                   i2c2_object.trStatus.s.empty = true;
001F0E  208820     MOV #0x882, W0
001F10  4000E4     ADD W0, #0x4, W1
001F12  780091     MOV [W1], W1
001F14  A01001     BSET W1, #1
001F16  400064     ADD W0, #0x4, W0
001F18  780801     MOV W1, [W0]
202:                   i2c2_object.trStatus.s.full = false;
001F1A  208820     MOV #0x882, W0
001F1C  4000E4     ADD W0, #0x4, W1
001F1E  780091     MOV [W1], W1
001F20  A10001     BCLR W1, #0
001F22  400064     ADD W0, #0x4, W0
001F24  780801     MOV W1, [W0]
203:               
204:                   i2c2_object.i2cErrors = 0;
001F26  208820     MOV #0x882, W0
001F28  EB4080     CLR.B W1
001F2A  400066     ADD W0, #0x6, W0
001F2C  784801     MOV.B W1, [W0]
205:                   
206:                   // initialize the hardware
207:                   // Baud Rate Generator Value: I2CBRG 78;   
208:                   I2C2BRG = 0x4E;
001F2E  2004E0     MOV #0x4E, W0
001F30  882540     MOV W0, I2C2BRG
209:                   // ACKEN disabled; STRICT disabled; STREN disabled; GCEN disabled; SMEN disabled; DISSLW enabled; I2CSIDL disabled; ACKDT Sends ACK; SCLREL Holds; RSEN disabled; A10M 7 Bit; PEN disabled; RCEN disabled; SEN disabled; I2CEN enabled; 
210:                   I2C2CONL = 0x8000;
001F32  280000     MOV #0x8000, W0
001F34  882550     MOV W0, I2C2CONL
211:                   // BCL disabled; D_nA disabled; R_nW disabled; P disabled; S disabled; I2COV disabled; IWCOL disabled; 
212:                   I2C2STAT = 0x00;
001F36  EF24AE     CLR I2C2STAT
213:               
214:                   /* MI2C2 - I2C2 Master Events */
215:                   // clear the master interrupt flag
216:                   IFS3bits.MI2C2IF = 0;
001F38  A9408E     BCLR IFS3, #2
217:                   // enable the master interrupt
218:                   IEC3bits.MI2C2IE = 1;
001F3A  A8409E     BSET IEC3, #2
219:               
220:               }
001F3C  FA8000     ULNK
001F3E  060000     RETURN
221:               
222:               
223:               uint8_t I2C2_ErrorCountGet(void)
224:               {
001F40  FA0002     LNK #0x2
225:                   uint8_t ret;
226:               
227:                   ret = i2c2_object.i2cErrors;
001F42  208820     MOV #0x882, W0
001F44  400066     ADD W0, #0x6, W0
001F46  784F10     MOV.B [W0], [W14]
228:                   return ret;
001F48  78401E     MOV.B [W14], W0
229:               }
001F4A  FA8000     ULNK
001F4C  060000     RETURN
230:               
231:               void __attribute__ ( ( interrupt, no_auto_psv ) ) _MI2C2Interrupt ( void )
232:               {
000352  F80036     PUSH RCOUNT
000354  BE9F80     MOV.D W0, [W15++]
000356  BE9F82     MOV.D W2, [W15++]
000358  BE9F84     MOV.D W4, [W15++]
00035A  BE9F86     MOV.D W6, [W15++]
00035C  FA0000     LNK #0x0
233:                 
234:                   static uint8_t  *pi2c_buf_ptr;
235:                   static uint16_t i2c_address;
236:                   static uint8_t  i2c_bytes_left;
237:                   static uint8_t  i2c_10bit_address_restart = 0;
238:               
239:                   IFS3bits.MI2C2IF = 0;
00035E  A9408E     BCLR IFS3, #2
240:                           
241:                   // Check first if there was a collision.
242:                   // If we have a Write Collision, reset and go to idle state */
243:                   if(I2C2_WRITE_COLLISION_STATUS_BIT)
000360  802571     MOV I2C2STAT, W1
000362  200800     MOV #0x80, W0
000364  608000     AND W1, W0, W0
000366  E00000     CP0 W0
000368  320009     BRA Z, .L4
244:                   {
245:                       // clear the Write colision
246:                       I2C2_WRITE_COLLISION_STATUS_BIT = 0;
00036A  A9E4AE     BCLR I2C2STAT, #7
247:                       i2c2_state = S_MASTER_IDLE;
00036C  EF288A     CLR i2c2_state
248:                       *(p_i2c2_current->pTrFlag) = I2C2_MESSAGE_FAIL;
00036E  804480     MOV p_i2c2_current, W0
000370  400064     ADD W0, #0x4, W0
000372  780010     MOV [W0], W0
000374  EB0080     CLR W1
000376  780801     MOV W1, [W0]
249:               
250:                       // reset the buffer pointer
251:                       p_i2c2_current = NULL;
000378  EF2890     CLR p_i2c2_current
252:               
253:                       return;
00037A  370127     BRA .L3
254:                   }
255:               
256:                   /* Handle the correct i2c state */
257:                   switch(i2c2_state)
00037C  804450     MOV i2c2_state, W0
00037E  EB0080     CLR W1
000380  2000B2     MOV #0xB, W2
000382  200003     MOV #0x0, W3
000384  500F82     SUB W0, W2, [W15]
000386  588F83     SUBB W1, W3, [W15]
000388  3E0114     BRA GTU, .L6
00038A  016000     BRA W0
00038C  37000B     BRA .SE17, .L7
00038E  370047     BRA .L8
000390  370087     BRA .L9
000392  3700B0     BRA .L10
000394  37010B     BRA .L11
000396  3700DE     BRA .L12
000398  3700F1     BRA .L13
00039A  370108     BRA .L11
00039C  3700F3     BRA .L14
00039E  370109     BRA .L6
0003A0  370042     BRA .L15
0003A2  370060     BRA .L16
258:                   {
259:                       case S_MASTER_IDLE:    /* In reset state, waiting for data to send */
260:               
261:                           if(i2c2_object.trStatus.s.empty != true)
0003A4  208820     MOV #0x882, W0
0003A6  400064     ADD W0, #0x4, W0
0003A8  780010     MOV [W0], W0
0003AA  600062     AND W0, #0x2, W0
0003AC  E00000     CP0 W0
0003AE  3A010C     BRA NZ, .L39
262:                           {
263:                               // grab the item pointed by the head
264:                               p_i2c2_current     = i2c2_object.pTrHead;
0003B0  208820     MOV #0x882, W0
0003B2  E88000     INC2 W0, W0
0003B4  780010     MOV [W0], W0
0003B6  884480     MOV W0, p_i2c2_current
265:                               i2c2_trb_count     = i2c2_object.pTrHead->count;
0003B8  208820     MOV #0x882, W0
0003BA  E88000     INC2 W0, W0
0003BC  780010     MOV [W0], W0
0003BE  784010     MOV.B [W0], W0
0003C0  B7E88C     MOV.B WREG, i2c2_trb_count
266:                               p_i2c2_trb_current = i2c2_object.pTrHead->ptrb_list;
0003C2  208820     MOV #0x882, W0
0003C4  E88000     INC2 W0, W0
0003C6  780010     MOV [W0], W0
0003C8  E88000     INC2 W0, W0
0003CA  780010     MOV [W0], W0
0003CC  884470     MOV W0, p_i2c2_trb_current
267:               
268:                               i2c2_object.pTrHead++;
0003CE  208820     MOV #0x882, W0
0003D0  E88000     INC2 W0, W0
0003D2  780010     MOV [W0], W0
0003D4  4000E6     ADD W0, #0x6, W1
0003D6  208820     MOV #0x882, W0
0003D8  E88000     INC2 W0, W0
0003DA  780801     MOV W1, [W0]
269:               
270:                               // check if the end of the array is reached
271:                               if(i2c2_object.pTrHead == (i2c2_tr_queue + I2C2_CONFIG_TR_QUEUE_LENGTH))
0003DC  208820     MOV #0x882, W0
0003DE  E88000     INC2 W0, W0
0003E0  780090     MOV [W0], W1
0003E2  20CFA0     MOV #0xCFA, W0
0003E4  508F80     SUB W1, W0, [W15]
0003E6  3A0004     BRA NZ, .L19
272:                               {
273:                                   // adjust to restart at the beginning of the array
274:                                   i2c2_object.pTrHead = i2c2_tr_queue;
0003E8  208820     MOV #0x882, W0
0003EA  20CF41     MOV #0xCF4, W1
0003EC  E88000     INC2 W0, W0
0003EE  780801     MOV W1, [W0]
275:                               }
276:               
277:                               // since we moved one item to be processed, we know
278:                               // it is not full, so set the full status to false
279:                               i2c2_object.trStatus.s.full = false;
0003F0  208820     MOV #0x882, W0
0003F2  4000E4     ADD W0, #0x4, W1
0003F4  780091     MOV [W1], W1
0003F6  A10001     BCLR W1, #0
0003F8  400064     ADD W0, #0x4, W0
0003FA  780801     MOV W1, [W0]
280:               
281:                               // check if the queue is empty
282:                               if(i2c2_object.pTrHead == i2c2_object.pTrTail)
0003FC  208820     MOV #0x882, W0
0003FE  E88000     INC2 W0, W0
000400  780090     MOV [W0], W1
000402  208820     MOV #0x882, W0
000404  780010     MOV [W0], W0
000406  508F80     SUB W1, W0, [W15]
000408  3A0006     BRA NZ, .L20
283:                               {
284:                                   // it is empty so set the empty status to true
285:                                   i2c2_object.trStatus.s.empty = true;
00040A  208820     MOV #0x882, W0
00040C  4000E4     ADD W0, #0x4, W1
00040E  780091     MOV [W1], W1
000410  A01001     BSET W1, #1
000412  400064     ADD W0, #0x4, W0
000414  780801     MOV W1, [W0]
286:                               }
287:               
288:                               // send the start condition
289:                               I2C2_START_CONDITION_ENABLE_BIT = 1;
000416  A804AA     BSET I2C2CONL, #0
290:               
291:                               // start the i2c request
292:                               i2c2_state = S_MASTER_SEND_ADDR;
000418  200020     MOV #0x2, W0
00041A  884450     MOV W0, i2c2_state
293:                           }
294:               
295:                           break;
00041C  3700D6     BRA .L3
0005C8  000000     NOP
296:               
297:                       case S_MASTER_RESTART:
298:               
299:                           /* check for pending i2c Request */
300:               
301:                           // ... trigger a REPEATED START
302:                           I2C2_REPEAT_START_CONDITION_ENABLE_BIT = 1;
00041E  A824AA     BSET I2C2CONL, #1
303:               
304:                           // start the i2c request
305:                           i2c2_state = S_MASTER_SEND_ADDR;
000420  200020     MOV #0x2, W0
000422  884450     MOV W0, i2c2_state
306:               
307:                           break;
000424  3700D2     BRA .L3
308:               
309:                       case S_MASTER_SEND_ADDR_10BIT_LSB:
310:               
311:                           if(I2C2_ACKNOWLEDGE_STATUS_BIT)
000426  802571     MOV I2C2STAT, W1
000428  280000     MOV #0x8000, W0
00042A  608000     AND W1, W0, W0
00042C  E00000     CP0 W0
00042E  32000A     BRA Z, .L21
312:                           {
313:                               i2c2_object.i2cErrors++;
000430  208820     MOV #0x882, W0
000432  400066     ADD W0, #0x6, W0
000434  784010     MOV.B [W0], W0
000436  E84080     INC.B W0, W1
000438  208820     MOV #0x882, W0
00043A  400066     ADD W0, #0x6, W0
00043C  784801     MOV.B W1, [W0]
314:                               I2C2_Stop(I2C2_MESSAGE_ADDRESS_NO_ACK);
00043E  200040     MOV #0x4, W0
000440  070D97     RCALL I2C2_Stop
315:                           }
316:                           else
317:                           {
318:                               // Remove bit 0 as R/W is never sent here
319:                               I2C2_TRANSMIT_REG = (i2c_address >> 1) & 0x00FF;
000444  804490     MOV i2c_address, W0
000446  D10080     LSR W0, W1
000448  200FF0     MOV #0xFF, W0
00044A  608000     AND W1, W0, W0
00044C  882530     MOV W0, I2C2TRN
320:               
321:                               // determine the next state, check R/W
322:                               if(i2c_address & 0x01)
00044E  804490     MOV i2c_address, W0
000450  600061     AND W0, #0x1, W0
000452  784000     MOV.B W0, W0
000454  E00400     CP0.B W0
000456  320003     BRA Z, .L23
323:                               {
324:                                   // if this is a read we must repeat start
325:                                   // the bus to perform a read
326:                                   i2c2_state = S_MASTER_10BIT_RESTART;
000458  2000B0     MOV #0xB, W0
00045A  884450     MOV W0, i2c2_state
327:                               }
328:                               else
329:                               {
330:                                   // this is a write continue writing data
331:                                   i2c2_state = S_MASTER_SEND_DATA;
00045E  200030     MOV #0x3, W0
000460  884450     MOV W0, i2c2_state
332:                               }
333:                           }
334:               
335:                           break;
000442  3700C3     BRA .L3
00045C  3700B6     BRA .L3
000462  3700B3     BRA .L3
336:               
337:                       case S_MASTER_10BIT_RESTART:
338:               
339:                           if(I2C2_ACKNOWLEDGE_STATUS_BIT)
000464  802571     MOV I2C2STAT, W1
000466  280000     MOV #0x8000, W0
000468  608000     AND W1, W0, W0
00046A  E00000     CP0 W0
00046C  32000A     BRA Z, .L24
340:                           {
341:                               i2c2_object.i2cErrors++;
00046E  208820     MOV #0x882, W0
000470  400066     ADD W0, #0x6, W0
000472  784010     MOV.B [W0], W0
000474  E84080     INC.B W0, W1
000476  208820     MOV #0x882, W0
000478  400066     ADD W0, #0x6, W0
00047A  784801     MOV.B W1, [W0]
342:                               I2C2_Stop(I2C2_MESSAGE_ADDRESS_NO_ACK);
00047C  200040     MOV #0x4, W0
00047E  070D78     RCALL I2C2_Stop
343:                           }
344:                           else
345:                           {
346:                               // ACK Status is good
347:                               // restart the bus
348:                               I2C2_REPEAT_START_CONDITION_ENABLE_BIT = 1;
000482  A824AA     BSET I2C2CONL, #1
349:               
350:                               // fudge the address so S_MASTER_SEND_ADDR works correctly
351:                               // we only do this on a 10-bit address resend
352:                               i2c_address = 0x00F0 | ((i2c_address >> 8) & 0x0006);
000484  804490     MOV i2c_address, W0
000486  DE0048     LSR W0, #8, W0
000488  6000E6     AND W0, #0x6, W1
00048A  200F00     MOV #0xF0, W0
00048C  700001     IOR W0, W1, W0
00048E  884490     MOV W0, i2c_address
353:               
354:                               // set the R/W flag
355:                               i2c_address |= 0x0001;
000490  804490     MOV i2c_address, W0
000492  A00000     BSET W0, #0
000494  884490     MOV W0, i2c_address
356:               
357:                               // set the address restart flag so we do not change the address
358:                               i2c_10bit_address_restart = 1;
000496  B3C010     MOV.B #0x1, W0
000498  B7E894     MOV.B WREG, i2c_10bit_address_restart
359:               
360:                               // Resend the address as a read
361:                               i2c2_state = S_MASTER_SEND_ADDR;
00049A  200020     MOV #0x2, W0
00049C  884450     MOV W0, i2c2_state
362:                           }
363:               
364:                           break;
000480  3700A4     BRA .L3
00049E  370095     BRA .L3
365:               
366:                       case S_MASTER_SEND_ADDR:
367:               
368:                           /* Start has been sent, send the address byte */
369:               
370:                           /* Note: 
371:                               On a 10-bit address resend (done only during a 10-bit
372:                               device read), the original i2c_address was modified in
373:                               S_MASTER_10BIT_RESTART state. So the check if this is
374:                               a 10-bit address will fail and a normal 7-bit address
375:                               is sent with the R/W bit set to read. The flag
376:                               i2c_10bit_address_restart prevents the  address to
377:                               be re-written.
378:                            */
379:                           if(i2c_10bit_address_restart != 1)
0004A0  BFC894     MOV.B i2c_10bit_address_restart, WREG
0004A2  504FE1     SUB.B W0, #0x1, [W15]
0004A4  32000C     BRA Z, .L26
380:                           {
381:                               // extract the information for this message
382:                               i2c_address    = p_i2c2_trb_current->address;
0004A6  804470     MOV p_i2c2_trb_current, W0
0004A8  780010     MOV [W0], W0
0004AA  884490     MOV W0, i2c_address
383:                               pi2c_buf_ptr   = p_i2c2_trb_current->pbuffer;
0004AC  804470     MOV p_i2c2_trb_current, W0
0004AE  400064     ADD W0, #0x4, W0
0004B0  780010     MOV [W0], W0
0004B2  8844B0     MOV W0, pi2c_buf_ptr
384:                               i2c_bytes_left = p_i2c2_trb_current->length;
0004B4  804470     MOV p_i2c2_trb_current, W0
0004B6  E88000     INC2 W0, W0
0004B8  784010     MOV.B [W0], W0
0004BA  B7E898     MOV.B WREG, i2c_bytes_left
0004BC  370001     BRA .L27
385:                           }
386:                           else
387:                           {
388:                               // reset the flag so the next access is ok
389:                               i2c_10bit_address_restart = 0;
0004BE  EF6894     CLR.B i2c_10bit_address_restart
390:                           }
391:               
392:                           // check for 10-bit address
393:                           if(i2c_address > 0x00FF)
0004C0  804491     MOV i2c_address, W1
0004C2  200FF0     MOV #0xFF, W0
0004C4  508F80     SUB W1, W0, [W15]
0004C6  360009     BRA LEU, .L28
394:                           {
395:                               // we have a 10 bit address
396:                               // send bits<9:8>
397:                               // mask bit 0 as this is always a write
398:                               I2C2_TRANSMIT_REG = 0xF0 | ((i2c_address >> 8) & 0x0006);
0004C8  804490     MOV i2c_address, W0
0004CA  DE0048     LSR W0, #8, W0
0004CC  6000E6     AND W0, #0x6, W1
0004CE  200F00     MOV #0xF0, W0
0004D0  700001     IOR W0, W1, W0
0004D2  882530     MOV W0, I2C2TRN
399:                               i2c2_state = S_MASTER_SEND_ADDR_10BIT_LSB;
0004D4  2000A0     MOV #0xA, W0
0004D6  884450     MOV W0, i2c2_state
400:                           }
401:                           else
402:                           {
403:                               // Transmit the address
404:                               I2C2_TRANSMIT_REG = i2c_address;
0004DA  804490     MOV i2c_address, W0
0004DC  882530     MOV W0, I2C2TRN
405:                               if(i2c_address & 0x01)
0004DE  804490     MOV i2c_address, W0
0004E0  600061     AND W0, #0x1, W0
0004E2  784000     MOV.B W0, W0
0004E4  E00400     CP0.B W0
0004E6  320003     BRA Z, .L30
406:                               {
407:                                   // Next state is to wait for address to be acked
408:                                   i2c2_state = S_MASTER_ACK_ADDR;
0004E8  200050     MOV #0x5, W0
0004EA  884450     MOV W0, i2c2_state
409:                               }
410:                               else
411:                               {
412:                                   // Next state is transmit
413:                                   i2c2_state = S_MASTER_SEND_DATA;
0004EE  200030     MOV #0x3, W0
0004F0  884450     MOV W0, i2c2_state
414:                               }
415:                           }
416:                           break;
0004D8  370078     BRA .L3
0004EC  37006E     BRA .L3
0004F2  37006B     BRA .L3
417:               
418:                       case S_MASTER_SEND_DATA:
419:               
420:                           // Make sure the previous byte was acknowledged
421:                           if(I2C2_ACKNOWLEDGE_STATUS_BIT)
0004F4  802571     MOV I2C2STAT, W1
0004F6  280000     MOV #0x8000, W0
0004F8  608000     AND W1, W0, W0
0004FA  E00000     CP0 W0
0004FC  32000B     BRA Z, .L31
422:                           {
423:                               // Transmission was not acknowledged
424:                               i2c2_object.i2cErrors++;
0004FE  208820     MOV #0x882, W0
000500  400066     ADD W0, #0x6, W0
000502  784010     MOV.B [W0], W0
000504  E84080     INC.B W0, W1
000506  208820     MOV #0x882, W0
000508  400066     ADD W0, #0x6, W0
00050A  784801     MOV.B W1, [W0]
425:               
426:                               // Reset the Ack flag
427:                               I2C2_ACKNOWLEDGE_STATUS_BIT = 0;
00050C  A9E4AF     BCLR 0x4AF, #7
428:               
429:                               // Send a stop flag and go back to idle
430:                               I2C2_Stop(I2C2_DATA_NO_ACK);
00050E  200050     MOV #0x5, W0
000510  070D2F     RCALL I2C2_Stop
431:               
432:                           }
433:                           else
434:                           {
435:                               // Did we send them all ?
436:                               if(i2c_bytes_left-- == 0U)
000514  BFC898     MOV.B i2c_bytes_left, WREG
000516  FB8080     ZE W0, W1
000518  E90081     DEC W1, W1
00051A  DE08CF     LSR W1, #15, W1
00051C  784081     MOV.B W1, W1
00051E  E94000     DEC.B W0, W0
000520  B7E898     MOV.B WREG, i2c_bytes_left
000522  E00401     CP0.B W1
000524  320010     BRA Z, .L33
437:                               {
438:                                   // yup sent them all!
439:               
440:                                   // update the trb pointer
441:                                   p_i2c2_trb_current++;
000526  804470     MOV p_i2c2_trb_current, W0
000528  400066     ADD W0, #0x6, W0
00052A  884470     MOV W0, p_i2c2_trb_current
442:               
443:                                   // are we done with this string of requests?
444:                                   if(--i2c2_trb_count == 0)
00052C  BFC88C     MOV.B i2c2_trb_count, WREG
00052E  E94000     DEC.B W0, W0
000530  B7E88C     MOV.B WREG, i2c2_trb_count
000532  BFC88C     MOV.B i2c2_trb_count, WREG
000534  E00400     CP0.B W0
000536  3A0003     BRA NZ, .L34
445:                                   {
446:                                       I2C2_Stop(I2C2_MESSAGE_COMPLETE);
000538  200020     MOV #0x2, W0
00053A  070D1A     RCALL I2C2_Stop
447:                                   }
448:                                   else
449:                                   {
450:                                       // no!, there are more TRB to be sent.
451:                                       //I2C2_START_CONDITION_ENABLE_BIT = 1;
452:               
453:                                       // In some cases, the slave may require
454:                                       // a restart instead of a start. So use this one
455:                                       // instead.
456:                                       I2C2_REPEAT_START_CONDITION_ENABLE_BIT = 1;
00053E  A824AA     BSET I2C2CONL, #1
457:               
458:                                       // start the i2c request
459:                                       i2c2_state = S_MASTER_SEND_ADDR;
000540  200020     MOV #0x2, W0
000542  884450     MOV W0, i2c2_state
460:               
461:                                   }
462:                               }
463:                               else
464:                               {
465:                                   // Grab the next data to transmit
466:                                   I2C2_TRANSMIT_REG = *pi2c_buf_ptr++;
000546  8044B0     MOV pi2c_buf_ptr, W0
000548  784090     MOV.B [W0], W1
00054A  FB8081     ZE W1, W1
00054C  882531     MOV W1, I2C2TRN
00054E  E80000     INC W0, W0
000550  8844B0     MOV W0, pi2c_buf_ptr
467:                               }
468:                           }
469:                           break;
000512  37005B     BRA .L3
00053C  370046     BRA .L3
000544  370042     BRA .L3
000552  37003B     BRA .L3
470:               
471:                       case S_MASTER_ACK_ADDR:
472:               
473:                           /* Make sure the previous byte was acknowledged */
474:                           if(I2C2_ACKNOWLEDGE_STATUS_BIT)
000554  802571     MOV I2C2STAT, W1
000556  280000     MOV #0x8000, W0
000558  608000     AND W1, W0, W0
00055A  E00000     CP0 W0
00055C  32000B     BRA Z, .L35
475:                           {
476:               
477:                               // Transmission was not acknowledged
478:                               i2c2_object.i2cErrors++;
00055E  208820     MOV #0x882, W0
000560  400066     ADD W0, #0x6, W0
000562  784010     MOV.B [W0], W0
000564  E84080     INC.B W0, W1
000566  208820     MOV #0x882, W0
000568  400066     ADD W0, #0x6, W0
00056A  784801     MOV.B W1, [W0]
479:               
480:                               // Send a stop flag and go back to idle
481:                               I2C2_Stop(I2C2_MESSAGE_ADDRESS_NO_ACK);
00056C  200040     MOV #0x4, W0
00056E  070D00     RCALL I2C2_Stop
482:               
483:                               // Reset the Ack flag
484:                               I2C2_ACKNOWLEDGE_STATUS_BIT = 0;
000570  A9E4AF     BCLR 0x4AF, #7
485:                           }
486:                           else
487:                           {
488:                               I2C2_RECEIVE_ENABLE_BIT = 1;
000574  A864AA     BSET I2C2CONL, #3
489:                               i2c2_state = S_MASTER_ACK_RCV_DATA;
000576  200080     MOV #0x8, W0
000578  884450     MOV W0, i2c2_state
490:                           }
491:                           break;
000572  37002B     BRA .L3
00057A  370027     BRA .L3
492:               
493:                       case S_MASTER_RCV_DATA:
494:               
495:                           /* Acknowledge is completed.  Time for more data */
496:               
497:                           // Next thing is to ack the data
498:                           i2c2_state = S_MASTER_ACK_RCV_DATA;
00057C  200080     MOV #0x8, W0
00057E  884450     MOV W0, i2c2_state
499:               
500:                           // Set up to receive a byte of data
501:                           I2C2_RECEIVE_ENABLE_BIT = 1;
000580  A864AA     BSET I2C2CONL, #3
502:               
503:                           break;
000582  370023     BRA .L3
504:               
505:                       case S_MASTER_ACK_RCV_DATA:
506:               
507:                           // Grab the byte of data received and acknowledge it
508:                           *pi2c_buf_ptr++ = I2C2_RECEIVE_REG;
000584  8044B0     MOV pi2c_buf_ptr, W0
000586  802521     MOV I2C2RCV, W1
000588  784081     MOV.B W1, W1
00058A  784801     MOV.B W1, [W0]
00058C  E80000     INC W0, W0
00058E  8844B0     MOV W0, pi2c_buf_ptr
509:               
510:                           // Check if we received them all?
511:                           if(--i2c_bytes_left)
000590  BFC898     MOV.B i2c_bytes_left, WREG
000592  E94000     DEC.B W0, W0
000594  B7E898     MOV.B WREG, i2c_bytes_left
000596  BFC898     MOV.B i2c_bytes_left, WREG
000598  E00400     CP0.B W0
00059A  320004     BRA Z, .L37
512:                           {
513:               
514:                               /* No, there's more to receive */
515:               
516:                               // No, bit 7 is clear.  Data is ok
517:                               // Set the flag to acknowledge the data
518:                               I2C2_ACKNOWLEDGE_DATA_BIT = 0;
00059C  A9A4AA     BCLR I2C2CONL, #5
519:               
520:                               // Wait for the acknowledge to complete, then get more
521:                               i2c2_state = S_MASTER_RCV_DATA;
00059E  200060     MOV #0x6, W0
0005A0  884450     MOV W0, i2c2_state
0005A2  370002     BRA .L38
522:                           }
523:                           else
524:                           {
525:               
526:                               // Yes, it's the last byte.  Don't ack it
527:                               // Flag that we will nak the data
528:                               I2C2_ACKNOWLEDGE_DATA_BIT = 1;
0005A4  A8A4AA     BSET I2C2CONL, #5
529:               
530:                               I2C2_FunctionComplete();
0005A6  070CD3     RCALL I2C2_FunctionComplete
531:                           }
532:               
533:                           // Initiate the acknowledge
534:                           I2C2_ACKNOWLEDGE_ENABLE_BIT = 1;
0005A8  A884AA     BSET I2C2CONL, #4
535:                           break;
0005AA  37000F     BRA .L3
536:               
537:                       case S_MASTER_RCV_STOP:                
538:                       case S_MASTER_SEND_STOP:
539:               
540:                           // Send the stop flag
541:                           I2C2_Stop(I2C2_MESSAGE_COMPLETE);
0005AC  200020     MOV #0x2, W0
0005AE  070CE0     RCALL I2C2_Stop
542:                           break;
0005B0  37000C     BRA .L3
543:               
544:                       default:
545:               
546:                           // This case should not happen, if it does then
547:                           // terminate the transfer
548:                           i2c2_object.i2cErrors++;
0005B2  208820     MOV #0x882, W0
0005B4  400066     ADD W0, #0x6, W0
0005B6  784010     MOV.B [W0], W0
0005B8  E84080     INC.B W0, W1
0005BA  208820     MOV #0x882, W0
0005BC  400066     ADD W0, #0x6, W0
0005BE  784801     MOV.B W1, [W0]
549:                           I2C2_Stop(I2C2_LOST_STATE);
0005C0  200060     MOV #0x6, W0
0005C2  070CD6     RCALL I2C2_Stop
550:                           break;
0005C4  000000     NOP
0005C6  370001     BRA .L3
551:               
552:                   }
553:               }
0005CA  FA8000     ULNK
0005CC  BE034F     MOV.D [--W15], W6
0005CE  BE024F     MOV.D [--W15], W4
0005D0  BE014F     MOV.D [--W15], W2
0005D2  BE004F     MOV.D [--W15], W0
0005D4  F90036     POP RCOUNT
0005D6  064000     RETFIE
554:               
555:               static void I2C2_FunctionComplete(void)
556:               {
001F4E  FA0000     LNK #0x0
557:               
558:                   // update the trb pointer
559:                   p_i2c2_trb_current++;
001F50  804470     MOV p_i2c2_trb_current, W0
001F52  400066     ADD W0, #0x6, W0
001F54  884470     MOV W0, p_i2c2_trb_current
560:               
561:                   // are we done with this string of requests?
562:                   if(--i2c2_trb_count == 0)
001F56  BFC88C     MOV.B i2c2_trb_count, WREG
001F58  E94000     DEC.B W0, W0
001F5A  B7E88C     MOV.B WREG, i2c2_trb_count
001F5C  BFC88C     MOV.B i2c2_trb_count, WREG
001F5E  E00400     CP0.B W0
001F60  3A0003     BRA NZ, .L41
563:                   {
564:                       i2c2_state = S_MASTER_SEND_STOP;
001F62  200040     MOV #0x4, W0
001F64  884450     MOV W0, i2c2_state
001F66  370002     BRA .L40
565:                   }
566:                   else
567:                   {
568:                       i2c2_state = S_MASTER_RESTART;
001F68  200010     MOV #0x1, W0
001F6A  884450     MOV W0, i2c2_state
569:                   }
570:               
571:               }
001F6C  FA8000     ULNK
001F6E  060000     RETURN
572:               
573:               static void I2C2_Stop(I2C2_MESSAGE_STATUS completion_code)
574:               {
001F70  FA0002     LNK #0x2
001F72  780F00     MOV W0, [W14]
575:                   // then send a stop
576:                   I2C2_STOP_CONDITION_ENABLE_BIT = 1;
001F74  A844AA     BSET I2C2CONL, #2
577:               
578:                   // make sure the flag pointer is not NULL
579:                   if (p_i2c2_current->pTrFlag != NULL)
001F76  804480     MOV p_i2c2_current, W0
001F78  400064     ADD W0, #0x4, W0
001F7A  780010     MOV [W0], W0
001F7C  E00000     CP0 W0
001F7E  320004     BRA Z, .L44
580:                   {
581:                       // update the flag with the completion code
582:                       *(p_i2c2_current->pTrFlag) = completion_code;
001F80  804480     MOV p_i2c2_current, W0
001F82  400064     ADD W0, #0x4, W0
001F84  780010     MOV [W0], W0
001F86  78081E     MOV [W14], [W0]
583:                   }
584:               
585:                   // Done, back to idle
586:                   i2c2_state = S_MASTER_IDLE;
001F88  EF288A     CLR i2c2_state
587:                   
588:               }
001F8A  FA8000     ULNK
001F8C  060000     RETURN
589:               
590:               void I2C2_MasterWrite(
591:                                               uint8_t *pdata,
592:                                               uint8_t length,
593:                                               uint16_t address,
594:                                               I2C2_MESSAGE_STATUS *pstatus)
595:               {
001F8E  FA0008     LNK #0x8
001F90  780F00     MOV W0, [W14]
001F92  E8800E     INC2 W14, W0
001F94  784801     MOV.B W1, [W0]
001F96  470064     ADD W14, #0x4, W0
001F98  780802     MOV W2, [W0]
001F9A  470066     ADD W14, #0x6, W0
001F9C  780803     MOV W3, [W0]
596:                   static I2C2_TRANSACTION_REQUEST_BLOCK   trBlock;
597:               
598:                   // check if there is space in the queue
599:                   if (i2c2_object.trStatus.s.full != true)
001F9E  208820     MOV #0x882, W0
001FA0  400064     ADD W0, #0x4, W0
001FA2  780010     MOV [W0], W0
001FA4  600061     AND W0, #0x1, W0
001FA6  E00000     CP0 W0
001FA8  3A000D     BRA NZ, .L46
600:                   {
601:                       I2C2_MasterWriteTRBBuild(&trBlock, pdata, length, address);
001FAA  470064     ADD W14, #0x4, W0
001FAC  780190     MOV [W0], W3
001FAE  E8800E     INC2 W14, W0
001FB0  784110     MOV.B [W0], W2
001FB2  78009E     MOV [W14], W1
001FB4  20D000     MOV #0xD00, W0
001FB6  070093     RCALL I2C2_MasterWriteTRBBuild
602:                       I2C2_MasterTRBInsert(1, &trBlock, pstatus);
001FB8  470066     ADD W14, #0x6, W0
001FBA  780110     MOV [W0], W2
001FBC  20D001     MOV #0xD00, W1
001FBE  B3C010     MOV.B #0x1, W0
001FC0  070028     RCALL I2C2_MasterTRBInsert
001FC2  370004     BRA .L45
603:                   }
604:                   else
605:                   {
606:                       *pstatus = I2C2_MESSAGE_FAIL;
001FC4  470066     ADD W14, #0x6, W0
001FC6  780010     MOV [W0], W0
001FC8  EB0080     CLR W1
001FCA  780801     MOV W1, [W0]
607:                   }
608:               
609:               }                           
001FCC  FA8000     ULNK
001FCE  060000     RETURN
610:               
611:               void I2C2_MasterRead(
612:                                               uint8_t *pdata,
613:                                               uint8_t length,
614:                                               uint16_t address,
615:                                               I2C2_MESSAGE_STATUS *pstatus)
616:               {
001FD0  FA0008     LNK #0x8
001FD2  780F00     MOV W0, [W14]
001FD4  E8800E     INC2 W14, W0
001FD6  784801     MOV.B W1, [W0]
001FD8  470064     ADD W14, #0x4, W0
001FDA  780802     MOV W2, [W0]
001FDC  470066     ADD W14, #0x6, W0
001FDE  780803     MOV W3, [W0]
617:                   static I2C2_TRANSACTION_REQUEST_BLOCK   trBlock;
618:               
619:               
620:                   // check if there is space in the queue
621:                   if (i2c2_object.trStatus.s.full != true)
001FE0  208820     MOV #0x882, W0
001FE2  400064     ADD W0, #0x4, W0
001FE4  780010     MOV [W0], W0
001FE6  600061     AND W0, #0x1, W0
001FE8  E00000     CP0 W0
001FEA  3A000D     BRA NZ, .L49
622:                   {
623:                       I2C2_MasterReadTRBBuild(&trBlock, pdata, length, address);
001FEC  470064     ADD W14, #0x4, W0
001FEE  780190     MOV [W0], W3
001FF0  E8800E     INC2 W14, W0
001FF2  784110     MOV.B [W0], W2
001FF4  78009E     MOV [W14], W1
001FF6  20CFA0     MOV #0xCFA, W0
001FF8  070054     RCALL I2C2_MasterReadTRBBuild
624:                       I2C2_MasterTRBInsert(1, &trBlock, pstatus);
001FFA  470066     ADD W14, #0x6, W0
001FFC  780110     MOV [W0], W2
001FFE  20CFA1     MOV #0xCFA, W1
002000  B3C010     MOV.B #0x1, W0
002002  070007     RCALL I2C2_MasterTRBInsert
002004  370004     BRA .L48
625:                   }
626:                   else
627:                   {
628:                       *pstatus = I2C2_MESSAGE_FAIL;
002006  470066     ADD W14, #0x6, W0
002008  780010     MOV [W0], W0
00200A  EB0080     CLR W1
00200C  780801     MOV W1, [W0]
629:                   }
630:               
631:               }       
00200E  FA8000     ULNK
002010  060000     RETURN
632:               
633:               void I2C2_MasterTRBInsert(
634:                                               uint8_t count,
635:                                               I2C2_TRANSACTION_REQUEST_BLOCK *ptrb_list,
636:                                               I2C2_MESSAGE_STATUS *pflag)
637:               {
002012  FA0006     LNK #0x6
002014  784F00     MOV.B W0, [W14]
002016  E8800E     INC2 W14, W0
002018  780801     MOV W1, [W0]
00201A  470064     ADD W14, #0x4, W0
00201C  780802     MOV W2, [W0]
638:               
639:                   // check if there is space in the queue
640:                   if (i2c2_object.trStatus.s.full != true)
00201E  208820     MOV #0x882, W0
002020  400064     ADD W0, #0x4, W0
002022  780010     MOV [W0], W0
002024  600061     AND W0, #0x1, W0
002026  E00000     CP0 W0
002028  3A0036     BRA NZ, .L52
641:                   {
642:                       *pflag = I2C2_MESSAGE_PENDING;
00202A  470064     ADD W14, #0x4, W0
00202C  780010     MOV [W0], W0
00202E  200011     MOV #0x1, W1
002030  780801     MOV W1, [W0]
643:               
644:                       i2c2_object.pTrTail->ptrb_list = ptrb_list;
002032  208820     MOV #0x882, W0
002034  780010     MOV [W0], W0
002036  E88000     INC2 W0, W0
002038  E8808E     INC2 W14, W1
00203A  780811     MOV [W1], [W0]
645:                       i2c2_object.pTrTail->count     = count;
00203C  208820     MOV #0x882, W0
00203E  780010     MOV [W0], W0
002040  78481E     MOV.B [W14], [W0]
646:                       i2c2_object.pTrTail->pTrFlag   = pflag;
002042  208820     MOV #0x882, W0
002044  780010     MOV [W0], W0
002046  400064     ADD W0, #0x4, W0
002048  4700E4     ADD W14, #0x4, W1
00204A  780811     MOV [W1], [W0]
647:                       i2c2_object.pTrTail++;
00204C  208820     MOV #0x882, W0
00204E  780010     MOV [W0], W0
002050  4000E6     ADD W0, #0x6, W1
002052  208820     MOV #0x882, W0
002054  780801     MOV W1, [W0]
648:               
649:                       // check if the end of the array is reached
650:                       if (i2c2_object.pTrTail == (i2c2_tr_queue + I2C2_CONFIG_TR_QUEUE_LENGTH))
002056  208820     MOV #0x882, W0
002058  780090     MOV [W0], W1
00205A  20CFA0     MOV #0xCFA, W0
00205C  508F80     SUB W1, W0, [W15]
00205E  3A0003     BRA NZ, .L53
651:                       {
652:                           // adjust to restart at the beginning of the array
653:                           i2c2_object.pTrTail = i2c2_tr_queue;
002060  208820     MOV #0x882, W0
002062  20CF41     MOV #0xCF4, W1
002064  780801     MOV W1, [W0]
654:                       }
655:               
656:                       // since we added one item to be processed, we know
657:                       // it is not empty, so set the empty status to false
658:                       i2c2_object.trStatus.s.empty = false;
002066  208820     MOV #0x882, W0
002068  4000E4     ADD W0, #0x4, W1
00206A  780091     MOV [W1], W1
00206C  A11001     BCLR W1, #1
00206E  400064     ADD W0, #0x4, W0
002070  780801     MOV W1, [W0]
659:               
660:                       // check if full
661:                       if (i2c2_object.pTrHead == i2c2_object.pTrTail)
002072  208820     MOV #0x882, W0
002074  E88000     INC2 W0, W0
002076  780090     MOV [W0], W1
002078  208820     MOV #0x882, W0
00207A  780010     MOV [W0], W0
00207C  508F80     SUB W1, W0, [W15]
00207E  3A0006     BRA NZ, .L54
662:                       {
663:                           // it is full, set the full status to true
664:                           i2c2_object.trStatus.s.full = true;
002080  208820     MOV #0x882, W0
002082  4000E4     ADD W0, #0x4, W1
002084  780091     MOV [W1], W1
002086  A00001     BSET W1, #0
002088  400064     ADD W0, #0x4, W0
00208A  780801     MOV W1, [W0]
665:                       }
666:               
667:                       // for interrupt based
668:                       if(i2c2_state == S_MASTER_IDLE)
00208C  804450     MOV i2c2_state, W0
00208E  E00000     CP0 W0
002090  3A0006     BRA NZ, .L51
669:                       {    
670:                           // force the task to run since we know that the queue has
671:                           // something that needs to be sent
672:                           IFS3bits.MI2C2IF = 1;
002092  A8408E     BSET IFS3, #2
002094  370004     BRA .L51
673:                       }           
674:                       
675:                   }
676:                   else
677:                   {
678:                       *pflag = I2C2_MESSAGE_FAIL;
002096  470064     ADD W14, #0x4, W0
002098  780010     MOV [W0], W0
00209A  EB0080     CLR W1
00209C  780801     MOV W1, [W0]
679:                   }
680:               
681:               }      
00209E  FA8000     ULNK
0020A0  060000     RETURN
682:                                               
683:               void I2C2_MasterReadTRBBuild(
684:                                               I2C2_TRANSACTION_REQUEST_BLOCK *ptrb,
685:                                               uint8_t *pdata,
686:                                               uint8_t length,
687:                                               uint16_t address)
688:               {
0020A2  FA0008     LNK #0x8
0020A4  780F00     MOV W0, [W14]
0020A6  E8800E     INC2 W14, W0
0020A8  780801     MOV W1, [W0]
0020AA  470064     ADD W14, #0x4, W0
0020AC  784802     MOV.B W2, [W0]
0020AE  470066     ADD W14, #0x6, W0
0020B0  780803     MOV W3, [W0]
689:                   ptrb->address  = address << 1;
0020B2  470066     ADD W14, #0x6, W0
0020B4  780010     MOV [W0], W0
0020B6  400000     ADD W0, W0, W0
0020B8  780080     MOV W0, W1
0020BA  78001E     MOV [W14], W0
0020BC  780801     MOV W1, [W0]
690:                   // make this a read
691:                   ptrb->address |= 0x01;
0020BE  78001E     MOV [W14], W0
0020C0  780010     MOV [W0], W0
0020C2  780080     MOV W0, W1
0020C4  A00001     BSET W1, #0
0020C6  78001E     MOV [W14], W0
0020C8  780801     MOV W1, [W0]
692:                   ptrb->length   = length;
0020CA  78001E     MOV [W14], W0
0020CC  E88000     INC2 W0, W0
0020CE  4700E4     ADD W14, #0x4, W1
0020D0  784811     MOV.B [W1], [W0]
693:                   ptrb->pbuffer  = pdata;
0020D2  78001E     MOV [W14], W0
0020D4  400064     ADD W0, #0x4, W0
0020D6  E8808E     INC2 W14, W1
0020D8  780811     MOV [W1], [W0]
694:               }
0020DA  FA8000     ULNK
0020DC  060000     RETURN
695:                                               
696:               void I2C2_MasterWriteTRBBuild(
697:                                               I2C2_TRANSACTION_REQUEST_BLOCK *ptrb,
698:                                               uint8_t *pdata,
699:                                               uint8_t length,
700:                                               uint16_t address)
701:               {
0020DE  FA0008     LNK #0x8
0020E0  780F00     MOV W0, [W14]
0020E2  E8800E     INC2 W14, W0
0020E4  780801     MOV W1, [W0]
0020E6  470064     ADD W14, #0x4, W0
0020E8  784802     MOV.B W2, [W0]
0020EA  470066     ADD W14, #0x6, W0
0020EC  780803     MOV W3, [W0]
702:                   ptrb->address = address << 1;
0020EE  470066     ADD W14, #0x6, W0
0020F0  780010     MOV [W0], W0
0020F2  400000     ADD W0, W0, W0
0020F4  780080     MOV W0, W1
0020F6  78001E     MOV [W14], W0
0020F8  780801     MOV W1, [W0]
703:                   ptrb->length  = length;
0020FA  78001E     MOV [W14], W0
0020FC  E88000     INC2 W0, W0
0020FE  4700E4     ADD W14, #0x4, W1
002100  784811     MOV.B [W1], [W0]
704:                   ptrb->pbuffer = pdata;
002102  78001E     MOV [W14], W0
002104  400064     ADD W0, #0x4, W0
002106  E8808E     INC2 W14, W1
002108  780811     MOV [W1], [W0]
705:               }
00210A  FA8000     ULNK
00210C  060000     RETURN
706:               
707:               bool I2C2_MasterQueueIsEmpty(void)
708:               {
00210E  FA0000     LNK #0x0
709:                   return((bool)i2c2_object.trStatus.s.empty);
002110  208820     MOV #0x882, W0
002112  400064     ADD W0, #0x4, W0
002114  780010     MOV [W0], W0
002116  600062     AND W0, #0x2, W0
002118  A7F000     BTSC W0, #15
00211A  EA0000     NEG W0, W0
00211C  EA0000     NEG W0, W0
00211E  DE004F     LSR W0, #15, W0
002120  784000     MOV.B W0, W0
710:               }
002122  FA8000     ULNK
002124  060000     RETURN
711:               
712:               bool I2C2_MasterQueueIsFull(void)
713:               {
002126  FA0000     LNK #0x0
714:                   return((bool)i2c2_object.trStatus.s.full);
002128  208820     MOV #0x882, W0
00212A  400064     ADD W0, #0x4, W0
00212C  780010     MOV [W0], W0
00212E  600061     AND W0, #0x1, W0
002130  A7F000     BTSC W0, #15
002132  EA0000     NEG W0, W0
002134  EA0000     NEG W0, W0
002136  DE004F     LSR W0, #15, W0
002138  784000     MOV.B W0, W0
715:               }
00213A  FA8000     ULNK
00213C  060000     RETURN
716:               
717:               /**
718:                End of File
719:               */
---  E:/Users/Alex/Documents/eagle/projects/USBPD Supply/adapter/USBPD-Adapter.X/mcc_generated_files/i2c1.c
1:                 
2:                 /**
3:                   I2C1 Generated Driver File
4:                 
5:                   @Company
6:                     Microchip Technology Inc.
7:                 
8:                   @File Name
9:                     i2c1.c
10:                
11:                  @Summary
12:                    This is the generated header file for the i2c1 driver using PIC24 / dsPIC33 / PIC32MM MCUs
13:                
14:                  @Description
15:                    This header file provides APIs for driver for i2c1.
16:                    Generation Information :
17:                        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - 1.171.1
18:                        Device            :  PIC24FJ128GA702
19:                
20:                    The generated drivers are tested against the following:
21:                        Compiler          :  XC16 v1.70
22:                        MPLAB             :  MPLAB X v5.50
23:                */
24:                
25:                /*
26:                    (c) 2020 Microchip Technology Inc. and its subsidiaries. You may use this
27:                    software and any derivatives exclusively with Microchip products.
28:                
29:                    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
30:                    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
31:                    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
32:                    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
33:                    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
34:                
35:                    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
36:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
37:                    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
38:                    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
39:                    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
40:                    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
41:                    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
42:                
43:                    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
44:                    TERMS.
45:                */
46:                
47:                #include "i2c1.h"
48:                
49:                /**
50:                 Section: Data Types
51:                */
52:                
53:                /**
54:                  I2C Driver Queue Status Type
55:                
56:                  @Summary
57:                    Defines the type used for the transaction queue status.
58:                
59:                  @Description
60:                    This defines type used to keep track of the queue status.
61:                 */
62:                
63:                typedef union
64:                {
65:                    struct
66:                    {
67:                            uint8_t full:1;
68:                            uint8_t empty:1;
69:                            uint8_t reserved:6;
70:                    }s;
71:                    uint8_t status;
72:                } I2C_TR_QUEUE_STATUS;
73:                
74:                /**
75:                  I2C Driver Queue Entry Type
76:                
77:                  @Summary
78:                    Defines the object used for an entry in the i2c queue items.
79:                
80:                  @Description
81:                    This defines the object in the i2c queue. Each entry is a composed
82:                    of a list of TRBs, the number of the TRBs and the status of the
83:                    currently processed TRB.
84:                 */
85:                typedef struct
86:                {
87:                    uint8_t                         count;          // a count of trb's in the trb list
88:                    I2C1_TRANSACTION_REQUEST_BLOCK  *ptrb_list;     // pointer to the trb list
89:                    I2C1_MESSAGE_STATUS             *pTrFlag;       // set with the error of the last trb sent.
90:                                                                    // if all trb's are sent successfully,
91:                                                                    // then this is I2C1_MESSAGE_COMPLETE
92:                } I2C_TR_QUEUE_ENTRY;
93:                
94:                /**
95:                  I2C Master Driver Object Type
96:                
97:                  @Summary
98:                    Defines the object that manages the i2c master.
99:                
100:                 @Description
101:                   This defines the object that manages the sending and receiving of
102:                   i2c master transactions.
103:                 */
104:               
105:               typedef struct
106:               {
107:                   /* Read/Write Queue */
108:                   I2C_TR_QUEUE_ENTRY          *pTrTail;       // tail of the queue
109:                   I2C_TR_QUEUE_ENTRY          *pTrHead;       // head of the queue
110:                   I2C_TR_QUEUE_STATUS         trStatus;       // status of the last transaction
111:                   uint8_t                     i2cDoneFlag;    // flag to indicate the current
112:                                                               // transaction is done
113:                   uint8_t                     i2cErrors;      // keeps track of errors
114:               
115:               
116:               } I2C_OBJECT ;
117:               
118:               /**
119:                 I2C Master Driver State Enumeration
120:               
121:                 @Summary
122:                   Defines the different states of the i2c master.
123:               
124:                 @Description
125:                   This defines the different states that the i2c master
126:                   used to process transactions on the i2c bus.
127:               */
128:               
129:               typedef enum
130:               {
131:                   S_MASTER_IDLE,
132:                   S_MASTER_RESTART,
133:                   S_MASTER_SEND_ADDR,
134:                   S_MASTER_SEND_DATA,
135:                   S_MASTER_SEND_STOP,
136:                   S_MASTER_ACK_ADDR,
137:                   S_MASTER_RCV_DATA,
138:                   S_MASTER_RCV_STOP,
139:                   S_MASTER_ACK_RCV_DATA,
140:                   S_MASTER_NOACK_STOP,
141:                   S_MASTER_SEND_ADDR_10BIT_LSB,
142:                   S_MASTER_10BIT_RESTART,
143:                   
144:               } I2C_MASTER_STATES;
145:               
146:               /**
147:                Section: Macro Definitions
148:               */
149:               
150:               /* defined for I2C1 */
151:               
152:               
153:               #ifndef I2C1_CONFIG_TR_QUEUE_LENGTH
154:                       #define I2C1_CONFIG_TR_QUEUE_LENGTH 1
155:               #endif
156:               
157:               #define I2C1_TRANSMIT_REG                       I2C1TRN			// Defines the transmit register used to send data.
158:               #define I2C1_RECEIVE_REG                        I2C1RCV	// Defines the receive register used to receive data.
159:               
160:               // The following control bits are used in the I2C state machine to manage
161:               // the I2C module and determine next states.
162:               #define I2C1_WRITE_COLLISION_STATUS_BIT         I2C1STATbits.IWCOL	// Defines the write collision status bit.
163:               #define I2C1_ACKNOWLEDGE_STATUS_BIT             I2C1STATbits.ACKSTAT	// I2C ACK status bit.
164:               
165:               #define I2C1_START_CONDITION_ENABLE_BIT         I2C1CONLbits.SEN		// I2C START control bit.
166:               #define I2C1_REPEAT_START_CONDITION_ENABLE_BIT  I2C1CONLbits.RSEN	// I2C Repeated START control bit.
167:               #define I2C1_RECEIVE_ENABLE_BIT                 I2C1CONLbits.RCEN	// I2C Receive enable control bit.
168:               #define I2C1_STOP_CONDITION_ENABLE_BIT          I2C1CONLbits.PEN		// I2C STOP control bit.
169:               #define I2C1_ACKNOWLEDGE_ENABLE_BIT             I2C1CONLbits.ACKEN 	// I2C ACK start control bit.
170:               #define I2C1_ACKNOWLEDGE_DATA_BIT               I2C1CONLbits.ACKDT	// I2C ACK data control bit.
171:               
172:               /**
173:                Section: Local Functions
174:               */
175:               
176:               static void I2C1_FunctionComplete(void);
177:               static void I2C1_Stop(I2C1_MESSAGE_STATUS completion_code);
178:               
179:               /**
180:                Section: Local Variables
181:               */
182:               
183:               static I2C_TR_QUEUE_ENTRY            i2c1_tr_queue[I2C1_CONFIG_TR_QUEUE_LENGTH];
184:               static I2C_OBJECT                    i2c1_object;
185:               static I2C_MASTER_STATES             i2c1_state = S_MASTER_IDLE;
186:               static uint8_t                       i2c1_trb_count;
187:               
188:               static I2C1_TRANSACTION_REQUEST_BLOCK *p_i2c1_trb_current;
189:               static I2C_TR_QUEUE_ENTRY            *p_i2c1_current = NULL;
190:               
191:               
192:               /**
193:                 Section: Driver Interface
194:               */
195:               
196:               void I2C1_Initialize(void)
197:               {
00213E  FA0000     LNK #0x0
198:                   
199:                   i2c1_object.pTrHead = i2c1_tr_queue;
002140  2089A0     MOV #0x89A, W0
002142  20D061     MOV #0xD06, W1
002144  E88000     INC2 W0, W0
002146  780801     MOV W1, [W0]
200:                   i2c1_object.pTrTail = i2c1_tr_queue;
002148  2089A0     MOV #0x89A, W0
00214A  20D061     MOV #0xD06, W1
00214C  780801     MOV W1, [W0]
201:                   i2c1_object.trStatus.s.empty = true;
00214E  2089A0     MOV #0x89A, W0
002150  4000E4     ADD W0, #0x4, W1
002152  780091     MOV [W1], W1
002154  A01001     BSET W1, #1
002156  400064     ADD W0, #0x4, W0
002158  780801     MOV W1, [W0]
202:                   i2c1_object.trStatus.s.full = false;
00215A  2089A0     MOV #0x89A, W0
00215C  4000E4     ADD W0, #0x4, W1
00215E  780091     MOV [W1], W1
002160  A10001     BCLR W1, #0
002162  400064     ADD W0, #0x4, W0
002164  780801     MOV W1, [W0]
203:               
204:                   i2c1_object.i2cErrors = 0;
002166  2089A0     MOV #0x89A, W0
002168  EB4080     CLR.B W1
00216A  400066     ADD W0, #0x6, W0
00216C  784801     MOV.B W1, [W0]
205:                   
206:                   // initialize the hardware
207:                   // Baud Rate Generator Value: I2CBRG 78;   
208:                   I2C1BRG = 0x4E;
00216E  2004E0     MOV #0x4E, W0
002170  8824C0     MOV W0, I2C1BRG
209:                   // ACKEN disabled; STRICT disabled; STREN disabled; GCEN disabled; SMEN disabled; DISSLW enabled; I2CSIDL disabled; ACKDT Sends ACK; SCLREL Holds; RSEN disabled; A10M 7 Bit; PEN disabled; RCEN disabled; SEN disabled; I2CEN enabled; 
210:                   I2C1CONL = 0x8000;
002172  280000     MOV #0x8000, W0
002174  8824D0     MOV W0, I2C1CONL
211:                   // BCL disabled; D_nA disabled; R_nW disabled; P disabled; S disabled; I2COV disabled; IWCOL disabled; 
212:                   I2C1STAT = 0x00;
002176  EF249E     CLR I2C1STAT
213:               
214:                   /* MI2C1 - I2C1 Master Events */
215:                   // clear the master interrupt flag
216:                   IFS1bits.MI2C1IF = 0;
002178  A9208A     BCLR IFS1, #1
217:                   // enable the master interrupt
218:                   IEC1bits.MI2C1IE = 1;
00217A  A8209A     BSET IEC1, #1
219:               
220:               }
00217C  FA8000     ULNK
00217E  060000     RETURN
221:               
222:               
223:               uint8_t I2C1_ErrorCountGet(void)
224:               {
002180  FA0002     LNK #0x2
225:                   uint8_t ret;
226:               
227:                   ret = i2c1_object.i2cErrors;
002182  2089A0     MOV #0x89A, W0
002184  400066     ADD W0, #0x6, W0
002186  784F10     MOV.B [W0], [W14]
228:                   return ret;
002188  78401E     MOV.B [W14], W0
229:               }
00218A  FA8000     ULNK
00218C  060000     RETURN
230:               
231:               void __attribute__ ( ( interrupt, no_auto_psv ) ) _MI2C1Interrupt ( void )
232:               {
0005D8  F80036     PUSH RCOUNT
0005DA  BE9F80     MOV.D W0, [W15++]
0005DC  BE9F82     MOV.D W2, [W15++]
0005DE  BE9F84     MOV.D W4, [W15++]
0005E0  BE9F86     MOV.D W6, [W15++]
0005E2  FA0000     LNK #0x0
233:                 
234:                   static uint8_t  *pi2c_buf_ptr;
235:                   static uint16_t i2c_address;
236:                   static uint8_t  i2c_bytes_left;
237:                   static uint8_t  i2c_10bit_address_restart = 0;
238:               
239:                   IFS1bits.MI2C1IF = 0;
0005E4  A9208A     BCLR IFS1, #1
240:                           
241:                   // Check first if there was a collision.
242:                   // If we have a Write Collision, reset and go to idle state */
243:                   if(I2C1_WRITE_COLLISION_STATUS_BIT)
0005E6  8024F1     MOV I2C1STAT, W1
0005E8  200800     MOV #0x80, W0
0005EA  608000     AND W1, W0, W0
0005EC  E00000     CP0 W0
0005EE  320009     BRA Z, .L4
244:                   {
245:                       // clear the Write colision
246:                       I2C1_WRITE_COLLISION_STATUS_BIT = 0;
0005F0  A9E49E     BCLR I2C1STAT, #7
247:                       i2c1_state = S_MASTER_IDLE;
0005F2  EF28A2     CLR i2c1_state
248:                       *(p_i2c1_current->pTrFlag) = I2C1_MESSAGE_FAIL;
0005F4  804540     MOV p_i2c1_current, W0
0005F6  400064     ADD W0, #0x4, W0
0005F8  780010     MOV [W0], W0
0005FA  EB0080     CLR W1
0005FC  780801     MOV W1, [W0]
249:               
250:                       // reset the buffer pointer
251:                       p_i2c1_current = NULL;
0005FE  EF28A8     CLR p_i2c1_current
252:               
253:                       return;
000600  370127     BRA .L3
254:                   }
255:               
256:                   /* Handle the correct i2c state */
257:                   switch(i2c1_state)
000602  804510     MOV i2c1_state, W0
000604  EB0080     CLR W1
000606  2000B2     MOV #0xB, W2
000608  200003     MOV #0x0, W3
00060A  500F82     SUB W0, W2, [W15]
00060C  588F83     SUBB W1, W3, [W15]
00060E  3E0114     BRA GTU, .L6
000610  016000     BRA W0
000612  37000B     BRA .SE17, .L7
000614  370047     BRA .L8
000616  370087     BRA .L9
000618  3700B0     BRA .L10
00061A  37010B     BRA .L11
00061C  3700DE     BRA .L12
00061E  3700F1     BRA .L13
000620  370108     BRA .L11
000622  3700F3     BRA .L14
000624  370109     BRA .L6
000626  370042     BRA .L15
000628  370060     BRA .L16
258:                   {
259:                       case S_MASTER_IDLE:    /* In reset state, waiting for data to send */
260:               
261:                           if(i2c1_object.trStatus.s.empty != true)
00062A  2089A0     MOV #0x89A, W0
00062C  400064     ADD W0, #0x4, W0
00062E  780010     MOV [W0], W0
000630  600062     AND W0, #0x2, W0
000632  E00000     CP0 W0
000634  3A010C     BRA NZ, .L39
262:                           {
263:                               // grab the item pointed by the head
264:                               p_i2c1_current     = i2c1_object.pTrHead;
000636  2089A0     MOV #0x89A, W0
000638  E88000     INC2 W0, W0
00063A  780010     MOV [W0], W0
00063C  884540     MOV W0, p_i2c1_current
265:                               i2c1_trb_count     = i2c1_object.pTrHead->count;
00063E  2089A0     MOV #0x89A, W0
000640  E88000     INC2 W0, W0
000642  780010     MOV [W0], W0
000644  784010     MOV.B [W0], W0
000646  B7E8A4     MOV.B WREG, i2c1_trb_count
266:                               p_i2c1_trb_current = i2c1_object.pTrHead->ptrb_list;
000648  2089A0     MOV #0x89A, W0
00064A  E88000     INC2 W0, W0
00064C  780010     MOV [W0], W0
00064E  E88000     INC2 W0, W0
000650  780010     MOV [W0], W0
000652  884530     MOV W0, p_i2c1_trb_current
267:               
268:                               i2c1_object.pTrHead++;
000654  2089A0     MOV #0x89A, W0
000656  E88000     INC2 W0, W0
000658  780010     MOV [W0], W0
00065A  4000E6     ADD W0, #0x6, W1
00065C  2089A0     MOV #0x89A, W0
00065E  E88000     INC2 W0, W0
000660  780801     MOV W1, [W0]
269:               
270:                               // check if the end of the array is reached
271:                               if(i2c1_object.pTrHead == (i2c1_tr_queue + I2C1_CONFIG_TR_QUEUE_LENGTH))
000662  2089A0     MOV #0x89A, W0
000664  E88000     INC2 W0, W0
000666  780090     MOV [W0], W1
000668  20D0C0     MOV #0xD0C, W0
00066A  508F80     SUB W1, W0, [W15]
00066C  3A0004     BRA NZ, .L19
272:                               {
273:                                   // adjust to restart at the beginning of the array
274:                                   i2c1_object.pTrHead = i2c1_tr_queue;
00066E  2089A0     MOV #0x89A, W0
000670  20D061     MOV #0xD06, W1
000672  E88000     INC2 W0, W0
000674  780801     MOV W1, [W0]
275:                               }
276:               
277:                               // since we moved one item to be processed, we know
278:                               // it is not full, so set the full status to false
279:                               i2c1_object.trStatus.s.full = false;
000676  2089A0     MOV #0x89A, W0
000678  4000E4     ADD W0, #0x4, W1
00067A  780091     MOV [W1], W1
00067C  A10001     BCLR W1, #0
00067E  400064     ADD W0, #0x4, W0
000680  780801     MOV W1, [W0]
280:               
281:                               // check if the queue is empty
282:                               if(i2c1_object.pTrHead == i2c1_object.pTrTail)
000682  2089A0     MOV #0x89A, W0
000684  E88000     INC2 W0, W0
000686  780090     MOV [W0], W1
000688  2089A0     MOV #0x89A, W0
00068A  780010     MOV [W0], W0
00068C  508F80     SUB W1, W0, [W15]
00068E  3A0006     BRA NZ, .L20
283:                               {
284:                                   // it is empty so set the empty status to true
285:                                   i2c1_object.trStatus.s.empty = true;
000690  2089A0     MOV #0x89A, W0
000692  4000E4     ADD W0, #0x4, W1
000694  780091     MOV [W1], W1
000696  A01001     BSET W1, #1
000698  400064     ADD W0, #0x4, W0
00069A  780801     MOV W1, [W0]
286:                               }
287:               
288:                               // send the start condition
289:                               I2C1_START_CONDITION_ENABLE_BIT = 1;
00069C  A8049A     BSET I2C1CONL, #0
290:               
291:                               // start the i2c request
292:                               i2c1_state = S_MASTER_SEND_ADDR;
00069E  200020     MOV #0x2, W0
0006A0  884510     MOV W0, i2c1_state
293:                           }
294:               
295:                           break;
0006A2  3700D6     BRA .L3
00084E  000000     NOP
296:               
297:                       case S_MASTER_RESTART:
298:               
299:                           /* check for pending i2c Request */
300:               
301:                           // ... trigger a REPEATED START
302:                           I2C1_REPEAT_START_CONDITION_ENABLE_BIT = 1;
0006A4  A8249A     BSET I2C1CONL, #1
303:               
304:                           // start the i2c request
305:                           i2c1_state = S_MASTER_SEND_ADDR;
0006A6  200020     MOV #0x2, W0
0006A8  884510     MOV W0, i2c1_state
306:               
307:                           break;
0006AA  3700D2     BRA .L3
308:               
309:                       case S_MASTER_SEND_ADDR_10BIT_LSB:
310:               
311:                           if(I2C1_ACKNOWLEDGE_STATUS_BIT)
0006AC  8024F1     MOV I2C1STAT, W1
0006AE  280000     MOV #0x8000, W0
0006B0  608000     AND W1, W0, W0
0006B2  E00000     CP0 W0
0006B4  32000A     BRA Z, .L21
312:                           {
313:                               i2c1_object.i2cErrors++;
0006B6  2089A0     MOV #0x89A, W0
0006B8  400066     ADD W0, #0x6, W0
0006BA  784010     MOV.B [W0], W0
0006BC  E84080     INC.B W0, W1
0006BE  2089A0     MOV #0x89A, W0
0006C0  400066     ADD W0, #0x6, W0
0006C2  784801     MOV.B W1, [W0]
314:                               I2C1_Stop(I2C1_MESSAGE_ADDRESS_NO_ACK);
0006C4  200040     MOV #0x4, W0
0006C6  070D74     RCALL I2C1_Stop
315:                           }
316:                           else
317:                           {
318:                               // Remove bit 0 as R/W is never sent here
319:                               I2C1_TRANSMIT_REG = (i2c_address >> 1) & 0x00FF;
0006CA  804550     MOV i2c_address, W0
0006CC  D10080     LSR W0, W1
0006CE  200FF0     MOV #0xFF, W0
0006D0  608000     AND W1, W0, W0
0006D2  8824B0     MOV W0, I2C1TRN
320:               
321:                               // determine the next state, check R/W
322:                               if(i2c_address & 0x01)
0006D4  804550     MOV i2c_address, W0
0006D6  600061     AND W0, #0x1, W0
0006D8  784000     MOV.B W0, W0
0006DA  E00400     CP0.B W0
0006DC  320003     BRA Z, .L23
323:                               {
324:                                   // if this is a read we must repeat start
325:                                   // the bus to perform a read
326:                                   i2c1_state = S_MASTER_10BIT_RESTART;
0006DE  2000B0     MOV #0xB, W0
0006E0  884510     MOV W0, i2c1_state
327:                               }
328:                               else
329:                               {
330:                                   // this is a write continue writing data
331:                                   i2c1_state = S_MASTER_SEND_DATA;
0006E4  200030     MOV #0x3, W0
0006E6  884510     MOV W0, i2c1_state
332:                               }
333:                           }
334:               
335:                           break;
0006C8  3700C3     BRA .L3
0006E2  3700B6     BRA .L3
0006E8  3700B3     BRA .L3
336:               
337:                       case S_MASTER_10BIT_RESTART:
338:               
339:                           if(I2C1_ACKNOWLEDGE_STATUS_BIT)
0006EA  8024F1     MOV I2C1STAT, W1
0006EC  280000     MOV #0x8000, W0
0006EE  608000     AND W1, W0, W0
0006F0  E00000     CP0 W0
0006F2  32000A     BRA Z, .L24
340:                           {
341:                               i2c1_object.i2cErrors++;
0006F4  2089A0     MOV #0x89A, W0
0006F6  400066     ADD W0, #0x6, W0
0006F8  784010     MOV.B [W0], W0
0006FA  E84080     INC.B W0, W1
0006FC  2089A0     MOV #0x89A, W0
0006FE  400066     ADD W0, #0x6, W0
000700  784801     MOV.B W1, [W0]
342:                               I2C1_Stop(I2C1_MESSAGE_ADDRESS_NO_ACK);
000702  200040     MOV #0x4, W0
000704  070D55     RCALL I2C1_Stop
343:                           }
344:                           else
345:                           {
346:                               // ACK Status is good
347:                               // restart the bus
348:                               I2C1_REPEAT_START_CONDITION_ENABLE_BIT = 1;
000708  A8249A     BSET I2C1CONL, #1
349:               
350:                               // fudge the address so S_MASTER_SEND_ADDR works correctly
351:                               // we only do this on a 10-bit address resend
352:                               i2c_address = 0x00F0 | ((i2c_address >> 8) & 0x0006);
00070A  804550     MOV i2c_address, W0
00070C  DE0048     LSR W0, #8, W0
00070E  6000E6     AND W0, #0x6, W1
000710  200F00     MOV #0xF0, W0
000712  700001     IOR W0, W1, W0
000714  884550     MOV W0, i2c_address
353:               
354:                               // set the R/W flag
355:                               i2c_address |= 0x0001;
000716  804550     MOV i2c_address, W0
000718  A00000     BSET W0, #0
00071A  884550     MOV W0, i2c_address
356:               
357:                               // set the address restart flag so we do not change the address
358:                               i2c_10bit_address_restart = 1;
00071C  B3C010     MOV.B #0x1, W0
00071E  B7E8AC     MOV.B WREG, i2c_10bit_address_restart
359:               
360:                               // Resend the address as a read
361:                               i2c1_state = S_MASTER_SEND_ADDR;
000720  200020     MOV #0x2, W0
000722  884510     MOV W0, i2c1_state
362:                           }
363:               
364:                           break;
000706  3700A4     BRA .L3
000724  370095     BRA .L3
365:               
366:                       case S_MASTER_SEND_ADDR:
367:               
368:                           /* Start has been sent, send the address byte */
369:               
370:                           /* Note: 
371:                               On a 10-bit address resend (done only during a 10-bit
372:                               device read), the original i2c_address was modified in
373:                               S_MASTER_10BIT_RESTART state. So the check if this is
374:                               a 10-bit address will fail and a normal 7-bit address
375:                               is sent with the R/W bit set to read. The flag
376:                               i2c_10bit_address_restart prevents the  address to
377:                               be re-written.
378:                            */
379:                           if(i2c_10bit_address_restart != 1)
000726  BFC8AC     MOV.B i2c_10bit_address_restart, WREG
000728  504FE1     SUB.B W0, #0x1, [W15]
00072A  32000C     BRA Z, .L26
380:                           {
381:                               // extract the information for this message
382:                               i2c_address    = p_i2c1_trb_current->address;
00072C  804530     MOV p_i2c1_trb_current, W0
00072E  780010     MOV [W0], W0
000730  884550     MOV W0, i2c_address
383:                               pi2c_buf_ptr   = p_i2c1_trb_current->pbuffer;
000732  804530     MOV p_i2c1_trb_current, W0
000734  400064     ADD W0, #0x4, W0
000736  780010     MOV [W0], W0
000738  884570     MOV W0, pi2c_buf_ptr
384:                               i2c_bytes_left = p_i2c1_trb_current->length;
00073A  804530     MOV p_i2c1_trb_current, W0
00073C  E88000     INC2 W0, W0
00073E  784010     MOV.B [W0], W0
000740  B7E8B0     MOV.B WREG, i2c_bytes_left
000742  370001     BRA .L27
385:                           }
386:                           else
387:                           {
388:                               // reset the flag so the next access is ok
389:                               i2c_10bit_address_restart = 0;
000744  EF68AC     CLR.B i2c_10bit_address_restart
390:                           }
391:               
392:                           // check for 10-bit address
393:                           if(i2c_address > 0x00FF)
000746  804551     MOV i2c_address, W1
000748  200FF0     MOV #0xFF, W0
00074A  508F80     SUB W1, W0, [W15]
00074C  360009     BRA LEU, .L28
394:                           {
395:                               // we have a 10 bit address
396:                               // send bits<9:8>
397:                               // mask bit 0 as this is always a write
398:                               I2C1_TRANSMIT_REG = 0xF0 | ((i2c_address >> 8) & 0x0006);
00074E  804550     MOV i2c_address, W0
000750  DE0048     LSR W0, #8, W0
000752  6000E6     AND W0, #0x6, W1
000754  200F00     MOV #0xF0, W0
000756  700001     IOR W0, W1, W0
000758  8824B0     MOV W0, I2C1TRN
399:                               i2c1_state = S_MASTER_SEND_ADDR_10BIT_LSB;
00075A  2000A0     MOV #0xA, W0
00075C  884510     MOV W0, i2c1_state
400:                           }
401:                           else
402:                           {
403:                               // Transmit the address
404:                               I2C1_TRANSMIT_REG = i2c_address;
000760  804550     MOV i2c_address, W0
000762  8824B0     MOV W0, I2C1TRN
405:                               if(i2c_address & 0x01)
000764  804550     MOV i2c_address, W0
000766  600061     AND W0, #0x1, W0
000768  784000     MOV.B W0, W0
00076A  E00400     CP0.B W0
00076C  320003     BRA Z, .L30
406:                               {
407:                                   // Next state is to wait for address to be acked
408:                                   i2c1_state = S_MASTER_ACK_ADDR;
00076E  200050     MOV #0x5, W0
000770  884510     MOV W0, i2c1_state
409:                               }
410:                               else
411:                               {
412:                                   // Next state is transmit
413:                                   i2c1_state = S_MASTER_SEND_DATA;
000774  200030     MOV #0x3, W0
000776  884510     MOV W0, i2c1_state
414:                               }
415:                           }
416:                           break;
00075E  370078     BRA .L3
000772  37006E     BRA .L3
000778  37006B     BRA .L3
417:               
418:                       case S_MASTER_SEND_DATA:
419:               
420:                           // Make sure the previous byte was acknowledged
421:                           if(I2C1_ACKNOWLEDGE_STATUS_BIT)
00077A  8024F1     MOV I2C1STAT, W1
00077C  280000     MOV #0x8000, W0
00077E  608000     AND W1, W0, W0
000780  E00000     CP0 W0
000782  32000B     BRA Z, .L31
422:                           {
423:                               // Transmission was not acknowledged
424:                               i2c1_object.i2cErrors++;
000784  2089A0     MOV #0x89A, W0
000786  400066     ADD W0, #0x6, W0
000788  784010     MOV.B [W0], W0
00078A  E84080     INC.B W0, W1
00078C  2089A0     MOV #0x89A, W0
00078E  400066     ADD W0, #0x6, W0
000790  784801     MOV.B W1, [W0]
425:               
426:                               // Reset the Ack flag
427:                               I2C1_ACKNOWLEDGE_STATUS_BIT = 0;
000792  A9E49F     BCLR 0x49F, #7
428:               
429:                               // Send a stop flag and go back to idle
430:                               I2C1_Stop(I2C1_DATA_NO_ACK);
000794  200050     MOV #0x5, W0
000796  070D0C     RCALL I2C1_Stop
431:               
432:                           }
433:                           else
434:                           {
435:                               // Did we send them all ?
436:                               if(i2c_bytes_left-- == 0U)
00079A  BFC8B0     MOV.B i2c_bytes_left, WREG
00079C  FB8080     ZE W0, W1
00079E  E90081     DEC W1, W1
0007A0  DE08CF     LSR W1, #15, W1
0007A2  784081     MOV.B W1, W1
0007A4  E94000     DEC.B W0, W0
0007A6  B7E8B0     MOV.B WREG, i2c_bytes_left
0007A8  E00401     CP0.B W1
0007AA  320010     BRA Z, .L33
437:                               {
438:                                   // yup sent them all!
439:               
440:                                   // update the trb pointer
441:                                   p_i2c1_trb_current++;
0007AC  804530     MOV p_i2c1_trb_current, W0
0007AE  400066     ADD W0, #0x6, W0
0007B0  884530     MOV W0, p_i2c1_trb_current
442:               
443:                                   // are we done with this string of requests?
444:                                   if(--i2c1_trb_count == 0)
0007B2  BFC8A4     MOV.B i2c1_trb_count, WREG
0007B4  E94000     DEC.B W0, W0
0007B6  B7E8A4     MOV.B WREG, i2c1_trb_count
0007B8  BFC8A4     MOV.B i2c1_trb_count, WREG
0007BA  E00400     CP0.B W0
0007BC  3A0003     BRA NZ, .L34
445:                                   {
446:                                       I2C1_Stop(I2C1_MESSAGE_COMPLETE);
0007BE  200020     MOV #0x2, W0
0007C0  070CF7     RCALL I2C1_Stop
447:                                   }
448:                                   else
449:                                   {
450:                                       // no!, there are more TRB to be sent.
451:                                       //I2C1_START_CONDITION_ENABLE_BIT = 1;
452:               
453:                                       // In some cases, the slave may require
454:                                       // a restart instead of a start. So use this one
455:                                       // instead.
456:                                       I2C1_REPEAT_START_CONDITION_ENABLE_BIT = 1;
0007C4  A8249A     BSET I2C1CONL, #1
457:               
458:                                       // start the i2c request
459:                                       i2c1_state = S_MASTER_SEND_ADDR;
0007C6  200020     MOV #0x2, W0
0007C8  884510     MOV W0, i2c1_state
460:               
461:                                   }
462:                               }
463:                               else
464:                               {
465:                                   // Grab the next data to transmit
466:                                   I2C1_TRANSMIT_REG = *pi2c_buf_ptr++;
0007CC  804570     MOV pi2c_buf_ptr, W0
0007CE  784090     MOV.B [W0], W1
0007D0  FB8081     ZE W1, W1
0007D2  8824B1     MOV W1, I2C1TRN
0007D4  E80000     INC W0, W0
0007D6  884570     MOV W0, pi2c_buf_ptr
467:                               }
468:                           }
469:                           break;
000798  37005B     BRA .L3
0007C2  370046     BRA .L3
0007CA  370042     BRA .L3
0007D8  37003B     BRA .L3
470:               
471:                       case S_MASTER_ACK_ADDR:
472:               
473:                           /* Make sure the previous byte was acknowledged */
474:                           if(I2C1_ACKNOWLEDGE_STATUS_BIT)
0007DA  8024F1     MOV I2C1STAT, W1
0007DC  280000     MOV #0x8000, W0
0007DE  608000     AND W1, W0, W0
0007E0  E00000     CP0 W0
0007E2  32000B     BRA Z, .L35
475:                           {
476:               
477:                               // Transmission was not acknowledged
478:                               i2c1_object.i2cErrors++;
0007E4  2089A0     MOV #0x89A, W0
0007E6  400066     ADD W0, #0x6, W0
0007E8  784010     MOV.B [W0], W0
0007EA  E84080     INC.B W0, W1
0007EC  2089A0     MOV #0x89A, W0
0007EE  400066     ADD W0, #0x6, W0
0007F0  784801     MOV.B W1, [W0]
479:               
480:                               // Send a stop flag and go back to idle
481:                               I2C1_Stop(I2C1_MESSAGE_ADDRESS_NO_ACK);
0007F2  200040     MOV #0x4, W0
0007F4  070CDD     RCALL I2C1_Stop
482:               
483:                               // Reset the Ack flag
484:                               I2C1_ACKNOWLEDGE_STATUS_BIT = 0;
0007F6  A9E49F     BCLR 0x49F, #7
485:                           }
486:                           else
487:                           {
488:                               I2C1_RECEIVE_ENABLE_BIT = 1;
0007FA  A8649A     BSET I2C1CONL, #3
489:                               i2c1_state = S_MASTER_ACK_RCV_DATA;
0007FC  200080     MOV #0x8, W0
0007FE  884510     MOV W0, i2c1_state
490:                           }
491:                           break;
0007F8  37002B     BRA .L3
000800  370027     BRA .L3
492:               
493:                       case S_MASTER_RCV_DATA:
494:               
495:                           /* Acknowledge is completed.  Time for more data */
496:               
497:                           // Next thing is to ack the data
498:                           i2c1_state = S_MASTER_ACK_RCV_DATA;
000802  200080     MOV #0x8, W0
000804  884510     MOV W0, i2c1_state
499:               
500:                           // Set up to receive a byte of data
501:                           I2C1_RECEIVE_ENABLE_BIT = 1;
000806  A8649A     BSET I2C1CONL, #3
502:               
503:                           break;
000808  370023     BRA .L3
504:               
505:                       case S_MASTER_ACK_RCV_DATA:
506:               
507:                           // Grab the byte of data received and acknowledge it
508:                           *pi2c_buf_ptr++ = I2C1_RECEIVE_REG;
00080A  804570     MOV pi2c_buf_ptr, W0
00080C  8024A1     MOV I2C1RCV, W1
00080E  784081     MOV.B W1, W1
000810  784801     MOV.B W1, [W0]
000812  E80000     INC W0, W0
000814  884570     MOV W0, pi2c_buf_ptr
509:               
510:                           // Check if we received them all?
511:                           if(--i2c_bytes_left)
000816  BFC8B0     MOV.B i2c_bytes_left, WREG
000818  E94000     DEC.B W0, W0
00081A  B7E8B0     MOV.B WREG, i2c_bytes_left
00081C  BFC8B0     MOV.B i2c_bytes_left, WREG
00081E  E00400     CP0.B W0
000820  320004     BRA Z, .L37
512:                           {
513:               
514:                               /* No, there's more to receive */
515:               
516:                               // No, bit 7 is clear.  Data is ok
517:                               // Set the flag to acknowledge the data
518:                               I2C1_ACKNOWLEDGE_DATA_BIT = 0;
000822  A9A49A     BCLR I2C1CONL, #5
519:               
520:                               // Wait for the acknowledge to complete, then get more
521:                               i2c1_state = S_MASTER_RCV_DATA;
000824  200060     MOV #0x6, W0
000826  884510     MOV W0, i2c1_state
000828  370002     BRA .L38
522:                           }
523:                           else
524:                           {
525:               
526:                               // Yes, it's the last byte.  Don't ack it
527:                               // Flag that we will nak the data
528:                               I2C1_ACKNOWLEDGE_DATA_BIT = 1;
00082A  A8A49A     BSET I2C1CONL, #5
529:               
530:                               I2C1_FunctionComplete();
00082C  070CB0     RCALL I2C1_FunctionComplete
531:                           }
532:               
533:                           // Initiate the acknowledge
534:                           I2C1_ACKNOWLEDGE_ENABLE_BIT = 1;
00082E  A8849A     BSET I2C1CONL, #4
535:                           break;
000830  37000F     BRA .L3
536:               
537:                       case S_MASTER_RCV_STOP:                
538:                       case S_MASTER_SEND_STOP:
539:               
540:                           // Send the stop flag
541:                           I2C1_Stop(I2C1_MESSAGE_COMPLETE);
000832  200020     MOV #0x2, W0
000834  070CBD     RCALL I2C1_Stop
542:                           break;
000836  37000C     BRA .L3
543:               
544:                       default:
545:               
546:                           // This case should not happen, if it does then
547:                           // terminate the transfer
548:                           i2c1_object.i2cErrors++;
000838  2089A0     MOV #0x89A, W0
00083A  400066     ADD W0, #0x6, W0
00083C  784010     MOV.B [W0], W0
00083E  E84080     INC.B W0, W1
000840  2089A0     MOV #0x89A, W0
000842  400066     ADD W0, #0x6, W0
000844  784801     MOV.B W1, [W0]
549:                           I2C1_Stop(I2C1_LOST_STATE);
000846  200060     MOV #0x6, W0
000848  070CB3     RCALL I2C1_Stop
550:                           break;
00084A  000000     NOP
00084C  370001     BRA .L3
551:               
552:                   }
553:               }
000850  FA8000     ULNK
000852  BE034F     MOV.D [--W15], W6
000854  BE024F     MOV.D [--W15], W4
000856  BE014F     MOV.D [--W15], W2
000858  BE004F     MOV.D [--W15], W0
00085A  F90036     POP RCOUNT
00085C  064000     RETFIE
554:               
555:               static void I2C1_FunctionComplete(void)
556:               {
00218E  FA0000     LNK #0x0
557:               
558:                   // update the trb pointer
559:                   p_i2c1_trb_current++;
002190  804530     MOV p_i2c1_trb_current, W0
002192  400066     ADD W0, #0x6, W0
002194  884530     MOV W0, p_i2c1_trb_current
560:               
561:                   // are we done with this string of requests?
562:                   if(--i2c1_trb_count == 0)
002196  BFC8A4     MOV.B i2c1_trb_count, WREG
002198  E94000     DEC.B W0, W0
00219A  B7E8A4     MOV.B WREG, i2c1_trb_count
00219C  BFC8A4     MOV.B i2c1_trb_count, WREG
00219E  E00400     CP0.B W0
0021A0  3A0003     BRA NZ, .L41
563:                   {
564:                       i2c1_state = S_MASTER_SEND_STOP;
0021A2  200040     MOV #0x4, W0
0021A4  884510     MOV W0, i2c1_state
0021A6  370002     BRA .L40
565:                   }
566:                   else
567:                   {
568:                       i2c1_state = S_MASTER_RESTART;
0021A8  200010     MOV #0x1, W0
0021AA  884510     MOV W0, i2c1_state
569:                   }
570:               
571:               }
0021AC  FA8000     ULNK
0021AE  060000     RETURN
572:               
573:               static void I2C1_Stop(I2C1_MESSAGE_STATUS completion_code)
574:               {
0021B0  FA0002     LNK #0x2
0021B2  780F00     MOV W0, [W14]
575:                   // then send a stop
576:                   I2C1_STOP_CONDITION_ENABLE_BIT = 1;
0021B4  A8449A     BSET I2C1CONL, #2
577:               
578:                   // make sure the flag pointer is not NULL
579:                   if (p_i2c1_current->pTrFlag != NULL)
0021B6  804540     MOV p_i2c1_current, W0
0021B8  400064     ADD W0, #0x4, W0
0021BA  780010     MOV [W0], W0
0021BC  E00000     CP0 W0
0021BE  320004     BRA Z, .L44
580:                   {
581:                       // update the flag with the completion code
582:                       *(p_i2c1_current->pTrFlag) = completion_code;
0021C0  804540     MOV p_i2c1_current, W0
0021C2  400064     ADD W0, #0x4, W0
0021C4  780010     MOV [W0], W0
0021C6  78081E     MOV [W14], [W0]
583:                   }
584:               
585:                   // Done, back to idle
586:                   i2c1_state = S_MASTER_IDLE;
0021C8  EF28A2     CLR i2c1_state
587:                   
588:               }
0021CA  FA8000     ULNK
0021CC  060000     RETURN
589:               
590:               void I2C1_MasterWrite(
591:                                               uint8_t *pdata,
592:                                               uint8_t length,
593:                                               uint16_t address,
594:                                               I2C1_MESSAGE_STATUS *pstatus)
595:               {
0021CE  FA0008     LNK #0x8
0021D0  780F00     MOV W0, [W14]
0021D2  E8800E     INC2 W14, W0
0021D4  784801     MOV.B W1, [W0]
0021D6  470064     ADD W14, #0x4, W0
0021D8  780802     MOV W2, [W0]
0021DA  470066     ADD W14, #0x6, W0
0021DC  780803     MOV W3, [W0]
596:                   static I2C1_TRANSACTION_REQUEST_BLOCK   trBlock;
597:               
598:                   // check if there is space in the queue
599:                   if (i2c1_object.trStatus.s.full != true)
0021DE  2089A0     MOV #0x89A, W0
0021E0  400064     ADD W0, #0x4, W0
0021E2  780010     MOV [W0], W0
0021E4  600061     AND W0, #0x1, W0
0021E6  E00000     CP0 W0
0021E8  3A000D     BRA NZ, .L46
600:                   {
601:                       I2C1_MasterWriteTRBBuild(&trBlock, pdata, length, address);
0021EA  470064     ADD W14, #0x4, W0
0021EC  780190     MOV [W0], W3
0021EE  E8800E     INC2 W14, W0
0021F0  784110     MOV.B [W0], W2
0021F2  78009E     MOV [W14], W1
0021F4  20D120     MOV #0xD12, W0
0021F6  070093     RCALL I2C1_MasterWriteTRBBuild
602:                       I2C1_MasterTRBInsert(1, &trBlock, pstatus);
0021F8  470066     ADD W14, #0x6, W0
0021FA  780110     MOV [W0], W2
0021FC  20D121     MOV #0xD12, W1
0021FE  B3C010     MOV.B #0x1, W0
002200  070028     RCALL I2C1_MasterTRBInsert
002202  370004     BRA .L45
603:                   }
604:                   else
605:                   {
606:                       *pstatus = I2C1_MESSAGE_FAIL;
002204  470066     ADD W14, #0x6, W0
002206  780010     MOV [W0], W0
002208  EB0080     CLR W1
00220A  780801     MOV W1, [W0]
607:                   }
608:               
609:               }                           
00220C  FA8000     ULNK
00220E  060000     RETURN
610:               
611:               void I2C1_MasterRead(
612:                                               uint8_t *pdata,
613:                                               uint8_t length,
614:                                               uint16_t address,
615:                                               I2C1_MESSAGE_STATUS *pstatus)
616:               {
002210  FA0008     LNK #0x8
002212  780F00     MOV W0, [W14]
002214  E8800E     INC2 W14, W0
002216  784801     MOV.B W1, [W0]
002218  470064     ADD W14, #0x4, W0
00221A  780802     MOV W2, [W0]
00221C  470066     ADD W14, #0x6, W0
00221E  780803     MOV W3, [W0]
617:                   static I2C1_TRANSACTION_REQUEST_BLOCK   trBlock;
618:               
619:               
620:                   // check if there is space in the queue
621:                   if (i2c1_object.trStatus.s.full != true)
002220  2089A0     MOV #0x89A, W0
002222  400064     ADD W0, #0x4, W0
002224  780010     MOV [W0], W0
002226  600061     AND W0, #0x1, W0
002228  E00000     CP0 W0
00222A  3A000D     BRA NZ, .L49
622:                   {
623:                       I2C1_MasterReadTRBBuild(&trBlock, pdata, length, address);
00222C  470064     ADD W14, #0x4, W0
00222E  780190     MOV [W0], W3
002230  E8800E     INC2 W14, W0
002232  784110     MOV.B [W0], W2
002234  78009E     MOV [W14], W1
002236  20D0C0     MOV #0xD0C, W0
002238  070054     RCALL I2C1_MasterReadTRBBuild
624:                       I2C1_MasterTRBInsert(1, &trBlock, pstatus);
00223A  470066     ADD W14, #0x6, W0
00223C  780110     MOV [W0], W2
00223E  20D0C1     MOV #0xD0C, W1
002240  B3C010     MOV.B #0x1, W0
002242  070007     RCALL I2C1_MasterTRBInsert
002244  370004     BRA .L48
625:                   }
626:                   else
627:                   {
628:                       *pstatus = I2C1_MESSAGE_FAIL;
002246  470066     ADD W14, #0x6, W0
002248  780010     MOV [W0], W0
00224A  EB0080     CLR W1
00224C  780801     MOV W1, [W0]
629:                   }
630:               
631:               }       
00224E  FA8000     ULNK
002250  060000     RETURN
632:               
633:               void I2C1_MasterTRBInsert(
634:                                               uint8_t count,
635:                                               I2C1_TRANSACTION_REQUEST_BLOCK *ptrb_list,
636:                                               I2C1_MESSAGE_STATUS *pflag)
637:               {
002252  FA0006     LNK #0x6
002254  784F00     MOV.B W0, [W14]
002256  E8800E     INC2 W14, W0
002258  780801     MOV W1, [W0]
00225A  470064     ADD W14, #0x4, W0
00225C  780802     MOV W2, [W0]
638:               
639:                   // check if there is space in the queue
640:                   if (i2c1_object.trStatus.s.full != true)
00225E  2089A0     MOV #0x89A, W0
002260  400064     ADD W0, #0x4, W0
002262  780010     MOV [W0], W0
002264  600061     AND W0, #0x1, W0
002266  E00000     CP0 W0
002268  3A0036     BRA NZ, .L52
641:                   {
642:                       *pflag = I2C1_MESSAGE_PENDING;
00226A  470064     ADD W14, #0x4, W0
00226C  780010     MOV [W0], W0
00226E  200011     MOV #0x1, W1
002270  780801     MOV W1, [W0]
643:               
644:                       i2c1_object.pTrTail->ptrb_list = ptrb_list;
002272  2089A0     MOV #0x89A, W0
002274  780010     MOV [W0], W0
002276  E88000     INC2 W0, W0
002278  E8808E     INC2 W14, W1
00227A  780811     MOV [W1], [W0]
645:                       i2c1_object.pTrTail->count     = count;
00227C  2089A0     MOV #0x89A, W0
00227E  780010     MOV [W0], W0
002280  78481E     MOV.B [W14], [W0]
646:                       i2c1_object.pTrTail->pTrFlag   = pflag;
002282  2089A0     MOV #0x89A, W0
002284  780010     MOV [W0], W0
002286  400064     ADD W0, #0x4, W0
002288  4700E4     ADD W14, #0x4, W1
00228A  780811     MOV [W1], [W0]
647:                       i2c1_object.pTrTail++;
00228C  2089A0     MOV #0x89A, W0
00228E  780010     MOV [W0], W0
002290  4000E6     ADD W0, #0x6, W1
002292  2089A0     MOV #0x89A, W0
002294  780801     MOV W1, [W0]
648:               
649:                       // check if the end of the array is reached
650:                       if (i2c1_object.pTrTail == (i2c1_tr_queue + I2C1_CONFIG_TR_QUEUE_LENGTH))
002296  2089A0     MOV #0x89A, W0
002298  780090     MOV [W0], W1
00229A  20D0C0     MOV #0xD0C, W0
00229C  508F80     SUB W1, W0, [W15]
00229E  3A0003     BRA NZ, .L53
651:                       {
652:                           // adjust to restart at the beginning of the array
653:                           i2c1_object.pTrTail = i2c1_tr_queue;
0022A0  2089A0     MOV #0x89A, W0
0022A2  20D061     MOV #0xD06, W1
0022A4  780801     MOV W1, [W0]
654:                       }
655:               
656:                       // since we added one item to be processed, we know
657:                       // it is not empty, so set the empty status to false
658:                       i2c1_object.trStatus.s.empty = false;
0022A6  2089A0     MOV #0x89A, W0
0022A8  4000E4     ADD W0, #0x4, W1
0022AA  780091     MOV [W1], W1
0022AC  A11001     BCLR W1, #1
0022AE  400064     ADD W0, #0x4, W0
0022B0  780801     MOV W1, [W0]
659:               
660:                       // check if full
661:                       if (i2c1_object.pTrHead == i2c1_object.pTrTail)
0022B2  2089A0     MOV #0x89A, W0
0022B4  E88000     INC2 W0, W0
0022B6  780090     MOV [W0], W1
0022B8  2089A0     MOV #0x89A, W0
0022BA  780010     MOV [W0], W0
0022BC  508F80     SUB W1, W0, [W15]
0022BE  3A0006     BRA NZ, .L54
662:                       {
663:                           // it is full, set the full status to true
664:                           i2c1_object.trStatus.s.full = true;
0022C0  2089A0     MOV #0x89A, W0
0022C2  4000E4     ADD W0, #0x4, W1
0022C4  780091     MOV [W1], W1
0022C6  A00001     BSET W1, #0
0022C8  400064     ADD W0, #0x4, W0
0022CA  780801     MOV W1, [W0]
665:                       }
666:               
667:                       // for interrupt based
668:                       if(i2c1_state == S_MASTER_IDLE)
0022CC  804510     MOV i2c1_state, W0
0022CE  E00000     CP0 W0
0022D0  3A0006     BRA NZ, .L51
669:                       {    
670:                           // force the task to run since we know that the queue has
671:                           // something that needs to be sent
672:                           IFS1bits.MI2C1IF = 1;
0022D2  A8208A     BSET IFS1, #1
0022D4  370004     BRA .L51
673:                       }           
674:                       
675:                   }
676:                   else
677:                   {
678:                       *pflag = I2C1_MESSAGE_FAIL;
0022D6  470064     ADD W14, #0x4, W0
0022D8  780010     MOV [W0], W0
0022DA  EB0080     CLR W1
0022DC  780801     MOV W1, [W0]
679:                   }
680:               
681:               }      
0022DE  FA8000     ULNK
0022E0  060000     RETURN
682:                                               
683:               void I2C1_MasterReadTRBBuild(
684:                                               I2C1_TRANSACTION_REQUEST_BLOCK *ptrb,
685:                                               uint8_t *pdata,
686:                                               uint8_t length,
687:                                               uint16_t address)
688:               {
0022E2  FA0008     LNK #0x8
0022E4  780F00     MOV W0, [W14]
0022E6  E8800E     INC2 W14, W0
0022E8  780801     MOV W1, [W0]
0022EA  470064     ADD W14, #0x4, W0
0022EC  784802     MOV.B W2, [W0]
0022EE  470066     ADD W14, #0x6, W0
0022F0  780803     MOV W3, [W0]
689:                   ptrb->address  = address << 1;
0022F2  470066     ADD W14, #0x6, W0
0022F4  780010     MOV [W0], W0
0022F6  400000     ADD W0, W0, W0
0022F8  780080     MOV W0, W1
0022FA  78001E     MOV [W14], W0
0022FC  780801     MOV W1, [W0]
690:                   // make this a read
691:                   ptrb->address |= 0x01;
0022FE  78001E     MOV [W14], W0
002300  780010     MOV [W0], W0
002302  780080     MOV W0, W1
002304  A00001     BSET W1, #0
002306  78001E     MOV [W14], W0
002308  780801     MOV W1, [W0]
692:                   ptrb->length   = length;
00230A  78001E     MOV [W14], W0
00230C  E88000     INC2 W0, W0
00230E  4700E4     ADD W14, #0x4, W1
002310  784811     MOV.B [W1], [W0]
693:                   ptrb->pbuffer  = pdata;
002312  78001E     MOV [W14], W0
002314  400064     ADD W0, #0x4, W0
002316  E8808E     INC2 W14, W1
002318  780811     MOV [W1], [W0]
694:               }
00231A  FA8000     ULNK
00231C  060000     RETURN
695:                                               
696:               void I2C1_MasterWriteTRBBuild(
697:                                               I2C1_TRANSACTION_REQUEST_BLOCK *ptrb,
698:                                               uint8_t *pdata,
699:                                               uint8_t length,
700:                                               uint16_t address)
701:               {
00231E  FA0008     LNK #0x8
002320  780F00     MOV W0, [W14]
002322  E8800E     INC2 W14, W0
002324  780801     MOV W1, [W0]
002326  470064     ADD W14, #0x4, W0
002328  784802     MOV.B W2, [W0]
00232A  470066     ADD W14, #0x6, W0
00232C  780803     MOV W3, [W0]
702:                   ptrb->address = address << 1;
00232E  470066     ADD W14, #0x6, W0
002330  780010     MOV [W0], W0
002332  400000     ADD W0, W0, W0
002334  780080     MOV W0, W1
002336  78001E     MOV [W14], W0
002338  780801     MOV W1, [W0]
703:                   ptrb->length  = length;
00233A  78001E     MOV [W14], W0
00233C  E88000     INC2 W0, W0
00233E  4700E4     ADD W14, #0x4, W1
002340  784811     MOV.B [W1], [W0]
704:                   ptrb->pbuffer = pdata;
002342  78001E     MOV [W14], W0
002344  400064     ADD W0, #0x4, W0
002346  E8808E     INC2 W14, W1
002348  780811     MOV [W1], [W0]
705:               }
00234A  FA8000     ULNK
00234C  060000     RETURN
706:               
707:               bool I2C1_MasterQueueIsEmpty(void)
708:               {
00234E  FA0000     LNK #0x0
709:                   return((bool)i2c1_object.trStatus.s.empty);
002350  2089A0     MOV #0x89A, W0
002352  400064     ADD W0, #0x4, W0
002354  780010     MOV [W0], W0
002356  600062     AND W0, #0x2, W0
002358  A7F000     BTSC W0, #15
00235A  EA0000     NEG W0, W0
00235C  EA0000     NEG W0, W0
00235E  DE004F     LSR W0, #15, W0
002360  784000     MOV.B W0, W0
710:               }
002362  FA8000     ULNK
002364  060000     RETURN
711:               
712:               bool I2C1_MasterQueueIsFull(void)
713:               {
002366  FA0000     LNK #0x0
714:                   return((bool)i2c1_object.trStatus.s.full);
002368  2089A0     MOV #0x89A, W0
00236A  400064     ADD W0, #0x4, W0
00236C  780010     MOV [W0], W0
00236E  600061     AND W0, #0x1, W0
002370  A7F000     BTSC W0, #15
002372  EA0000     NEG W0, W0
002374  EA0000     NEG W0, W0
002376  DE004F     LSR W0, #15, W0
002378  784000     MOV.B W0, W0
715:               }
00237A  FA8000     ULNK
00237C  060000     RETURN
716:               
717:               /**
718:                End of File
719:               */
---  E:/Users/Alex/Documents/eagle/projects/USBPD Supply/adapter/USBPD-Adapter.X/mcc_generated_files/delay.c
1:                 /**
2:                 \file
3:                 \addtogroup doc_driver_delay_code
4:                 \brief This file contains the functions to generate delays in the millisecond and microsecond ranges.
5:                 \copyright (c) 2020 Microchip Technology Inc. and its subsidiaries.
6:                 \page License
7:                     (c) 2020 Microchip Technology Inc. and its subsidiaries. You may use this
8:                     software and any derivatives exclusively with Microchip products.
9:                 
10:                    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
11:                    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
12:                    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
13:                    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
14:                    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
15:                
16:                    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
17:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
18:                    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
19:                    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
20:                    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
21:                    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
22:                    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
23:                
24:                    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
25:                    TERMS.
26:                **/
27:                
28:                
29:                #ifndef FCY
30:                #define FCY (_XTAL_FREQ/2)
31:                #endif
32:                #include "clock.h"
33:                #include <libpic30.h>
34:                #include <stdint.h>
35:                
36:                /**
37:                *  \ingroup doc_driver_delay_code
38:                *  Call this function to delay execution of the program for a certain number of milliseconds
39:                @param milliseconds - number of milliseconds to delay
40:                */
41:                void DELAY_milliseconds(uint16_t milliseconds) {
00288A  FA0002     LNK #0x2
00288C  780F00     MOV W0, [W14]
42:                    while(milliseconds--){ 
00288E  370003     BRA .L2
002896  78001E     MOV [W14], W0
002898  A7F000     BTSC W0, #15
00289A  EA0000     NEG W0, W0
00289C  EA0000     NEG W0, W0
00289E  DE004F     LSR W0, #15, W0
0028A0  784000     MOV.B W0, W0
0028A2  E90F1E     DEC [W14], [W14]
0028A4  E00400     CP0.B W0
0028A6  3AFFF4     BRA NZ, .L3
43:                        __delay_ms(1); 
002890  23E800     MOV #0x3E80, W0
002892  200001     MOV #0x0, W1
002894  070074     RCALL ___delay32, .Letext0, .LFE0
44:                    }
45:                }
0028A8  FA8000     ULNK
0028AA  060000     RETURN
46:                
47:                /**
48:                *  \ingroup doc_driver_delay_code
49:                *  Call this function to delay execution of the program for a certain number of microseconds
50:                @param microseconds - number of microseconds to delay
51:                */
52:                void DELAY_microseconds(uint16_t microseconds) {
0028AC  FA0002     LNK #0x2
0028AE  780F00     MOV W0, [W14]
53:                    while( microseconds >= 32)
0028B0  370005     BRA .L5
0028BC  78001E     MOV [W14], W0
0028BE  500FFF     SUB W0, #0x1F, [W15]
0028C0  3EFFF8     BRA GTU, .L6
54:                    {
55:                        __delay_us(32);
0028B2  202000     MOV #0x200, W0
0028B4  200001     MOV #0x0, W1
0028B6  070063     RCALL ___delay32, .Letext0, .LFE0
56:                        microseconds -= 32;
0028B8  2FFE01     MOV #0xFFE0, W1
0028BA  408F1E     ADD W1, [W14], [W14]
57:                    }
58:                    
59:                    while(microseconds--)
0028C2  370003     BRA .L7
0028CA  78001E     MOV [W14], W0
0028CC  A7F000     BTSC W0, #15
0028CE  EA0000     NEG W0, W0
0028D0  EA0000     NEG W0, W0
0028D2  DE004F     LSR W0, #15, W0
0028D4  784000     MOV.B W0, W0
0028D6  E90F1E     DEC [W14], [W14]
0028D8  E00400     CP0.B W0
0028DA  3AFFF4     BRA NZ, .L8
60:                    {
61:                        __delay_us(1);
0028C4  200100     MOV #0x10, W0
0028C6  200001     MOV #0x0, W1
0028C8  07005A     RCALL ___delay32, .Letext0, .LFE0
62:                    }
63:                }
0028DC  FA8000     ULNK
0028DE  060000     RETURN
---  E:/Users/Alex/Documents/eagle/projects/USBPD Supply/adapter/USBPD-Adapter.X/mcc_generated_files/clock.c
1:                 /**
2:                   @Generated PIC24 / dsPIC33 / PIC32MM MCUs Source File
3:                 
4:                   @Company:
5:                     Microchip Technology Inc.
6:                 
7:                   @File Name:
8:                     clock.c
9:                 
10:                  @Summary:
11:                    This is the clock.c file generated using PIC24 / dsPIC33 / PIC32MM MCUs
12:                
13:                  @Description:
14:                    This header file provides implementations for driver APIs for all modules selected in the GUI.
15:                    Generation Information :
16:                        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - 1.171.1
17:                        Device            :  PIC24FJ128GA702
18:                    The generated drivers are tested against the following:
19:                        Compiler          :  XC16 v1.70
20:                        MPLAB             :  MPLAB X v5.50
21:                */
22:                
23:                /*
24:                    (c) 2020 Microchip Technology Inc. and its subsidiaries. You may use this
25:                    software and any derivatives exclusively with Microchip products.
26:                
27:                    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:                    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:                    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:                    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
31:                    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
32:                
33:                    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:                    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:                    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:                    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:                    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:                
41:                    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
42:                    TERMS.
43:                */
44:                
45:                #include <stdint.h>
46:                #include "xc.h"
47:                #include "clock.h"
48:                
49:                void CLOCK_Initialize(void)
50:                {
00282E  FA0000     LNK #0x0
51:                    // CPDIV 1:1; PLLEN disabled; DOZE 1:8; RCDIV FRC; DOZEN disabled; ROI disabled; 
52:                    CLKDIV = 0x3000;
002830  230000     MOV #0x3000, W0
002832  880810     MOV W0, CLKDIV
53:                    // STOR disabled; STORPOL Interrupt when STOR is 1; STSIDL disabled; STLPOL Interrupt when STLOCK is 1; STLOCK disabled; STSRC SOSC; STEN disabled; TUN Center frequency; 
54:                    OSCTUN = 0x00;
002834  EF2106     CLR OSCTUN
55:                    // ROEN disabled; ROSWEN disabled; ROSEL FOSC; ROOUT disabled; ROSIDL disabled; ROSLP disabled; 
56:                    REFOCONL = 0x00;
002836  EF2168     CLR REFOCONL
57:                    // RODIV 0; 
58:                    REFOCONH = 0x00;
002838  EF216A     CLR REFOCONH
59:                    // DCOTUN 0; 
60:                    DCOTUN = 0x00;
00283A  EF2108     CLR DCOTUN
61:                    // DCOFSEL 8; DCOEN disabled; 
62:                    DCOCON = 0x700;
00283C  207000     MOV #0x700, W0
00283E  880850     MOV W0, DCOCON
63:                    // DIV 0; 
64:                    OSCDIV = 0x00;
002840  EF210C     CLR OSCDIV
65:                    // TRIM 0; 
66:                    OSCFDIV = 0x00;
002842  EF210E     CLR OSCFDIV
67:                    // AD1MD enabled; T3MD enabled; T1MD enabled; U2MD enabled; T2MD enabled; U1MD enabled; SPI2MD enabled; SPI1MD enabled; I2C1MD enabled; 
68:                    PMD1 = 0x00;
002844  EF2178     CLR PMD1
69:                    // IC3MD enabled; OC1MD enabled; IC2MD enabled; OC2MD enabled; IC1MD enabled; OC3MD enabled; 
70:                    PMD2 = 0x00;
002846  EF217A     CLR PMD2
71:                    // PMPMD enabled; RTCCMD enabled; CMPMD enabled; CRCMD enabled; I2C2MD enabled; 
72:                    PMD3 = 0x00;
002848  EF217C     CLR PMD3
73:                    // CTMUMD enabled; REFOMD enabled; LVDMD enabled; 
74:                    PMD4 = 0x00;
00284A  EF217E     CLR PMD4
75:                    // CCP2MD enabled; CCP1MD enabled; CCP4MD enabled; CCP3MD enabled; CCP5MD enabled; 
76:                    PMD5 = 0x00;
00284C  EF2180     CLR PMD5
77:                    // SPI3MD enabled; 
78:                    PMD6 = 0x00;
00284E  EF2182     CLR PMD6
79:                    // DMA1MD enabled; DMA0MD enabled; 
80:                    PMD7 = 0x00;
002850  EF2184     CLR PMD7
81:                    // CLC1MD enabled; CLC2MD enabled; 
82:                    PMD8 = 0x00;
002852  EF2186     CLR PMD8
83:                    // CF no clock failure; NOSC FRCPLL; SOSCEN disabled; POSCEN disabled; CLKLOCK unlocked; OSWEN Switch is Complete; IOLOCK not-active; 
84:                    __builtin_write_OSCCONH((uint8_t) (0x01));
002854  200012     MOV #0x1, W2
002856  200780     MOV #0x78, W0
002858  2009A1     MOV #0x9A, W1
00285A  201013     MOV #0x101, W3
00285C  784980     MOV.B W0, [W3]
00285E  784981     MOV.B W1, [W3]
002860  784982     MOV.B W2, [W3]
85:                    __builtin_write_OSCCONL((uint8_t) (0x01));
002862  200012     MOV #0x1, W2
002864  200460     MOV #0x46, W0
002866  200571     MOV #0x57, W1
002868  201003     MOV #0x100, W3
00286A  784980     MOV.B W0, [W3]
00286C  784981     MOV.B W1, [W3]
00286E  784982     MOV.B W2, [W3]
86:                    // Wait for Clock switch to occur
87:                    while (OSCCONbits.OSWEN != 0);
002870  000000     NOP
002872  800800     MOV OSCCON, W0
002874  600061     AND W0, #0x1, W0
002876  E00000     CP0 W0
002878  3AFFFC     BRA NZ, .L2
88:                    while (OSCCONbits.LOCK != 1);
00287A  000000     NOP
00287C  800801     MOV OSCCON, W1
00287E  200200     MOV #0x20, W0
002880  608000     AND W1, W0, W0
002882  E00000     CP0 W0
002884  32FFFB     BRA Z, .L3
89:                }
002886  FA8000     ULNK
002888  060000     RETURN
---  E:/Users/Alex/Documents/eagle/projects/USBPD Supply/adapter/USBPD-Adapter.X/main.c  ----------------
1:                 /**
2:                   Generated main.c file from MPLAB Code Configurator
3:                 
4:                   @Company
5:                     Microchip Technology Inc.
6:                 
7:                   @File Name
8:                     main.c
9:                 
10:                  @Summary
11:                    This is the generated main.c using PIC24 / dsPIC33 / PIC32MM MCUs.
12:                
13:                  @Description
14:                    This source file provides main entry point for system initialization and application code development.
15:                    Generation Information :
16:                        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - 1.171.1
17:                        Device            :  PIC24FJ128GA702
18:                    The generated drivers are tested against the following:
19:                        Compiler          :  XC16 v1.70
20:                        MPLAB 	          :  MPLAB X v5.50
21:                */
22:                
23:                /*
24:                    (c) 2020 Microchip Technology Inc. and its subsidiaries. You may use this
25:                    software and any derivatives exclusively with Microchip products.
26:                
27:                    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:                    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:                    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:                    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
31:                    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
32:                
33:                    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:                    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:                    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:                    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:                    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:                
41:                    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
42:                    TERMS.
43:                */
44:                
45:                /**
46:                  Section: Included Files
47:                */
48:                #include "mcc_generated_files/system.h"
49:                #include "oled.h"
50:                #include "util.h"
51:                #include "ui.h"
52:                
53:                
54:                #define SCREEN_UPDATE_PERIOD 100000
55:                
56:                
57:                static uint64_t last_screen_update = 0;
58:                
59:                
60:                static void _halt_error() {
002750  FA0000     LNK #0x0
002752  DA4000     BREAK
61:                    #ifdef __DEBUG    
62:                        __builtin_software_breakpoint();
63:                    #endif
64:                    while(1);
002754  37FFFF     BRA .L2
65:                }
66:                
67:                
68:                /*
69:                                         Main application
70:                 */
71:                int main(void) {
002756  FA0002     LNK #0x2
002758  BE9F88     MOV.D W8, [W15++]
00275A  BE9F8A     MOV.D W10, [W15++]
72:                    // initialize the device
73:                    SYSTEM_Initialize();
00275C  07012B     RCALL SYSTEM_Initialize
74:                
75:                    UI_Initialize();
00275E  07FB41     RCALL UI_Initialize
76:                    
77:                    bool init_success = false;
002760  EB4000     CLR.B W0
002762  784F00     MOV.B W0, [W14]
78:                    uint8_t i;
79:                    for (i = 0; i < 10; i++) {
002764  EB4080     CLR.B W1
002766  E8000E     INC W14, W0
002768  784801     MOV.B W1, [W0]
00276A  37000B     BRA .L4
002778  E8000E     INC W14, W0
00277A  784010     MOV.B [W0], W0
00277C  E84080     INC.B W0, W1
00277E  E8000E     INC W14, W0
002780  784801     MOV.B W1, [W0]
002782  E8000E     INC W14, W0
002784  784010     MOV.B [W0], W0
002786  504FE9     SUB.B W0, #0x9, [W15]
002788  36FFF1     BRA LEU, .L7
80:                        if (OLED_Initialize()) {
00276C  07F7CF     RCALL OLED_Initialize
00276E  E00400     CP0.B W0
002770  320003     BRA Z, .L5
81:                            init_success = true;
002772  B3C010     MOV.B #0x1, W0
002774  784F00     MOV.B W0, [W14]
82:                            break;
002776  370009     BRA .L6
83:                        }
84:                    }
85:                    if (!init_success) _halt_error();
00278A  78401E     MOV.B [W14], W0
00278C  A20400     BTG.B W0, #0
00278E  E00400     CP0.B W0
002790  320003     BRA Z, .L8
002792  07FFDE     RCALL _halt_error
002794  370001     BRA .L8
86:                
87:                    while (1) {
88:                        UTIL_UpdateCurrentTime();
002798  0700C5     RCALL UTIL_UpdateCurrentTime
89:                        
90:                        UI_Tasks();
00279A  07FB52     RCALL UI_Tasks
91:                        
92:                        if (util_currentTimeMicroseconds - last_screen_update >= SCREEN_UPDATE_PERIOD) {
00279C  208C20     MOV #0x8C2, W0
00279E  BE0430     MOV.D [W0++], W8
0027A0  BE0520     MOV.D [W0--], W10
0027A2  208B20     MOV #0x8B2, W0
0027A4  BE0150     MOV.D [++W0], W2
0027A6  BE0040     MOV.D [--W0], W0
0027A8  540200     SUB W8, W0, W4
0027AA  5C8281     SUBB W9, W1, W5
0027AC  5D0302     SUBB W10, W2, W6
0027AE  5D8383     SUBB W11, W3, W7
0027B0  2869F0     MOV #0x869F, W0
0027B2  200011     MOV #0x1, W1
0027B4  B81160     MUL.UU W2, #0, W2
0027B6  E12000     CP.W W4, W0
0027B8  E1A801     CPB.W W5, W1
0027BA  E1B002     CPB.W W6, W2
0027BC  E1B803     CPB.W W7, W3
0027BE  36FFEB     BRA LEU, .L10
93:                            last_screen_update = util_currentTimeMicroseconds;
0027C0  208C20     MOV #0x8C2, W0
0027C2  BE0150     MOV.D [++W0], W2
0027C4  BE0040     MOV.D [--W0], W0
0027C6  208B24     MOV #0x8B2, W4
0027C8  BE9A00     MOV.D W0, [W4++]
0027CA  BE9202     MOV.D W2, [W4--]
94:                            OLED_UpdateScreen();
0027CC  07F768     RCALL OLED_UpdateScreen
95:                        }
96:                    }
002796  000000     NOP
0027CE  37FFE4     BRA .L8
97:                
98:                    return 1;
99:                }
100:               /**
101:                End of File
102:               */
103:               
---  E:/Users/Alex/Documents/eagle/projects/USBPD Supply/adapter/USBPD-Adapter.X/i2c_blocking.c  --------
1:                 #include "i2c_blocking.h"
2:                 #include "mcc_generated_files/delay.h"
3:                 
4:                 #define _I2CB_RETRY_MAX       10  // define the retry count
5:                 #define _I2CB_DEVICE_TIMEOUT  50   // define slave timeout
6:                 
7:                 
8:                 const I2CB_INSTANCE I2CB_I2C1 = {
9:                     &I2C1_MasterWrite,
10:                    &I2C1_MasterRead,
11:                    &I2C1_MasterTRBInsert,
12:                    &I2C1_MasterReadTRBBuild,
13:                    &I2C1_MasterWriteTRBBuild
14:                };
15:                
16:                const I2CB_INSTANCE I2CB_I2C2 = {
17:                    &I2C2_MasterWrite,
18:                    &I2C2_MasterRead,
19:                    &I2C2_MasterTRBInsert,
20:                    &I2C2_MasterReadTRBBuild,
21:                    &I2C2_MasterWriteTRBBuild
22:                };
23:                
24:                
25:                bool I2CB_Write(I2CB_INSTANCE instance, uint16_t address, uint8_t* data, uint8_t length) {
001720  FA0016     LNK #0x16
001722  781F88     MOV W8, [W15++]
001724  470466     ADD W14, #0x6, W8
001726  780C00     MOV W0, [W8]
001728  470068     ADD W14, #0x8, W0
00172A  780801     MOV W1, [W0]
00172C  47006A     ADD W14, #0xA, W0
00172E  780802     MOV W2, [W0]
001730  47006C     ADD W14, #0xC, W0
001732  780803     MOV W3, [W0]
001734  47006E     ADD W14, #0xE, W0
001736  780804     MOV W4, [W0]
001738  470070     ADD W14, #0x10, W0
00173A  780805     MOV W5, [W0]
00173C  470072     ADD W14, #0x12, W0
00173E  780806     MOV W6, [W0]
001740  470074     ADD W14, #0x14, W0
001742  784807     MOV.B W7, [W0]
26:                    I2CB_MESSAGE_STATUS status = I2C1_MESSAGE_PENDING;
001744  200011     MOV #0x1, W1
001746  470064     ADD W14, #0x4, W0
001748  780801     MOV W1, [W0]
27:                    uint16_t retryTimeOut, slaveTimeOut;
28:                    
29:                    retryTimeOut = 0;
00174A  EB0000     CLR W0
00174C  780F00     MOV W0, [W14]
30:                    slaveTimeOut = 0;
00174E  EB0080     CLR W1
001750  E8800E     INC2 W14, W0
001752  780801     MOV W1, [W0]
31:                
32:                    while (status != I2C1_MESSAGE_FAIL) {
001754  370026     BRA .L2
0017A2  470064     ADD W14, #0x4, W0
0017A4  780010     MOV [W0], W0
0017A6  E00000     CP0 W0
0017A8  3AFFD6     BRA NZ, .L10
0017AA  370003     BRA .L8
33:                        instance.write(data, length, address, &status);
001756  470066     ADD W14, #0x6, W0
001758  780210     MOV [W0], W4
00175A  470064     ADD W14, #0x4, W0
00175C  780180     MOV W0, W3
00175E  470070     ADD W14, #0x10, W0
001760  780110     MOV [W0], W2
001762  470074     ADD W14, #0x14, W0
001764  784090     MOV.B [W0], W1
001766  470072     ADD W14, #0x12, W0
001768  780010     MOV [W0], W0
00176A  010004     CALL W4
34:                
35:                        while(status == I2C1_MESSAGE_PENDING) {
00176C  37000E     BRA .L3
00178A  470064     ADD W14, #0x4, W0
00178C  780010     MOV [W0], W0
00178E  500FE1     SUB W0, #0x1, [W15]
001790  32FFEE     BRA Z, .L6
36:                            DELAY_microseconds(500);
00176E  201F40     MOV #0x1F4, W0
001770  07089D     RCALL DELAY_microseconds
37:                            
38:                            if (slaveTimeOut == _I2CB_DEVICE_TIMEOUT) return false;
001772  E8800E     INC2 W14, W0
001774  780090     MOV [W0], W1
001776  200320     MOV #0x32, W0
001778  508F80     SUB W1, W0, [W15]
00177A  3A0002     BRA NZ, .L4
00177C  EB4000     CLR.B W0
00177E  370021     BRA .L5
39:                            else slaveTimeOut++;
001780  E8800E     INC2 W14, W0
001782  780010     MOV [W0], W0
001784  E80080     INC W0, W1
001786  E8800E     INC2 W14, W0
001788  780801     MOV W1, [W0]
40:                        }
41:                
42:                        if (status == I2C1_MESSAGE_COMPLETE) break;
001792  470064     ADD W14, #0x4, W0
001794  780010     MOV [W0], W0
001796  500FE2     SUB W0, #0x2, [W15]
001798  320009     BRA Z, .L11
0017AC  000000     NOP
0017AE  370001     BRA .L8
43:                
44:                        if (retryTimeOut == _I2CB_RETRY_MAX) break;
00179A  78001E     MOV [W14], W0
00179C  500FEA     SUB W0, #0xA, [W15]
00179E  320008     BRA Z, .L12
0017B0  000000     NOP
45:                        else retryTimeOut++;
0017A0  E80F1E     INC [W14], [W14]
46:                    }
47:                
48:                    return status == I2C1_MESSAGE_COMPLETE;
0017B2  470064     ADD W14, #0x4, W0
0017B4  780010     MOV [W0], W0
0017B6  A21000     BTG W0, #1
0017B8  A7F000     BTSC W0, #15
0017BA  EA0000     NEG W0, W0
0017BC  E90000     DEC W0, W0
0017BE  DE004F     LSR W0, #15, W0
0017C0  784000     MOV.B W0, W0
49:                }
0017C2  78044F     MOV [--W15], W8
0017C4  FA8000     ULNK
0017C6  060000     RETURN
50:                
51:                bool I2CB_Write8(I2CB_INSTANCE instance, uint16_t address, uint8_t data) {
0017C8  FA000E     LNK #0xE
0017CA  780F00     MOV W0, [W14]
0017CC  E8800E     INC2 W14, W0
0017CE  780801     MOV W1, [W0]
0017D0  470064     ADD W14, #0x4, W0
0017D2  780802     MOV W2, [W0]
0017D4  470066     ADD W14, #0x6, W0
0017D6  780803     MOV W3, [W0]
0017D8  470068     ADD W14, #0x8, W0
0017DA  780804     MOV W4, [W0]
0017DC  47006A     ADD W14, #0xA, W0
0017DE  780805     MOV W5, [W0]
0017E0  47006C     ADD W14, #0xC, W0
0017E2  784806     MOV.B W6, [W0]
52:                    return I2CB_Write(instance, address, &data, 1);
0017E4  47006C     ADD W14, #0xC, W0
0017E6  B3C017     MOV.B #0x1, W7
0017E8  780300     MOV W0, W6
0017EA  47006A     ADD W14, #0xA, W0
0017EC  780290     MOV [W0], W5
0017EE  78001E     MOV [W14], W0
0017F0  E8808E     INC2 W14, W1
0017F2  780091     MOV [W1], W1
0017F4  470164     ADD W14, #0x4, W2
0017F6  780112     MOV [W2], W2
0017F8  4701E6     ADD W14, #0x6, W3
0017FA  780193     MOV [W3], W3
0017FC  470268     ADD W14, #0x8, W4
0017FE  780214     MOV [W4], W4
001800  07FF8F     RCALL I2CB_Write
53:                }
001802  FA8000     ULNK
001804  060000     RETURN
54:                
55:                bool I2CB_Write16(I2CB_INSTANCE instance, uint16_t address, uint16_t data) {
001806  FA000E     LNK #0xE
001808  780F00     MOV W0, [W14]
00180A  E8800E     INC2 W14, W0
00180C  780801     MOV W1, [W0]
00180E  470064     ADD W14, #0x4, W0
001810  780802     MOV W2, [W0]
001812  470066     ADD W14, #0x6, W0
001814  780803     MOV W3, [W0]
001816  470068     ADD W14, #0x8, W0
001818  780804     MOV W4, [W0]
00181A  47006A     ADD W14, #0xA, W0
00181C  780805     MOV W5, [W0]
00181E  47006C     ADD W14, #0xC, W0
001820  780806     MOV W6, [W0]
56:                    return I2CB_Write(instance, address, (uint8_t*)&data, 2);
001822  47006C     ADD W14, #0xC, W0
001824  B3C027     MOV.B #0x2, W7
001826  780300     MOV W0, W6
001828  47006A     ADD W14, #0xA, W0
00182A  780290     MOV [W0], W5
00182C  78001E     MOV [W14], W0
00182E  E8808E     INC2 W14, W1
001830  780091     MOV [W1], W1
001832  470164     ADD W14, #0x4, W2
001834  780112     MOV [W2], W2
001836  4701E6     ADD W14, #0x6, W3
001838  780193     MOV [W3], W3
00183A  470268     ADD W14, #0x8, W4
00183C  780214     MOV [W4], W4
00183E  07FF70     RCALL I2CB_Write
57:                }
001840  FA8000     ULNK
001842  060000     RETURN
58:                
59:                bool I2CB_Write32(I2CB_INSTANCE instance, uint16_t address, uint32_t data) {
001844  FA0010     LNK #0x10
001846  780F00     MOV W0, [W14]
001848  E8800E     INC2 W14, W0
00184A  780801     MOV W1, [W0]
00184C  470064     ADD W14, #0x4, W0
00184E  780802     MOV W2, [W0]
001850  470066     ADD W14, #0x6, W0
001852  780803     MOV W3, [W0]
001854  470068     ADD W14, #0x8, W0
001856  780804     MOV W4, [W0]
001858  47006A     ADD W14, #0xA, W0
00185A  780805     MOV W5, [W0]
00185C  47006C     ADD W14, #0xC, W0
00185E  BE8806     MOV.D W6, [W0]
60:                    return I2CB_Write(instance, address, (uint8_t*)&data, 4);
001860  47006C     ADD W14, #0xC, W0
001862  B3C047     MOV.B #0x4, W7
001864  780300     MOV W0, W6
001866  47006A     ADD W14, #0xA, W0
001868  780290     MOV [W0], W5
00186A  78001E     MOV [W14], W0
00186C  E8808E     INC2 W14, W1
00186E  780091     MOV [W1], W1
001870  470164     ADD W14, #0x4, W2
001872  780112     MOV [W2], W2
001874  4701E6     ADD W14, #0x6, W3
001876  780193     MOV [W3], W3
001878  470268     ADD W14, #0x8, W4
00187A  780214     MOV [W4], W4
00187C  07FF51     RCALL I2CB_Write
61:                }
00187E  FA8000     ULNK
001880  060000     RETURN
62:                
63:                
64:                bool I2CB_Read(I2CB_INSTANCE instance, uint16_t address, uint8_t* data, uint8_t length) {
001882  FA0016     LNK #0x16
001884  781F88     MOV W8, [W15++]
001886  470466     ADD W14, #0x6, W8
001888  780C00     MOV W0, [W8]
00188A  470068     ADD W14, #0x8, W0
00188C  780801     MOV W1, [W0]
00188E  47006A     ADD W14, #0xA, W0
001890  780802     MOV W2, [W0]
001892  47006C     ADD W14, #0xC, W0
001894  780803     MOV W3, [W0]
001896  47006E     ADD W14, #0xE, W0
001898  780804     MOV W4, [W0]
00189A  470070     ADD W14, #0x10, W0
00189C  780805     MOV W5, [W0]
00189E  470072     ADD W14, #0x12, W0
0018A0  780806     MOV W6, [W0]
0018A2  470074     ADD W14, #0x14, W0
0018A4  784807     MOV.B W7, [W0]
65:                    I2CB_MESSAGE_STATUS status = I2C1_MESSAGE_PENDING;
0018A6  200011     MOV #0x1, W1
0018A8  470064     ADD W14, #0x4, W0
0018AA  780801     MOV W1, [W0]
66:                    uint16_t retryTimeOut, slaveTimeOut;
67:                    
68:                    retryTimeOut = 0;
0018AC  EB0000     CLR W0
0018AE  780F00     MOV W0, [W14]
69:                    slaveTimeOut = 0;
0018B0  EB0080     CLR W1
0018B2  E8800E     INC2 W14, W0
0018B4  780801     MOV W1, [W0]
70:                
71:                    while (status != I2C1_MESSAGE_FAIL) {
0018B6  370026     BRA .L17
001904  470064     ADD W14, #0x4, W0
001906  780010     MOV [W0], W0
001908  E00000     CP0 W0
00190A  3AFFD6     BRA NZ, .L25
00190C  370003     BRA .L23
72:                        instance.read(data, length, address, &status);
0018B8  470068     ADD W14, #0x8, W0
0018BA  780210     MOV [W0], W4
0018BC  470064     ADD W14, #0x4, W0
0018BE  780180     MOV W0, W3
0018C0  470070     ADD W14, #0x10, W0
0018C2  780110     MOV [W0], W2
0018C4  470074     ADD W14, #0x14, W0
0018C6  784090     MOV.B [W0], W1
0018C8  470072     ADD W14, #0x12, W0
0018CA  780010     MOV [W0], W0
0018CC  010004     CALL W4
73:                
74:                        while(status == I2C1_MESSAGE_PENDING) {
0018CE  37000E     BRA .L18
0018EC  470064     ADD W14, #0x4, W0
0018EE  780010     MOV [W0], W0
0018F0  500FE1     SUB W0, #0x1, [W15]
0018F2  32FFEE     BRA Z, .L21
75:                            DELAY_microseconds(500);
0018D0  201F40     MOV #0x1F4, W0
0018D2  0707EC     RCALL DELAY_microseconds
76:                            
77:                            if (slaveTimeOut == _I2CB_DEVICE_TIMEOUT) return false;
0018D4  E8800E     INC2 W14, W0
0018D6  780090     MOV [W0], W1
0018D8  200320     MOV #0x32, W0
0018DA  508F80     SUB W1, W0, [W15]
0018DC  3A0002     BRA NZ, .L19
0018DE  EB4000     CLR.B W0
0018E0  370021     BRA .L20
78:                            else slaveTimeOut++;
0018E2  E8800E     INC2 W14, W0
0018E4  780010     MOV [W0], W0
0018E6  E80080     INC W0, W1
0018E8  E8800E     INC2 W14, W0
0018EA  780801     MOV W1, [W0]
79:                        }
80:                
81:                        if (status == I2C1_MESSAGE_COMPLETE) break;
0018F4  470064     ADD W14, #0x4, W0
0018F6  780010     MOV [W0], W0
0018F8  500FE2     SUB W0, #0x2, [W15]
0018FA  320009     BRA Z, .L26
00190E  000000     NOP
001910  370001     BRA .L23
82:                
83:                        if (retryTimeOut == _I2CB_RETRY_MAX) break;
0018FC  78001E     MOV [W14], W0
0018FE  500FEA     SUB W0, #0xA, [W15]
001900  320008     BRA Z, .L27
001912  000000     NOP
84:                        else retryTimeOut++;
001902  E80F1E     INC [W14], [W14]
85:                    }
86:                
87:                    return status == I2C1_MESSAGE_COMPLETE;
001914  470064     ADD W14, #0x4, W0
001916  780010     MOV [W0], W0
001918  A21000     BTG W0, #1
00191A  A7F000     BTSC W0, #15
00191C  EA0000     NEG W0, W0
00191E  E90000     DEC W0, W0
001920  DE004F     LSR W0, #15, W0
001922  784000     MOV.B W0, W0
88:                }
001924  78044F     MOV [--W15], W8
001926  FA8000     ULNK
001928  060000     RETURN
89:                
90:                int16_t I2CB_Read8(I2CB_INSTANCE instance, uint16_t address) {
00192A  FA000E     LNK #0xE
00192C  E8830E     INC2 W14, W6
00192E  780B00     MOV W0, [W6]
001930  470064     ADD W14, #0x4, W0
001932  780801     MOV W1, [W0]
001934  470066     ADD W14, #0x6, W0
001936  780802     MOV W2, [W0]
001938  470068     ADD W14, #0x8, W0
00193A  780803     MOV W3, [W0]
00193C  47006A     ADD W14, #0xA, W0
00193E  780804     MOV W4, [W0]
001940  47006C     ADD W14, #0xC, W0
001942  780805     MOV W5, [W0]
91:                    int16_t res = 0;
001944  EB0000     CLR W0
001946  780F00     MOV W0, [W14]
92:                    if (!I2CB_Read(instance, address, (uint8_t*)&res, 1)) res = -1;
001948  78000E     MOV W14, W0
00194A  B3C017     MOV.B #0x1, W7
00194C  780300     MOV W0, W6
00194E  47006C     ADD W14, #0xC, W0
001950  780290     MOV [W0], W5
001952  E8800E     INC2 W14, W0
001954  780010     MOV [W0], W0
001956  4700E4     ADD W14, #0x4, W1
001958  780091     MOV [W1], W1
00195A  470166     ADD W14, #0x6, W2
00195C  780112     MOV [W2], W2
00195E  4701E8     ADD W14, #0x8, W3
001960  780193     MOV [W3], W3
001962  47026A     ADD W14, #0xA, W4
001964  780214     MOV [W4], W4
001966  07FF8D     RCALL I2CB_Read
001968  A20400     BTG.B W0, #0
00196A  E00400     CP0.B W0
00196C  320002     BRA Z, .L29
00196E  EB8000     SETM W0
001970  780F00     MOV W0, [W14]
93:                    return res;
001972  78001E     MOV [W14], W0
94:                }
001974  FA8000     ULNK
001976  060000     RETURN
95:                
96:                int32_t I2CB_Read16(I2CB_INSTANCE instance, uint16_t address) {
001978  FA0010     LNK #0x10
00197A  470364     ADD W14, #0x4, W6
00197C  780B00     MOV W0, [W6]
00197E  470066     ADD W14, #0x6, W0
001980  780801     MOV W1, [W0]
001982  470068     ADD W14, #0x8, W0
001984  780802     MOV W2, [W0]
001986  47006A     ADD W14, #0xA, W0
001988  780803     MOV W3, [W0]
00198A  47006C     ADD W14, #0xC, W0
00198C  780804     MOV W4, [W0]
00198E  47006E     ADD W14, #0xE, W0
001990  780805     MOV W5, [W0]
97:                    int32_t res = 0;
001992  B80060     MUL.UU W0, #0, W0
001994  BE8F00     MOV.D W0, [W14]
98:                    if (!I2CB_Read(instance, address, (uint8_t*)&res, 2)) res = -1;
001996  78000E     MOV W14, W0
001998  B3C027     MOV.B #0x2, W7
00199A  780300     MOV W0, W6
00199C  47006E     ADD W14, #0xE, W0
00199E  780290     MOV [W0], W5
0019A0  470064     ADD W14, #0x4, W0
0019A2  780010     MOV [W0], W0
0019A4  4700E6     ADD W14, #0x6, W1
0019A6  780091     MOV [W1], W1
0019A8  470168     ADD W14, #0x8, W2
0019AA  780112     MOV [W2], W2
0019AC  4701EA     ADD W14, #0xA, W3
0019AE  780193     MOV [W3], W3
0019B0  47026C     ADD W14, #0xC, W4
0019B2  780214     MOV [W4], W4
0019B4  07FF66     RCALL I2CB_Read
0019B6  A20400     BTG.B W0, #0
0019B8  E00400     CP0.B W0
0019BA  320003     BRA Z, .L31
0019BC  EB8000     SETM W0
0019BE  EB8080     SETM W1
0019C0  BE8F00     MOV.D W0, [W14]
99:                    return res;
0019C2  BE001E     MOV.D [W14], W0
100:               }
0019C4  FA8000     ULNK
0019C6  060000     RETURN
101:               
102:               int64_t I2CB_Read32(I2CB_INSTANCE instance, uint16_t address) {
0019C8  FA0014     LNK #0x14
0019CA  470368     ADD W14, #0x8, W6
0019CC  780B00     MOV W0, [W6]
0019CE  47006A     ADD W14, #0xA, W0
0019D0  780801     MOV W1, [W0]
0019D2  47006C     ADD W14, #0xC, W0
0019D4  780802     MOV W2, [W0]
0019D6  47006E     ADD W14, #0xE, W0
0019D8  780803     MOV W3, [W0]
0019DA  470070     ADD W14, #0x10, W0
0019DC  780804     MOV W4, [W0]
0019DE  470072     ADD W14, #0x12, W0
0019E0  780805     MOV W5, [W0]
103:                   int64_t res = 0;
0019E2  B80060     MUL.UU W0, #0, W0
0019E4  B81160     MUL.UU W2, #0, W2
0019E6  BE9F00     MOV.D W0, [W14++]
0019E8  BE9702     MOV.D W2, [W14--]
104:                   if (!I2CB_Read(instance, address, (uint8_t*)&res, 4)) res = -1;
0019EA  78000E     MOV W14, W0
0019EC  B3C047     MOV.B #0x4, W7
0019EE  780300     MOV W0, W6
0019F0  470072     ADD W14, #0x12, W0
0019F2  780290     MOV [W0], W5
0019F4  470068     ADD W14, #0x8, W0
0019F6  780010     MOV [W0], W0
0019F8  4700EA     ADD W14, #0xA, W1
0019FA  780091     MOV [W1], W1
0019FC  47016C     ADD W14, #0xC, W2
0019FE  780112     MOV [W2], W2
001A00  4701EE     ADD W14, #0xE, W3
001A02  780193     MOV [W3], W3
001A04  470270     ADD W14, #0x10, W4
001A06  780214     MOV [W4], W4
001A08  07FF3C     RCALL I2CB_Read
001A0A  A20400     BTG.B W0, #0
001A0C  E00400     CP0.B W0
001A0E  320005     BRA Z, .L33
001A10  2FFFF0     MOV #0xFFFF, W0
001A12  2FFFF1     MOV #0xFFFF, W1
001A14  BE0100     MOV.D W0, W2
001A16  BE9F00     MOV.D W0, [W14++]
001A18  BE9702     MOV.D W2, [W14--]
105:                   return res;
001A1A  BE003E     MOV.D [W14++], W0
001A1C  BE012E     MOV.D [W14--], W2
106:               }
001A1E  FA8000     ULNK
001A20  060000     RETURN
107:               
108:               bool I2CB_CmdRead(I2CB_INSTANCE instance, uint16_t address, uint8_t command, uint8_t* data, uint8_t length) {
001A22  FA0022     LNK #0x22
001A24  781F88     MOV W8, [W15++]
001A26  470472     ADD W14, #0x12, W8
001A28  780C00     MOV W0, [W8]
001A2A  470074     ADD W14, #0x14, W0
001A2C  780801     MOV W1, [W0]
001A2E  470076     ADD W14, #0x16, W0
001A30  780802     MOV W2, [W0]
001A32  470078     ADD W14, #0x18, W0
001A34  780803     MOV W3, [W0]
001A36  47007A     ADD W14, #0x1A, W0
001A38  780804     MOV W4, [W0]
001A3A  47007C     ADD W14, #0x1C, W0
001A3C  780805     MOV W5, [W0]
001A3E  47007E     ADD W14, #0x1E, W0
001A40  784806     MOV.B W6, [W0]
001A42  200200     MOV #0x20, W0
001A44  40000E     ADD W0, W14, W0
001A46  780807     MOV W7, [W0]
109:                   I2CB_MESSAGE_STATUS status = I2C1_MESSAGE_PENDING;
001A48  200011     MOV #0x1, W1
001A4A  470064     ADD W14, #0x4, W0
001A4C  780801     MOV W1, [W0]
110:                   I2CB_TRANSACTION_REQUEST_BLOCK trb[2];
111:                   uint16_t retryTimeOut, slaveTimeOut;
112:                   
113:                   retryTimeOut = 0;
001A4E  EB0000     CLR W0
001A50  780F00     MOV W0, [W14]
114:                   slaveTimeOut = 0;
001A52  EB0080     CLR W1
001A54  E8800E     INC2 W14, W0
001A56  780801     MOV W1, [W0]
115:                   
116:                   instance.writeTrbBuild(trb, &command, 1, address);
001A58  47007A     ADD W14, #0x1A, W0
001A5A  780210     MOV [W0], W4
001A5C  4700FE     ADD W14, #0x1E, W1
001A5E  470066     ADD W14, #0x6, W0
001A60  47017C     ADD W14, #0x1C, W2
001A62  780192     MOV [W2], W3
001A64  B3C012     MOV.B #0x1, W2
001A66  010004     CALL W4
117:                   instance.readTrbBuild(trb + 1, data, length, address);
001A68  470078     ADD W14, #0x18, W0
001A6A  780210     MOV [W0], W4
001A6C  470066     ADD W14, #0x6, W0
001A6E  400066     ADD W0, #0x6, W0
001A70  4700FC     ADD W14, #0x1C, W1
001A72  780191     MOV [W1], W3
001A74  5700E8     SUB W14, #0x8, W1
001A76  784111     MOV.B [W1], W2
001A78  200201     MOV #0x20, W1
001A7A  40808E     ADD W1, W14, W1
001A7C  780091     MOV [W1], W1
001A7E  010004     CALL W4
118:               
119:                   while (status != I2C1_MESSAGE_FAIL) {
001A80  370023     BRA .L35
001AC8  470064     ADD W14, #0x4, W0
001ACA  780010     MOV [W0], W0
001ACC  E00000     CP0 W0
001ACE  3AFFD9     BRA NZ, .L43
001AD0  370003     BRA .L41
120:                       instance.trbInsert(2, trb, &status);
001A82  470076     ADD W14, #0x16, W0
001A84  780190     MOV [W0], W3
001A86  4700E4     ADD W14, #0x4, W1
001A88  470066     ADD W14, #0x6, W0
001A8A  780101     MOV W1, W2
001A8C  780080     MOV W0, W1
001A8E  B3C020     MOV.B #0x2, W0
001A90  010003     CALL W3
121:               
122:                       while(status == I2C1_MESSAGE_PENDING) {
001A92  37000E     BRA .L36
001AB0  470064     ADD W14, #0x4, W0
001AB2  780010     MOV [W0], W0
001AB4  500FE1     SUB W0, #0x1, [W15]
001AB6  32FFEE     BRA Z, .L39
123:                           DELAY_microseconds(500);
001A94  201F40     MOV #0x1F4, W0
001A96  07070A     RCALL DELAY_microseconds
124:                           
125:                           if (slaveTimeOut == _I2CB_DEVICE_TIMEOUT) return false;
001A98  E8800E     INC2 W14, W0
001A9A  780090     MOV [W0], W1
001A9C  200320     MOV #0x32, W0
001A9E  508F80     SUB W1, W0, [W15]
001AA0  3A0002     BRA NZ, .L37
001AA2  EB4000     CLR.B W0
001AA4  370021     BRA .L38
126:                           else slaveTimeOut++;
001AA6  E8800E     INC2 W14, W0
001AA8  780010     MOV [W0], W0
001AAA  E80080     INC W0, W1
001AAC  E8800E     INC2 W14, W0
001AAE  780801     MOV W1, [W0]
127:                       }
128:               
129:                       if (status == I2C1_MESSAGE_COMPLETE) break;
001AB8  470064     ADD W14, #0x4, W0
001ABA  780010     MOV [W0], W0
001ABC  500FE2     SUB W0, #0x2, [W15]
001ABE  320009     BRA Z, .L44
001AD2  000000     NOP
001AD4  370001     BRA .L41
130:               
131:                       if (retryTimeOut == _I2CB_RETRY_MAX) break;
001AC0  78001E     MOV [W14], W0
001AC2  500FEA     SUB W0, #0xA, [W15]
001AC4  320008     BRA Z, .L45
001AD6  000000     NOP
132:                       else retryTimeOut++;
001AC6  E80F1E     INC [W14], [W14]
133:                   }
134:               
135:                   return status == I2C1_MESSAGE_COMPLETE;
001AD8  470064     ADD W14, #0x4, W0
001ADA  780010     MOV [W0], W0
001ADC  A21000     BTG W0, #1
001ADE  A7F000     BTSC W0, #15
001AE0  EA0000     NEG W0, W0
001AE2  E90000     DEC W0, W0
001AE4  DE004F     LSR W0, #15, W0
001AE6  784000     MOV.B W0, W0
136:               }
001AE8  78044F     MOV [--W15], W8
001AEA  FA8000     ULNK
001AEC  060000     RETURN
137:               
138:               int16_t I2CB_CmdRead8(I2CB_INSTANCE instance, uint16_t address, uint8_t command) {
001AEE  FA0010     LNK #0x10
001AF0  E8838E     INC2 W14, W7
001AF2  780B80     MOV W0, [W7]
001AF4  470064     ADD W14, #0x4, W0
001AF6  780801     MOV W1, [W0]
001AF8  470066     ADD W14, #0x6, W0
001AFA  780802     MOV W2, [W0]
001AFC  470068     ADD W14, #0x8, W0
001AFE  780803     MOV W3, [W0]
001B00  47006A     ADD W14, #0xA, W0
001B02  780804     MOV W4, [W0]
001B04  47006C     ADD W14, #0xC, W0
001B06  780805     MOV W5, [W0]
001B08  47006E     ADD W14, #0xE, W0
001B0A  784806     MOV.B W6, [W0]
139:                   int16_t res = 0;
001B0C  EB0000     CLR W0
001B0E  780F00     MOV W0, [W14]
140:                   if (!I2CB_CmdRead(instance, address, command, (uint8_t*)&res, 1)) res = -1;
001B10  78000E     MOV W14, W0
001B12  B3C011     MOV.B #0x1, W1
001B14  781F81     MOV W1, [W15++]
001B16  780380     MOV W0, W7
001B18  47006E     ADD W14, #0xE, W0
001B1A  784310     MOV.B [W0], W6
001B1C  47006C     ADD W14, #0xC, W0
001B1E  780290     MOV [W0], W5
001B20  E8800E     INC2 W14, W0
001B22  780010     MOV [W0], W0
001B24  4700E4     ADD W14, #0x4, W1
001B26  780091     MOV [W1], W1
001B28  470166     ADD W14, #0x6, W2
001B2A  780112     MOV [W2], W2
001B2C  4701E8     ADD W14, #0x8, W3
001B2E  780193     MOV [W3], W3
001B30  47026A     ADD W14, #0xA, W4
001B32  780214     MOV [W4], W4
001B34  07FF76     RCALL I2CB_CmdRead
001B36  E9878F     DEC2 W15, W15
001B38  A20400     BTG.B W0, #0
001B3A  E00400     CP0.B W0
001B3C  320002     BRA Z, .L47
001B3E  EB8000     SETM W0
001B40  780F00     MOV W0, [W14]
141:                   return res;
001B42  78001E     MOV [W14], W0
142:               }
001B44  FA8000     ULNK
001B46  060000     RETURN
143:               
144:               int32_t I2CB_CmdRead16(I2CB_INSTANCE instance, uint16_t address, uint8_t command) {
001B48  FA0012     LNK #0x12
001B4A  4703E4     ADD W14, #0x4, W7
001B4C  780B80     MOV W0, [W7]
001B4E  470066     ADD W14, #0x6, W0
001B50  780801     MOV W1, [W0]
001B52  470068     ADD W14, #0x8, W0
001B54  780802     MOV W2, [W0]
001B56  47006A     ADD W14, #0xA, W0
001B58  780803     MOV W3, [W0]
001B5A  47006C     ADD W14, #0xC, W0
001B5C  780804     MOV W4, [W0]
001B5E  47006E     ADD W14, #0xE, W0
001B60  780805     MOV W5, [W0]
001B62  470070     ADD W14, #0x10, W0
001B64  784806     MOV.B W6, [W0]
145:                   int32_t res = 0;
001B66  B80060     MUL.UU W0, #0, W0
001B68  BE8F00     MOV.D W0, [W14]
146:                   if (!I2CB_CmdRead(instance, address, command, (uint8_t*)&res, 2)) res = -1;
001B6A  78000E     MOV W14, W0
001B6C  B3C021     MOV.B #0x2, W1
001B6E  781F81     MOV W1, [W15++]
001B70  780380     MOV W0, W7
001B72  470070     ADD W14, #0x10, W0
001B74  784310     MOV.B [W0], W6
001B76  47006E     ADD W14, #0xE, W0
001B78  780290     MOV [W0], W5
001B7A  470064     ADD W14, #0x4, W0
001B7C  780010     MOV [W0], W0
001B7E  4700E6     ADD W14, #0x6, W1
001B80  780091     MOV [W1], W1
001B82  470168     ADD W14, #0x8, W2
001B84  780112     MOV [W2], W2
001B86  4701EA     ADD W14, #0xA, W3
001B88  780193     MOV [W3], W3
001B8A  47026C     ADD W14, #0xC, W4
001B8C  780214     MOV [W4], W4
001B8E  07FF49     RCALL I2CB_CmdRead
001B90  E9878F     DEC2 W15, W15
001B92  A20400     BTG.B W0, #0
001B94  E00400     CP0.B W0
001B96  320003     BRA Z, .L49
001B98  EB8000     SETM W0
001B9A  EB8080     SETM W1
001B9C  BE8F00     MOV.D W0, [W14]
147:                   return res;
001B9E  BE001E     MOV.D [W14], W0
148:               }
001BA0  FA8000     ULNK
001BA2  060000     RETURN
149:               
150:               int64_t I2CB_CmdRead32(I2CB_INSTANCE instance, uint16_t address, uint8_t command) {
001BA4  FA0016     LNK #0x16
001BA6  4703E8     ADD W14, #0x8, W7
001BA8  780B80     MOV W0, [W7]
001BAA  47006A     ADD W14, #0xA, W0
001BAC  780801     MOV W1, [W0]
001BAE  47006C     ADD W14, #0xC, W0
001BB0  780802     MOV W2, [W0]
001BB2  47006E     ADD W14, #0xE, W0
001BB4  780803     MOV W3, [W0]
001BB6  470070     ADD W14, #0x10, W0
001BB8  780804     MOV W4, [W0]
001BBA  470072     ADD W14, #0x12, W0
001BBC  780805     MOV W5, [W0]
001BBE  470074     ADD W14, #0x14, W0
001BC0  784806     MOV.B W6, [W0]
151:                   int64_t res = 0;
001BC2  B80060     MUL.UU W0, #0, W0
001BC4  B81160     MUL.UU W2, #0, W2
001BC6  BE9F00     MOV.D W0, [W14++]
001BC8  BE9702     MOV.D W2, [W14--]
152:                   if (!I2CB_CmdRead(instance, address, command, (uint8_t*)&res, 4)) res = -1;
001BCA  78000E     MOV W14, W0
001BCC  B3C041     MOV.B #0x4, W1
001BCE  781F81     MOV W1, [W15++]
001BD0  780380     MOV W0, W7
001BD2  470074     ADD W14, #0x14, W0
001BD4  784310     MOV.B [W0], W6
001BD6  470072     ADD W14, #0x12, W0
001BD8  780290     MOV [W0], W5
001BDA  470068     ADD W14, #0x8, W0
001BDC  780010     MOV [W0], W0
001BDE  4700EA     ADD W14, #0xA, W1
001BE0  780091     MOV [W1], W1
001BE2  47016C     ADD W14, #0xC, W2
001BE4  780112     MOV [W2], W2
001BE6  4701EE     ADD W14, #0xE, W3
001BE8  780193     MOV [W3], W3
001BEA  470270     ADD W14, #0x10, W4
001BEC  780214     MOV [W4], W4
001BEE  07FF19     RCALL I2CB_CmdRead
001BF0  E9878F     DEC2 W15, W15
001BF2  A20400     BTG.B W0, #0
001BF4  E00400     CP0.B W0
001BF6  320005     BRA Z, .L51
001BF8  2FFFF0     MOV #0xFFFF, W0
001BFA  2FFFF1     MOV #0xFFFF, W1
001BFC  BE0100     MOV.D W0, W2
001BFE  BE9F00     MOV.D W0, [W14++]
001C00  BE9702     MOV.D W2, [W14--]
153:                   return res;
001C02  BE003E     MOV.D [W14++], W0
001C04  BE012E     MOV.D [W14--], W2
154:               }
001C06  FA8000     ULNK
001C08  060000     RETURN
155:               
---  E:/Users/Alex/Documents/eagle/projects/USBPD Supply/adapter/USBPD-Adapter.X/ap33772.h  -------------
1:                 #ifndef AP33772_H
2:                 #define	AP33772_H
3:                 
4:                 #include <xc.h> 
5:                 
6:                 typedef struct {
7:                     unsigned int __attribute__((packed)) maxCurrentx10mA : 10;
8:                     unsigned int __attribute__((packed)) voltageX50mV : 10;
9:                     unsigned int __attribute__((packed)) : 10;
10:                    unsigned int __attribute__((packed)) pdoType : 2;
11:                } AP33772_FPDO;
12:                
13:                typedef struct {
14:                    unsigned int __attribute__((packed)) maxCurrentx50mA : 7;
15:                    unsigned int __attribute__((packed)) : 1;
16:                    unsigned int __attribute__((packed)) minVoltagex100mV : 8;
17:                    unsigned int __attribute__((packed)) : 1;
18:                    unsigned int __attribute__((packed)) maxVoltagex100mV : 8;
19:                    unsigned int __attribute__((packed)) : 3;
20:                    unsigned int __attribute__((packed)) apdoType : 2;
21:                    unsigned int __attribute__((packed)) pdoType : 2;
22:                } AP33772_APDO;
23:                
24:                typedef union {
25:                    AP33772_FPDO fpdo;
26:                    AP33772_APDO apdo;
27:                } AP33772_PDO;
28:                
29:                typedef struct {
30:                    unsigned int __attribute__((packed)) maxCurrentx10mA : 10;
31:                    unsigned int __attribute__((packed)) minCurrentx10mA : 10;
32:                    unsigned int __attribute__((packed)) : 8;
33:                    unsigned int __attribute__((packed)) pdoIndex : 3;
34:                    unsigned int __attribute__((packed)) : 1;
35:                } AP33772_FRDO;
36:                
37:                typedef struct {
38:                    unsigned int __attribute__((packed)) currentx50mA : 7;
39:                    unsigned int __attribute__((packed)) : 2;
40:                    unsigned int __attribute__((packed)) voltagex20mV : 11;
41:                    unsigned int __attribute__((packed)) : 8;
42:                    unsigned int __attribute__((packed)) pdoIndex : 3;
43:                    unsigned int __attribute__((packed)) : 1;
44:                } AP33772_PRDO;
45:                
46:                typedef union {
47:                    AP33772_FRDO frdo;
48:                    AP33772_PRDO prdo;
49:                } AP33772_RDO;
50:                
51:                #ifdef	__cplusplus
52:                extern "C" {
53:                #endif /* __cplusplus */
54:                    
55:                    int test() {
0029C6  FA0000     LNK #0x0
56:                        return sizeof(AP33772_RDO);
0029C8  200040     MOV #0x4, W0
57:                    }
0029CA  FA8000     ULNK
0029CC  060000     RETURN
58:                
59:                #ifdef	__cplusplus
60:                }
61:                #endif /* __cplusplus */
62:                
63:                #endif	/* AP33772_H */
64:                
---  /home/xc16/release-builds/build_20220124/src/libm/src/umodsi3.s  -----------------------------------
000904  07FFEF     RCALL ___udivsi3
000906  BE0004     MOV.D W4, W0
000908  060000     RETURN
---  /home/xc16/release-builds/build_20220124/src/libm/src/udivsi3.s  -----------------------------------
0008E4  B82260     MUL.UU W4, #0, W4
0008E6  200206     MOV #0x20, W6
0008E8  D00000     SL W0, W0
0008EA  D28081     RLC W1, W1
0008EC  D28204     RLC W4, W4
0008EE  D28285     RLC W5, W5
0008F0  A00000     BSET W0, #0
0008F2  520202     SUB W4, W2, W4
0008F4  5A8283     SUBB W5, W3, W5
0008F6  310003     BRA C, iterate
0008F8  420202     ADD W4, W2, W4
0008FA  4A8283     ADDC W5, W3, W5
0008FC  A10000     BCLR W0, #0
0008FE  E90306     DEC W6, W6
000900  3AFFF3     BRA NZ, nextbit
000902  060000     RETURN
---  /home/xc16/release-builds/build_20220124/src/libm/src/mulsi3.s  ------------------------------------
0009DE  B90A02     MUL.SU W1, W2, W4
0009E0  B91B00     MUL.SU W3, W0, W6
0009E2  B80002     MUL.UU W0, W2, W0
0009E4  420081     ADD W4, W1, W1
0009E6  430081     ADD W6, W1, W1
0009E8  060000     RETURN
---  /home/xc16/release-builds/build_20220124/src/libm/src/modsi3.s  ------------------------------------
0008C6  781F81     MOV W1, [W15++]
0008C8  E00001     CP0 W1
0008CA  3D0002     BRA GE, modtestb
0008CC  100060     SUBR W0, #0x0, W0
0008CE  1880E0     SUBBR W1, #0x0, W1
0008D0  E00003     CP0 W3
0008D2  3D0002     BRA GE, calcrem
0008D4  110160     SUBR W2, #0x0, W2
0008D6  1981E0     SUBBR W3, #0x0, W3
0008D8  070015     RCALL ___umodsi3
0008DA  E0004F     CP0 [--W15]
0008DC  3B0002     BRA NN, exitr
0008DE  100060     SUBR W0, #0x0, W0
0008E0  1880E0     SUBBR W1, #0x0, W1
0008E2  060000     RETURN
---  /home/xc16/release-builds/build_20220124/src/libm/src/divsi3.s  ------------------------------------
0008A8  689F83     XOR W1, W3, [W15++]
0008AA  E00001     CP0 W1
0008AC  3D0002     BRA GE, divtestb
0008AE  100060     SUBR W0, #0x0, W0
0008B0  1880E0     SUBBR W1, #0x0, W1
0008B2  E00003     CP0 W3
0008B4  3D0002     BRA GE, calcquot
0008B6  110160     SUBR W2, #0x0, W2
0008B8  1981E0     SUBBR W3, #0x0, W3
0008BA  070014     RCALL ___udivsi3
0008BC  E0004F     CP0 [--W15]
0008BE  3B0002     BRA NN, returnq
0008C0  100060     SUBR W0, #0x0, W0
0008C2  1880E0     SUBBR W1, #0x0, W1
0008C4  060000     RETURN
